{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"Interfaz%20fluida/","title":"Fluent Interface","text":""},{"location":"OOP_Curso_Youtube_Runtimevic/","title":"OOP Curso Youtube Runtimevic","text":"<p> \ud83d\udcd6 Curso Programaci\u00f3n Orientada a Objetos Youtube -- OOP : </p> <p>  by Runtimevic -- V\u00edctor Dur\u00e1n Mu\u00f1oz. </p> <p> . \u00bf Qu\u00e9 es OOP?   . \u00bf Qu\u00e9 es OOP?   - Es un paradigma que hace uso de los objetos para la construcci\u00f3n de los software.       . \u00bf Qu\u00e9 es un paradigma?     - Tiene diferentes interpretaciones, puede ser un **modelo**, **ejemplo** o **patr\u00f3n.**     - Es una **forma** o un **estilo** de programar. - se busca plasmar la realidad hacia el c\u00f3digo.   . \u00bfC\u00f3mo pensar en Objetos?   - Enfocarse en **algo de la realidad.** - Detalla sus **atributos, (propiedades)** - Detalla sus **comportamientos (metodos)**  <pre><code>Ejemplo: (telefono m\u00f3vil-smartphone)\n. \u00bfQu\u00e9 atributos reconocemos? (Propiedades)\n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - Realizar llamadas.\n    - Navegar por internet. \n</code></pre> ***  . Tipos de paradigmas:   - Imperativa -- (**Instrucciones a seguir** para dar soluci\u00f3n a un problema). - Declarativa -- (Se **enfoca en el problema** a solucionar). - Estructurada -- (La soluci\u00f3n a un problema sigue **una secuencia de inico a fin**). -  Orientada a objetos (Construye soluciones **basadas en objetos**).  - Funcional -- (Divide el problema en diversas soluciones que ser\u00e1n ejecutadas por las **funciones declaradas**). ***  . Clases y Objetos:   - Una Clase es una **plantilla**. - Un Objeto es la **instancia de una Clase**.  <p>   ***  . Principios OOP: (4 pilares)  - Abstracci\u00f3n -- La forma de **plasmar algo hacia el c\u00f3digo** para enfocarse en su uso. No enfocarnos tanto en que hay por detras del codigo si no en el uso de este. - Encapsulamiento -- No toda la informaci\u00f3n de nuestro objeto es **relevante y/o accesible** para el usuario. - Herencia -- Es la cualidad de **heredar caracteristicas** de otra clase. (EXTENDS) - Polimorfismo -- Las **m\u00faltiples formas** que puede obtener un objeto si comparte la misma **clase o interfaz**. (IMPLEMENTS)   <p> </p>  *** \u00bfComo conseguir el Polimorfismo?  .Interface: (INTERFACE) - Son un **contrato que obliga** a una clase a **implementar** las **propiedades** y/o **m\u00e9todos** definidos. - Son una plantilla (sin l\u00f3gica).  .Clases Abstractas: (ABSTRACT) - Son Clases que no se pueden instanciar, solo pueden ser implementadas a trav\u00e9s de la herencia.  - Diferencias:      | Clases abstractas | Interfaces |      | :--- | :--- |          | 1.- Limitadas a una sola implementaci\u00f3n.   | 1. No tiene limitaci\u00f3n de implementaci\u00f3n.     |      | 2.- Pueden definir comportamiento base.     | 2. Expone prpiedades y m\u00e9todos abstractos (sin l\u00f3gica).     |   *** .modificadores de acceso:  - public: son accesibles luego de instanciar la clase. - private: son accesibles dentro de la clase. - protected: son accesibles a trav\u00e9s de la herencia. - internal: *** .Propiedades: Getters &amp; Setters  para modificar directamente nuestras propiedades lo que se busca es que se haga a trav\u00e9s de los metodos Getters y Setters, el cual var\u00eda la escritura seg\u00fan el lenguaje pero el concepto es el mismo. *** .Relaciones:  Vamos a ver 2 tipos de relaciones:  - Asociaci\u00f3n.     - De uno a uno: Una clase mantiene una **asociaci\u00f3n de a uno** con otra clase.     - De uno a muchos: Una clase mantiene una asociaci\u00f3n con otra clase **a trav\u00e9s de una colecci\u00f3n**.     - De muchos a muchos: La **asociaci\u00f3n se da en ambos lados** a trav\u00e9s de una colecci\u00f3n. - Colaboraci\u00f3n.     - La colaboraci\u00f3n se da **a trav\u00e9s de una referencia de una clase** con el fin de **lograr un cometido**.    ***  . SOLID: (5 principios)   ![SOLID](./imagenes/SOLID.png) - Propuesta por **Robert C.Martin** en el 2000. - Son **recomendaciones** para escribir un c\u00f3digo **sostenible,mantenible,escalable y robusto**. - Beneficios:       - Alta **Cohesi\u00f3n**. Colaboracion entre clases.     - Bajo **Acoplamiento**. Evitar que una clase dependa fuertemente de otra clase.   - Principio de Responsabilidad \u00danica: Una clase debe tener **una raz\u00f3n** para existir mas no para cambiar. - Principio de Abierto/Cerrado: Las piezas del software deben estar **abiertas para la extensi\u00f3n** pero **cerradas para la modificaci\u00f3n**. - Principio de Sustituci\u00f3n de Liskov: Las **clases subtipos** deber\u00edan ser reemplazables por sus **clases padres**. - Principio de Segregaci\u00f3n de Interfaz: Varias **interfaces** funcionan **mejor que una sola**. - Principio de Inversi\u00f3n de Dependencia: Clases de **alto nivel** no deben depender de las clases **bajo nivel**. ***  ![OOP_Logo](./imagenes/OO_Logo.jpg)         \ud83d\udc69\u200d\ud83c\udfeb \ud83d\udc68\u200d\ud83c\udfeb   ![Placeholder](https://dummyimage.com/600x400/eee/aaa){: align=left }"},{"location":"SUPER%20pointer/","title":"SUPER pointer","text":""},{"location":"THIS%20pointer/","title":"THIS pointer","text":""},{"location":"Tabla%20de%20Modificadores%20de%20acceso/","title":"Access Modifiers Table","text":""},{"location":"Tipos%20de%20Dise%C3%B1o%20para%20programacion%20de%20PLC/","title":"Types of Design for PLC programming","text":""},{"location":"Tipos%20de%20datos/","title":"Types of data","text":""},{"location":"Variable%20types%20and%20special%20variables/","title":"Variable types and special variables","text":""},{"location":"Variable%20types%20and%20special%20variables/#variable-types-and-special-variables","title":"Variable types and special variables:","text":"<p>The variable type defines how and where you can use the variable. The variable type is defined during the variable declaration.</p>"},{"location":"Variable%20types%20and%20special%20variables/#further-information","title":"Further Information:","text":"<ul> <li>Local Variables - VAR</li> <li>Input Variables - VAR_INPUT</li> <li>Output Variables - VAR_OUTPUT</li> <li>Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</li> <li>Global Variables - VAR_GLOBAL<ul> <li>Solo es posible su declaraci\u00f3n en GVL (Lista de Variables Global)</li> </ul> </li> <li>Temporary Variable - VAR_TEMP<ul> <li>Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.</li> <li>Las variables temporales se declaran localmente entre las palabras clave VAR_TEMP y END_VAR.</li> <li>VAR_TEMP declaraciones s\u00f3lo son posibles en programas y bloques de funciones.</li> <li>TwinCAT reinicializa las variables temporales cada vez que se llama al bloque de funciones.</li> </ul> </li> </ul> <p>La aplicaci\u00f3n s\u00f3lo puede acceder a variables temporales en la parte de implementaci\u00f3n de un programa o bloque de funciones. - Static Variables - VAR_STAT     - Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.     - Las variables est\u00e1ticas se declaran localmente entre las palabras clave VAR_STAT y END_VAR. TwinCAT inicializa las variables est\u00e1ticas cuando se llama por primera vez al bloque de funciones respectivo.     - Puede tener acceso a las variables est\u00e1ticas s\u00f3lo dentro del espacio de nombres donde se declaran las variables (como es el caso de las variables est\u00e1ticas en C). Sin embargo, las variables est\u00e1ticas conservan su valor cuando la aplicaci\u00f3n sale del bloque de funciones. Puede utilizar variables est\u00e1ticas, como contadores para llamadas a funciones, por ejemplo.     - Puede extender variables est\u00e1ticas con una palabra clave de atributo.     - Las variables est\u00e1ticas solo existen una vez. Esto tambi\u00e9n se aplica a las variables est\u00e1ticas de un bloque de funciones o un m\u00e9todo de bloque de funciones, incluso si el bloque de funciones se instancia varias veces. - External Variables - VAR_EXTERNAL     - Las variables externas son variables globales que se \"importan\" en un bloque de funciones.     - Puede declarar las variables entre las palabras clave VAR_EXTERNAL y END_VAR. Si la variable global no existe, se emite un mensaje de error.     - En TwinCAT 3 PLC no es necesario que las variables se declaren como externas. La palabra clave existe para mantener la compatibilidad con IEC 61131-3.     - Si, no obstante, utiliza variables externas, aseg\u00farese de abordar las variables asignadas (con AT %I o AT %Q) s\u00f3lo en la lista global de variables. El direccionamiento adicional de las instancias de variables locales dar\u00eda lugar a duplicaciones en la imagen del proceso.     - Estas variables declaradas tambien tiene que estar declarada la misma variable con el mismo nombre en una GVL (Lista de Varaibles Global) - Instance Variables - VAR_INST     - TwinCAT crea una variable VAR_INST de un m\u00e9todo no en la pila de m\u00e9todos como las variables VAR, sino en la pila de la instancia del bloque de funciones. Esto significa que la variable VAR_INST se comporta como otras variables de la instancia del bloque de funci\u00f3n y no se reinicializa cada vez que se llama al m\u00e9todo.     - VAR_INST variables solo est\u00e1n permitidas en los m\u00e9todos de un bloque de funciones, y el acceso a dicha variable solo est\u00e1 disponible dentro del m\u00e9todo. Puede supervisar los valores de las variables de instancia en la parte de declaraci\u00f3n del m\u00e9todo.     - Las variables de instancia no se pueden extender con una palabra clave de atributo. - Remanent Variables - PERSISTENT, RETAIN Las variables remanentes pueden conservar sus valores m\u00e1s all\u00e1 del tiempo de ejecuci\u00f3n habitual del programa. Las variables remanentes se pueden declarar como variables RETAIN o incluso m\u00e1s estrictamente como variables PERSISTENTES en el proyecto PLC.</p> <p>Un requisito previo para la funcionalidad completa de las variables RETAIN es un \u00e1rea de memoria correspondiente en el controlador (NovRam). Las variables persistentes se escriben solo cuando TwinCAT se apaga. Esto requerir\u00e1 generalmente un UPS correspondiente. Excepci\u00f3n: Las variables persistentes tambi\u00e9n se pueden escribir con el bloque de funci\u00f3n FB_WritePersistentData.</p> <p>Si el \u00e1rea de memoria correspondiente no existe, los valores de las variables RETAIN y PERSISTENT se pierden durante un corte de energ\u00eda.</p> <p>Variables remanentes - PERSISTENT, RETAIN 1:   La declaraci\u00f3n AT no debe utilizarse en combinaci\u00f3n con VAR RETAIN o VAR PERSISTENT.</p> <p>Variables persistentes Puede declarar variables persistentes agregando la palabra clave PERSISTENT despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables PERSISTENTES conservan su valor despu\u00e9s de una terminaci\u00f3n no controlada, un Reset cold o una nueva descarga del proyecto PLC. Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. En otras palabras, TwinCAT solo reinicializa las variables PERSISTENTES durante un origen de Restablecer.</p> <p>Un ejemplo de aplicaci\u00f3n para variables persistentes es un contador de horas de funcionamiento, que debe continuar contando despu\u00e9s de un corte de energ\u00eda y cuando el proyecto PLC se descarga nuevamente.</p> <p>Tabla de informaci\u00f3n general que muestra el comportamiento de las variables PERSISTENTES Despu\u00e9s del comando en l\u00ednea</p> <p>VAR PERSISTENTE</p> <p>Restablecer fr\u00edo</p> <p>Los valores se conservan</p> <p>Restablecer origen</p> <p>Los valores se reinicializan</p> <p>Descargar</p> <p>Los valores se conservan</p> <p>Cambio en l\u00ednea</p> <p>Los valores se conservan</p> <p>Evite usar el tipo de datos POINTER TO en listas de variables persistentes, ya que los valores de direcci\u00f3n pueden cambiar cuando el proyecto PLC se descargue nuevamente. TwinCAT emite las advertencias correspondientes del compilador. Declarar una variable local como PERSISTENTE en una funci\u00f3n no tiene ning\u00fan efecto. La persistencia de datos no se puede utilizar de esta manera. El comportamiento durante un restablecimiento en fr\u00edo puede verse influenciado por el pragma 'TcInitOnReset'</p> <p>Variables RETAIN Puede declarar variables RETAIN agregando la palabra clave RETAIN despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables declaradas como RETAIN dependen del sistema de destino, pero normalmente se administran en un \u00e1rea de memoria separada que debe protegerse contra fallas de energ\u00eda. El llamado controlador Retain asegura que las variables RETAIN se escriban al final de un ciclo PLC y solo en el \u00e1rea correspondiente de la NovRam. El manejo del controlador de retenci\u00f3n se describe en el cap\u00edtulo \"Conservar datos\" de la documentaci\u00f3n de C/C++.</p> <p>Las variables RETAIN conservan su valor despu\u00e9s de una terminaci\u00f3n incontrolada (corte de energ\u00eda). Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. TwinCAT reinicializa las variables RETAIN en un origen de restablecimiento.</p> <p>Una posible aplicaci\u00f3n es un contador de piezas en una planta de producci\u00f3n, que debe seguir contando despu\u00e9s de un corte de energ\u00eda.</p> <p>Tabla general que muestra el comportamiento de las variables RETAIN Despu\u00e9s del comando en l\u00ednea</p> <p>RETENCI\u00d3N DE VAR</p> <p>Restablecer fr\u00edo</p> <p>Los valores se conservan</p> <p>Restablecer origen</p> <p>Los valores se reinicializan</p> <p>Descargar</p> <p>Los valores se conservan - SUPER - THIS - Variable types - attribute keywords     - RETAIN: for remanent variables of type RETAIN     - PERSISTENT: for remanent variables of type PERSISTENT     - CONSTANT: for constants</p>"},{"location":"Variable%20types%20and%20special%20variables/#_1","title":"Variable types and special variables","text":"<ul> <li> <p>\ud83d\udd17 infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/instance-variables-with-var_inst</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/var_temp-var_stat-and-var_const</p> </li> <li> <p>\ud83d\udd17 Tipos de variables y variables especiales </p> </li> </ul> <p></p> <p></p>"},{"location":"inicio/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"inicio/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"inicio/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"inicio/#welcome-to-my-docs","title":"Welcome to My Docs","text":"<p>This is the front page of My Docs.</p>"},{"location":"inicio/#sub","title":"Sub","text":"<p>This is another section.</p>"},{"location":"links/","title":"Links","text":""},{"location":"page3/","title":"Page3","text":""},{"location":"page3/#esta-es-la-pagina-3","title":"esta es la pagina 3","text":""},{"location":"page3/#contact","title":"contact","text":"<p>este es mi contacto: Victor</p> <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa....</p> <pre><code>diagrama de clase\nnota \"De pato a cebra\"\nAnimal &lt;|-- Duck\nnote for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\"\nAnimal &lt;|-- Fish\nAnimal &lt;|-- Zebra\nAnimal : +int age\nAnimal : +String gender\nAnimal: +isMammal()\nAnimal: +mate()\nclass Duck{\n    +String beakColor\n    +swim()\n    +quack()\n}\nclass Fish{\n    -int sizeInFeet\n    -canEat()\n}\nclass Zebra{\n    +bool is_wild\n    +run()\n}</code></pre> <pre><code>graph TD\nA[Client] --&gt; B[Load Balancer]\nB --&gt; C[Server01]\nB --&gt; D[Server02]</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre> <pre><code>classDiagram\n  Person &lt;|-- Student\n  Person &lt;|-- Professor\n  Person : +String name\n  Person : +String phoneNumber\n  Person : +String emailAddress\n  Person: +purchaseParkingPass()\n  Address \"1\" &lt;-- \"0..1\" Person:lives at\n  class Student{\n    +int studentNumber\n    +int averageMark\n    +isEligibleToEnrol()\n    +getSeminarsTaken()\n  }\n  class Professor{\n    +int salary\n  }\n  class Address{\n    +String street\n    +String city\n    +String state\n    +int postalCode\n    +String country\n    -validate()\n    +outputAsLabel()  \n  }</code></pre>"},{"location":"page4/","title":"Page4","text":""},{"location":"page4/#esta-es-la-pagina-400","title":"esta es la pagina 4.0.0","text":"<p><code>Bold Code</code></p>"},{"location":"page4/#my-first-article","title":"My first article","text":"<p>This is my first article with some code:</p> <pre><code>class Test\n{\nstatic void Main()\n{\nConsole.WriteLine(\"Hello World\");\n}\n}\n</code></pre>"},{"location":"page4/#esta-es-la-pagina-1","title":"esta es la pagina 1","text":"Image caption <pre><code>  graph TD;\n      A--&gt;B;\n      A--&gt;C;\n      B--&gt;D;\n      C--&gt;D;</code></pre>"},{"location":"relaciones/","title":"Relations","text":""},{"location":"requeriments/","title":"Requeriments","text":""},{"location":"tipos%20de%20paradigmas/","title":"Types of paradigms","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/","title":"Constructor and Destructor","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/","title":"Abstract FB vs. Interface","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/","title":"Function Block Declaration variables","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/","title":"Function Block Access Modifiers","text":""},{"location":"Clases%20y%20Objetos/Function%20Block/","title":"Function Block","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/","title":"Method Declaration of variables","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/","title":"Method access modifiers","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/","title":"Method return variable types","text":""},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/","title":"Classes and Objects","text":""},{"location":"Clases%20y%20Objetos/herencia/","title":"Inheritance","text":""},{"location":"Clases%20y%20Objetos/interface/","title":"Interface","text":""},{"location":"Clases%20y%20Objetos/metodo/","title":"Method","text":""},{"location":"Clases%20y%20Objetos/modificadores%20de%20acceso/","title":"Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/propiedad/","title":"Property","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/","title":"Design patterns","text":""},{"location":"UML/Class%20UML/","title":"Class UML","text":""},{"location":"UML/Statechart%20UML/","title":"StateChart UML","text":""},{"location":"UML/UML/","title":"UML","text":""},{"location":"principios/_principios%20OOP/","title":"4 Pillars","text":""},{"location":"principios/abstraccion/","title":"Abstraction","text":""},{"location":"principios/encapsulamiento/","title":"Encapsulation","text":""},{"location":"principios/herencia/","title":"Inheritance","text":""},{"location":"principios/polimorfismo/","title":"Polymorphism","text":""},{"location":"solid/Principio%20de%20Abierto_Cerrado/","title":"Open/Closed Principle","text":""},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/","title":"Dependency Inversion Principle","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/","title":"Sole Responsibility Principle","text":""},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/","title":"Interface Segregation Principle","text":""},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/","title":"Liskov Substitution Principle","text":""},{"location":"solid/_SOLID/","title":"SOLID","text":""}]}