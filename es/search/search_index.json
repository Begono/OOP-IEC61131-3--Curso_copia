{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduccion","text":"<p> \ud83d\udcd6 Curso Programaci\u00f3n Orientada a Objetos Youtube -- OOP : </p> <p>  by Runtimevic -- V\u00edctor Dur\u00e1n Mu\u00f1oz. </p> <p> \u00bf Qu\u00e9 es OOP? </p> <ul> <li> <p>Es un paradigma que hace uso de los objetos para la construcci\u00f3n de los software.</p> <p>. \u00bf Qu\u00e9 es un paradigma?</p> <ul> <li>Tiene diferentes interpretaciones, puede ser un modelo, ejemplo o patr\u00f3n.</li> <li>Es una forma o un estilo de programar.</li> <li>se busca plasmar la realidad hacia el c\u00f3digo.</li> </ul> </li> </ul> <p> . \u00bfC\u00f3mo pensar en Objetos? </p> <ul> <li>Enfocarse en algo de la realidad.</li> <li>Detalla sus atributos, (propiedades)</li> <li>Detalla sus comportamientos (metodos)</li> </ul> <pre><code>\ud83d\udcf1 Ejemplo: (Telefono m\u00f3vil-smartphone)\n\n. \u00bfQu\u00e9 atributos (Propiedades) reconocemos? \n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - Realizar llamadas.\n    - Navegar por internet. \n</code></pre> <pre><code>\ud83d\ude97 Ejemplo: (Coche)\n\n. \u00bfQu\u00e9 atributos (Propiedades) reconocemos? \n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - conducir.\n    - frenar. \n    - acelerar.\n</code></pre> <p>\ud83d\udd17 Codesys admite OOP</p> <p>\ud83d\udd17 Beckhoff TwinCAT 3 admite OOP</p>"},{"location":"OOP_Curso_Youtube_Runtimevic/","title":"OOP Curso Youtube Runtimevic","text":"<p> \ud83d\udcd6 Curso Programaci\u00f3n Orientada a Objetos Youtube -- OOP : </p> <p>  by Runtimevic -- V\u00edctor Dur\u00e1n Mu\u00f1oz. </p> <p> . \u00bf Qu\u00e9 es OOP?   . \u00bf Qu\u00e9 es OOP?   - Es un paradigma que hace uso de los objetos para la construcci\u00f3n de los software.       . \u00bf Qu\u00e9 es un paradigma?     - Tiene diferentes interpretaciones, puede ser un **modelo**, **ejemplo** o **patr\u00f3n.**     - Es una **forma** o un **estilo** de programar. - se busca plasmar la realidad hacia el c\u00f3digo.   . \u00bfC\u00f3mo pensar en Objetos?   - Enfocarse en **algo de la realidad.** - Detalla sus **atributos, (propiedades)** - Detalla sus **comportamientos (metodos)**  <pre><code>Ejemplo: (telefono m\u00f3vil-smartphone)\n. \u00bfQu\u00e9 atributos reconocemos? (Propiedades)\n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - Realizar llamadas.\n    - Navegar por internet. \n</code></pre> ***  . Tipos de paradigmas:   - Imperativa -- (**Instrucciones a seguir** para dar soluci\u00f3n a un problema). - Declarativa -- (Se **enfoca en el problema** a solucionar). - Estructurada -- (La soluci\u00f3n a un problema sigue **una secuencia de inico a fin**). -  Orientada a objetos (Construye soluciones **basadas en objetos**).  - Funcional -- (Divide el problema en diversas soluciones que ser\u00e1n ejecutadas por las **funciones declaradas**). ***  . Clases y Objetos:   - Una Clase es una **plantilla**. - Un Objeto es la **instancia de una Clase**.  <p>   ***  . Principios OOP: (4 pilares)  - Abstracci\u00f3n -- La forma de **plasmar algo hacia el c\u00f3digo** para enfocarse en su uso. No enfocarnos tanto en que hay por detras del codigo si no en el uso de este. - Encapsulamiento -- No toda la informaci\u00f3n de nuestro objeto es **relevante y/o accesible** para el usuario. - Herencia -- Es la cualidad de **heredar caracteristicas** de otra clase. (EXTENDS) - Polimorfismo -- Las **m\u00faltiples formas** que puede obtener un objeto si comparte la misma **clase o interfaz**. (IMPLEMENTS)   <p> </p>  *** \u00bfComo conseguir el Polimorfismo?  .Interface: (INTERFACE) - Son un **contrato que obliga** a una clase a **implementar** las **propiedades** y/o **m\u00e9todos** definidos. - Son una plantilla (sin l\u00f3gica).  .Clases Abstractas: (ABSTRACT) - Son Clases que no se pueden instanciar, solo pueden ser implementadas a trav\u00e9s de la herencia.  - Diferencias:      | Clases abstractas | Interfaces |      | :--- | :--- |          | 1.- Limitadas a una sola implementaci\u00f3n.   | 1. No tiene limitaci\u00f3n de implementaci\u00f3n.     |      | 2.- Pueden definir comportamiento base.     | 2. Expone prpiedades y m\u00e9todos abstractos (sin l\u00f3gica).     |   *** .modificadores de acceso:  - public: son accesibles luego de instanciar la clase. - private: son accesibles dentro de la clase. - protected: son accesibles a trav\u00e9s de la herencia. - internal: *** .Propiedades: Getters &amp; Setters  para modificar directamente nuestras propiedades lo que se busca es que se haga a trav\u00e9s de los metodos Getters y Setters, el cual var\u00eda la escritura seg\u00fan el lenguaje pero el concepto es el mismo. *** .Relaciones:  Vamos a ver 2 tipos de relaciones:  - Asociaci\u00f3n.     - De uno a uno: Una clase mantiene una **asociaci\u00f3n de a uno** con otra clase.     - De uno a muchos: Una clase mantiene una asociaci\u00f3n con otra clase **a trav\u00e9s de una colecci\u00f3n**.     - De muchos a muchos: La **asociaci\u00f3n se da en ambos lados** a trav\u00e9s de una colecci\u00f3n. - Colaboraci\u00f3n.     - La colaboraci\u00f3n se da **a trav\u00e9s de una referencia de una clase** con el fin de **lograr un cometido**.    ***  . SOLID: (5 principios)   ![SOLID](./imagenes/SOLID.png) - Propuesta por **Robert C.Martin** en el 2000. - Son **recomendaciones** para escribir un c\u00f3digo **sostenible,mantenible,escalable y robusto**. - Beneficios:       - Alta **Cohesi\u00f3n**. Colaboracion entre clases.     - Bajo **Acoplamiento**. Evitar que una clase dependa fuertemente de otra clase.   - Principio de Responsabilidad \u00danica: Una clase debe tener **una raz\u00f3n** para existir mas no para cambiar. - Principio de Abierto/Cerrado: Las piezas del software deben estar **abiertas para la extensi\u00f3n** pero **cerradas para la modificaci\u00f3n**. - Principio de Sustituci\u00f3n de Liskov: Las **clases subtipos** deber\u00edan ser reemplazables por sus **clases padres**. - Principio de Segregaci\u00f3n de Interfaz: Varias **interfaces** funcionan **mejor que una sola**. - Principio de Inversi\u00f3n de Dependencia: Clases de **alto nivel** no deben depender de las clases **bajo nivel**. ***  ![OOP_Logo](./imagenes/OO_Logo.jpg)         \ud83d\udc69\u200d\ud83c\udfeb \ud83d\udc68\u200d\ud83c\udfeb   ![Placeholder](https://dummyimage.com/600x400/eee/aaa){: align=left }"},{"location":"SUPER%20pointer/","title":"SUPER puntero","text":""},{"location":"SUPER%20pointer/#super-puntero","title":"SUPER puntero:","text":"<p>cada bloque de funciones que se deriva de otro bloque de funciones tiene acceso a un puntero llamado SUPER .  Esto se puede usar para acceder a elementos (m\u00e9todos, propiedades, variables locales, etc.) desde el bloque de funciones principal.</p> <p>En lugar de copiar el c\u00f3digo del bloque de funciones principal al nuevo m\u00e9todo, el puntero SUPER se puede usar para llamar al m\u00e9todo desde el bloque de funciones  . Esto elimina la necesidad de copiar el c\u00f3digo.</p> <ul> <li>SUPER puntero Infosys Beckhoff</li> </ul>"},{"location":"THIS%20pointer/","title":"THIS puntero","text":""},{"location":"THIS%20pointer/#este-puntero","title":"ESTE puntero:","text":"<p>El puntero THIS est\u00e1 disponible para todos los bloques de funciones y apunta a la instancia de bloque de funciones actual.  Este puntero es necesario siempre que un m\u00e9todo contenga una variable local que oculte una variable en el bloque de funciones.</p> <p>Una declaraci\u00f3n de asignaci\u00f3n dentro del m\u00e9todo establece el valor de la variable local.  Si queremos que el m\u00e9todo establezca el valor de la variable local en el bloque de funciones, necesitamos usar el puntero THIS para acceder a \u00e9l.</p> <p>Al igual que con el puntero SUPER, el puntero THIS tambi\u00e9n debe estar siempre en may\u00fasculas.</p> <ul> <li>THIS puntero Infosys Beckhoff</li> </ul>"},{"location":"Tipos%20de%20datos/","title":"Tipos de Datos","text":""},{"location":"Tipos%20de%20datos/#tipos-de-datos","title":"tipos de datos:","text":""},{"location":"Tipos%20de%20datos/#las-ventajas-de-las-estructuras-de-datos","title":"Las ventajas de las estructuras de datos.","text":"<ul> <li>La principal aportaci\u00f3n de las estructuras de datos y los tipos de datos  creados por el usuario es la claridad y el orden del c\u00f3digo resultante.</li> </ul> <ul> <li> <p>Estructuras de datos: (STRUCT)</p> </li> <li> <p>Datos de usuario:UDT (User Data Type) Los UDT (User Data Type) son tipos de datos que el usuario crea a su medida,  seg\u00fan las necesidades de cada proyecto.</p> </li> </ul>"},{"location":"Variable%20types%20and%20special%20variables/","title":"Tipos de variables y variables especiales","text":""},{"location":"Variable%20types%20and%20special%20variables/#variable-types-and-special-variables","title":"Variable types and special variables:","text":"<p>The variable type defines how and where you can use the variable. The variable type is defined during the variable declaration.</p>"},{"location":"Variable%20types%20and%20special%20variables/#further-information","title":"Further Information:","text":"<ul> <li>Local Variables - VAR</li> <li>Input Variables - VAR_INPUT</li> <li>Output Variables - VAR_OUTPUT</li> <li>Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</li> <li>Global Variables - VAR_GLOBAL</li> <li>Temporary Variable - VAR_TEMP</li> <li>Static Variables - VAR_STAT</li> <li>External Variables - VAR_EXTERNAL</li> <li>Instance Variables - VAR_INST</li> <li>Remanent Variables - PERSISTENT, RETAIN</li> <li>SUPER</li> <li>THIS</li> <li>Variable types - attribute keywords<ul> <li>RETAIN: for remanent variables of type RETAIN</li> <li>PERSISTENT: for remanent variables of type PERSISTENT</li> <li>CONSTANT: for constants</li> </ul> </li> </ul>"},{"location":"Variable%20types%20and%20special%20variables/#_1","title":"Tipos de variables y variables especiales","text":"<ul> <li> <p>\ud83d\udd17 infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/instance-variables-with-var_inst</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/var_temp-var_stat-and-var_const</p> </li> <li> <p>\ud83d\udd17 Tipos de variables y variables especiales</p> </li> </ul>"},{"location":"inicio/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"inicio/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"inicio/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"inicio/#welcome-to-my-docs","title":"Welcome to My Docs","text":"<p>This is the front page of My Docs.</p>"},{"location":"inicio/#sub","title":"Sub","text":"<p>This is another section.</p>"},{"location":"links/","title":"Links","text":""},{"location":"links/#links","title":"Links","text":""},{"location":"modificadores%20de%20acceso/","title":"Modificadores de acceso","text":""},{"location":"modificadores%20de%20acceso/#modificadores-de-acceso","title":"modificadores de acceso:","text":"<ul> <li>public: son accesibles luego de instanciar la clase.</li> <li>private: son accesibles dentro de la clase.</li> <li>protected: son accesibles a trav\u00e9s de la herencia.</li> <li>internal:</li> </ul> <ul> <li>PUBLIC: Corresponds to the specification of no access modifier</li> <li>PRIVATE: Access to the method is restricted to the function block or the program respectively.</li> <li>PROTECTED: Access to the method is restricted to the program or the function block and its derivatives respectively.</li> <li> <p>INTERNAL: Access to the method is limited to the namespace (the library). In addition to these access modifiers, you can manually add the FINAL modifier to a method:</p> </li> <li> <p>FINAL: Overwriting the method in a derivative of the function block is not allowed. This means that the method may not be overwritten/extended in a possibly existing subclass.</p> </li> </ul>"},{"location":"page3/","title":"Page3","text":""},{"location":"page3/#esta-es-la-pagina-3","title":"esta es la pagina 3","text":""},{"location":"page3/#contact","title":"contact","text":"<p>este es mi contacto: Victor</p> <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa....</p> <pre><code>diagrama de clase\nnota \"De pato a cebra\"\nAnimal &lt;|-- Duck\nnote for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\"\nAnimal &lt;|-- Fish\nAnimal &lt;|-- Zebra\nAnimal : +int age\nAnimal : +String gender\nAnimal: +isMammal()\nAnimal: +mate()\nclass Duck{\n    +String beakColor\n    +swim()\n    +quack()\n}\nclass Fish{\n    -int sizeInFeet\n    -canEat()\n}\nclass Zebra{\n    +bool is_wild\n    +run()\n}</code></pre> <pre><code>graph TD\nA[Client] --&gt; B[Load Balancer]\nB --&gt; C[Server01]\nB --&gt; D[Server02]</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre> <pre><code>classDiagram\n  Person &lt;|-- Student\n  Person &lt;|-- Professor\n  Person : +String name\n  Person : +String phoneNumber\n  Person : +String emailAddress\n  Person: +purchaseParkingPass()\n  Address \"1\" &lt;-- \"0..1\" Person:lives at\n  class Student{\n    +int studentNumber\n    +int averageMark\n    +isEligibleToEnrol()\n    +getSeminarsTaken()\n  }\n  class Professor{\n    +int salary\n  }\n  class Address{\n    +String street\n    +String city\n    +String state\n    +int postalCode\n    +String country\n    -validate()\n    +outputAsLabel()  \n  }</code></pre>"},{"location":"page4/","title":"Page4","text":""},{"location":"page4/#esta-es-la-pagina-400","title":"esta es la pagina 4.0.0","text":"<p><code>Bold Code</code></p>"},{"location":"page4/#my-first-article","title":"My first article","text":"<p>This is my first article with some code:</p> <pre><code>class Test\n{\nstatic void Main()\n{\nConsole.WriteLine(\"Hello World\");\n}\n}\n</code></pre>"},{"location":"page4/#esta-es-la-pagina-1","title":"esta es la pagina 1","text":"Image caption <pre><code>  graph TD;\n      A--&gt;B;\n      A--&gt;C;\n      B--&gt;D;\n      C--&gt;D;</code></pre>"},{"location":"relaciones/","title":"Relaciones","text":"<p>.Relaciones:</p> <p>Vamos a ver 2 tipos de relaciones:</p> <ul> <li>Asociaci\u00f3n.<ul> <li>De uno a uno: Una clase mantiene una asociaci\u00f3n de a uno con otra clase.</li> <li>De uno a muchos: Una clase mantiene una asociaci\u00f3n con otra clase a trav\u00e9s de una colecci\u00f3n.</li> <li>De muchos a muchos: La asociaci\u00f3n se da en ambos lados a trav\u00e9s de una colecci\u00f3n.</li> </ul> </li> <li>Colaboraci\u00f3n.<ul> <li>La colaboraci\u00f3n se da a trav\u00e9s de una referencia de una clase con el fin de lograr un cometido. </li> </ul> </li> </ul>"},{"location":"requisitos/","title":"Requisitos","text":"<p> \ud83d\udc68\u200d\ud83c\udf93 Requisitos \ud83d\udc69\u200d\ud83c\udf93 : </p> <p></p> <p>Los requisitos necesarios para seguir este curso ser\u00edan tener instalados los siguientes softwares:</p> <ul> <li>\ud83d\udd17 Beckhoff TwinCAT 3 XAE \u00f3 el IDE de \ud83d\udd17 Codesys.</li> <li>Tener cuenta de usuario creada en \ud83d\udd17 GitHub.</li> <li> <p>saber lo m\u00ednimo de Git o apoyarse en herramientas visuales como pueden ser:</p> <ul> <li>\ud83d\udd17 GitHub Desktop.</li> <li>\ud83d\udd17 sourcetree</li> <li>\ud83d\udd17 tortoiseGit, etc...</li> <li>Ser\u00eda bueno tener algo de conocimientos previos de teoria de OOP, aunque sean en otros lenguajes de programaci\u00f3n ya que seran extrapolables para el enfoque de este curso de OOP IEC61131-3 para PLCs.</li> </ul> </li> </ul>"},{"location":"requisitos/#pasos-para-empezar","title":"Pasos para empezar:","text":"<ul> <li> <p>Clonar el repositorio de \ud83d\udd17GitHub:</p> <p>$ git clone https://github.com/runtimevic/OOP-IEC61131-3--Curso-Youtube.git</p> <p>\u00f3 utilizar por ejemplo GitHub Desktop para Clonar el repositorio de GitHub...</p> </li> <li> <p>Nos encontraremos las siguientes carpetas:</p> <ul> <li>\ud83d\udd17 TC3_OOP: Dentro de esta carpeta se encuentra el proyecto de TwinCAT3, con todo lo que se va explicando en los videos de youtube...</li> <li>\ud83d\udd17 Ficheros_PLCOpen_XML: Dentro de esta carpeta nos iremos encontrando los ficheros exportados en formato PLCOpen XML para que puedan ser importados en TwinCAT3 \u00f3 en Codesys de todo lo explicado en Youtube, ya que al ser el formato standarizado de PLCOpen se puede exportar/importar en todas las marcas de PLCs que sigan el estandard PLCOpen..., pero es recomendable intentar realizar lo explicado desde cero para ir practicando y asumir los conceptos explicados...</li> <li>tambien esta alojada la creaci\u00f3n de esta pagina web SSG, (Generador de Sitios Est\u00e1ticos) la cual se ira modificando conforme avancemos en este Curso de OOP IEC-61131-3 PLC...</li> </ul> </li> </ul>"},{"location":"tipos%20de%20paradigmas/","title":"Tipos de paradigmas","text":"<p> . Tipos de paradigmas: </p> <ul> <li>Imperativa -- (Instrucciones a seguir para dar soluci\u00f3n a un problema).</li> <li>Declarativa -- (Se enfoca en el problema a solucionar).</li> <li>Estructurada -- (La soluci\u00f3n a un problema sigue una secuencia de inico a fin).</li> <li> <p>Funcional -- (Divide el problema en diversas soluciones que ser\u00e1n ejecutadas por las funciones declaradas). La programaci\u00f3n procedimental o programaci\u00f3n por procedimientos es un paradigma de la programaci\u00f3n. Muchas veces es aplicable tanto en lenguajes de programaci\u00f3n de bajo nivel como en lenguajes de alto nivel. En el caso de que esta t\u00e9cnica se aplique en lenguajes de alto nivel, recibir\u00e1 el nombre de programaci\u00f3n funcional.</p> <ul> <li>se llaman rutinas separadas desde el programa principal</li> <li>datos en su mayor\u00eda globales -&gt; sin protecci\u00f3n.</li> <li>los procedimientos por lo general no pueden ser independientes -&gt; mala reutilizaci\u00f3n del c\u00f3digo.</li> </ul> </li> </ul> <p></p> <ul> <li> Orientada a objetos  -- Construye soluciones basadas en objetos. <pre><code>wikipedia:\nLa programaci\u00f3n orientada a objetos es un paradigma de programaci\u00f3n\nbasado en el concepto de \"objetos\", que pueden contener datos y c\u00f3digo.\nLos datos est\u00e1n en forma de campos y el c\u00f3digo est\u00e1 en forma de procedimientos.\n</code></pre></li> </ul> <p></p>"},{"location":"tipos%20de%20paradigmas/#ventajas-de-la-programacion-oop","title":"Ventajas de la Programaci\u00f3n OOP:","text":"<ul> <li>rutinas y datos se combinan en un objeto -&gt; Encapsulaci\u00f3n.</li> <li>m\u00e9todos/Propiedades -&gt; interfaces definidas para llamadas y acceso a datos.</li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/","title":"Constructor y Destructor","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#metodos-fb_init-fb_reinit-y-fb_exit","title":"M\u00e9todos 'FB_Init', 'FB_Reinit' y 'FB_Exit'","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_init","title":"FB_Init:","text":"<ul> <li>Dependiendo de la tarea, puede ser necesario que los bloques de funciones requieran par\u00e1metros que solo se usan una vez para las tareas de inicializaci\u00f3n. Una forma posible de pasarlos elegantemente es usar el m\u00e9todo FB_init(). Este m\u00e9todo se ejecuta impl\u00edcitamente una vez antes de que se inicie la tarea del PLC y se puede utilizar para realizar tareas de inicializaci\u00f3n.</li> <li>Tambi\u00e9n es posible sobrescribir FB_init(). En este caso, las mismas variables de entrada deben existir en el mismo orden y ser del mismo tipo de datos que en el FB b\u00e1sico. Sin embargo, se pueden agregar m\u00e1s variables de entrada para que el bloque de funciones derivado reciba par\u00e1metros adicionales.</li> <li>Al pasar los par\u00e1metros por FB_init(),no se pueden leer desde el exterior ni cambiar en tiempo de ejecuci\u00f3n. La \u00fanica excepci\u00f3n ser\u00eda la llamada expl\u00edcita de FB_init() desde la tarea del PLC. Sin embargo, esto debe evitarse principalmente, ya que todas las variables locales de la instancia se reinicializar\u00e1n en este caso. Sin embargo, si a\u00fan debe ser posible el acceso, se pueden crear las propiedades apropiadas para los par\u00e1metros.</li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_reinit","title":"FB_Reinit:","text":"<p>Si es necesario, debe implementar FB_reinit expl\u00edcitamente. Si este m\u00e9todo est\u00e1 presente, se llama autom\u00e1ticamente despu\u00e9s de que se haya copiado la instancia del bloque de funci\u00f3n correspondiente (llamada impl\u00edcita). Esto sucede durante un cambio en l\u00ednea despu\u00e9s de cambios en la declaraci\u00f3n de bloque de funci\u00f3n (cambio de firma) para reinicializar el nuevo bloque de instancia. Este m\u00e9todo se llama despu\u00e9s de la operaci\u00f3n de copia y debe establecer valores definidos para las variables de la instancia. Por ejemplo, puede inicializar variables en consecuencia en la nueva ubicaci\u00f3n en la memoria o notificar a otras partes de la aplicaci\u00f3n sobre la nueva ubicaci\u00f3n de variables espec\u00edficas en la memoria. Dise\u00f1e la implementaci\u00f3n independientemente del cambio en l\u00ednea. El m\u00e9todo tambi\u00e9n se puede llamar desde la aplicaci\u00f3n en cualquier momento para restablecer una instancia de bloque de funciones a su estado original.</p>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_exit","title":"FB_Exit:","text":"<p>Si es necesario, debe implementar FB_exit expl\u00edcitamente. Si este m\u00e9todo est\u00e1 presente, se llama autom\u00e1ticamente (impl\u00edcitamente) antes de que el controlador elimine el c\u00f3digo de la instancia del bloque de funciones (por ejemplo, incluso si TwinCAT cambia del modo Ejecutar al modo de configuraci\u00f3n).</p> <p></p> <ul> <li> <p>\ud83d\udd17 M\u00e9todos FB_init, FB_reinit and FB_exit, Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 M\u00e9todos 'FB_Init', 'FB_Reinit' y 'FB_Exit', Codesys</p> </li> <li> <p>\ud83d\udd17 iec-61131-3-parameter-transfer-via-fb_init, stefanhenneken.net</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block/","title":"Bloques de Funciones","text":""},{"location":"Clases%20y%20Objetos/Function%20Block/#declaracion-de-un-function-block","title":"Declaracion de un Function Block:","text":"<pre><code>FUNCTION_BLOCK &lt;access specifier&gt; &lt;function block&gt; | EXTENDS &lt;function block&gt; | IMPLEMENTS &lt;comma-separated list of interfaces&gt;\n</code></pre>"},{"location":"Clases%20y%20Objetos/Function%20Block/#implementacion-bloque-de-funciones","title":"Implementaci\u00f3n Bloque de Funciones:","text":""},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/","title":"Clases y Objetos","text":"<p> . Clases y Objetos: </p> <ul> <li>Una Clase es una plantilla.</li> <li>Un Objeto es la instancia de una Clase.</li> </ul> <p></p> <p><pre><code>En este Ejemplo Nos encontramos la Clase Coche,\ny hemos instanciado esta Clase para tener los Objetos de Coches \nMercedes, Bmw y Audi...\n</code></pre> Representacion de la Clase Coche en STL OOP IEC61131-3 <pre><code>FUNCTION_BLOCK Coche\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n    _Marca : STRING;\n    _Color : STRING;\n    accion : STRING;\nEND_VAR\n----------------------------------------------------------------\nMETHOD PUBLIC Acelerar\naccion := 'acelerar';\n----------------------------------------------------------------\nMETHOD PUBLIC Conducir\naccion := 'conducir';\n----------------------------------------------------------------\nMETHOD PUBLIC Frenar\naccion := 'frenar';\n----------------------------------------------------------------\nPROPERTY PUBLIC Color : STRING\nGet\n    Color := _Color;\nSet\n    _Color := Color;\n----------------------------------------------------------------\nPROPERTY PUBLIC Marca : STRING\nGet\n    Marca := _Marca;\nSet\n    _Marca := Marca;\n</code></pre> Instancia de la clase en los Objetos: Mercedes,Bmw y Audi y llamadas a sus metodos y propiedades... <pre><code>PROGRAM _01_Clase_y_Objetos\nVAR\n    // tenemos la Clase Coche y la instanciamos y obtenemos los Objetos: Mercedes, Bmw y Audi.\n    Mercedes : Coche;\n    Bmw : Coche;\n    Audi: Coche;\n\n    Color : STRING;\n    Marca : STRING;\n\n    Acelerar : BOOL;\n    Conducir:  BOOL;\n    Frenar  : BOOL; \nEND_VAR\n\n//Objeto Mercedes\n//llamadas a sus m\u00e9todos.\nIF Acelerar THEN\n    Mercedes.Acelerar();\n    Acelerar := FALSE;\nEND_IF\n\nIF Conducir THEN\n    Mercedes.Conducir();\n    Conducir := FALSE;\nEND_IF\n\nIF Frenar THEN\n    Mercedes.Frenar();\n    Frenar := FALSE;\nEND_IF\n\n//llamadas a sus propiedades.\nMercedes.Marca := 'Mercedes';\nMercedes.Color := 'Negro';\nColor := Mercedes.Color;\n</code></pre></p> <ul> <li>\ud83d\udd17 methods-properties-and-inheritance (stefanhenneken)</li> </ul>"},{"location":"Clases%20y%20Objetos/herencia/","title":"Herencia","text":""},{"location":"Clases%20y%20Objetos/herencia/#herencia","title":"Herencia:","text":"<p>Los bloques de funciones son un medio excelente para mantener las secciones del programa separadas entre s\u00ed. Esto mejora la estructura del software y simplifica significativamente la reutilizaci\u00f3n. Anteriormente, ampliar la funcionalidad de un bloque de funciones existente siempre era una tarea delicada. Esto signific\u00f3 modificar el c\u00f3digo o programar un nuevo bloque de funciones alrededor del bloque existente (es decir, el bloque de funciones existente se incrust\u00f3 efectivamente dentro de un nuevo bloque de funciones). En el \u00faltimo caso, fue necesario crear todas las variables de entrada nuevamente y asignarlas a las variables de entrada para el bloque de funciones existente. Lo mismo se requer\u00eda, en sentido contrario, para las variables de salida.</p> <p>TwinCAT 3 introduce el concepto de herencia. La herencia es uno de los principios fundamentales de la programaci\u00f3n orientada a objetos. La herencia implica derivar un nuevo bloque de funciones a partir de un bloque de funciones existente. A continuaci\u00f3n, se puede ampliar el nuevo bloque. En la medida permitida por los especificadores de acceso del bloque de funciones principal, el nuevo bloque de funciones hereda todas las propiedades y m\u00e9todos del bloque de funciones principal. Cada bloque de funciones puede tener cualquier n\u00famero de bloques de funciones secundarios, pero solo un bloque de funciones principal. La derivaci\u00f3n de un bloque de funciones se produce en la nueva declaraci\u00f3n del bloque de funciones. El nombre del nuevo bloque de funciones va seguido de la palabra clave EXTENDS seguida del nombre del bloque de funciones principal. Por ejemplo:</p> <p>1 FUNCTION_BLOCK PUBLIC FB_NewEngine EXTENDS FB_Engine El nuevo bloque de funciones derivado ( FB_NewEngine ) posee todas las propiedades y m\u00e9todos de su padre ( FB_Engine ). Sin embargo, los m\u00e9todos y las propiedades solo se heredan cuando el especificador de acceso lo permite.</p> <p>El bloque de funciones secundario tambi\u00e9n hereda todas las variables locales, VAR_INPUT , VAR_OUTPUT y VAR_IN_OUT del bloque de funciones principal. Este comportamiento no se puede modificar mediante especificadores de acceso.</p> <p>Si los m\u00e9todos o las propiedades del bloque de funciones principal se han declarado como PROTEGIDOS , el bloque de funciones secundario ( FB_NewEngine ) podr\u00e1 acceder a ellos, pero no desde fuera de FB_NewEngine .</p> <p>La herencia se aplica solo a las POU de tipo FUNCTION_BLOCK .</p> <p>Especificadores de acceso Las declaraciones FUNCTION_BLOCK , FUNCTION o PROGRAM pueden incluir un especificador de acceso. Esto restringe el acceso y, en su caso, la capacidad de heredar.</p> <p>P\u00daBLICO Cualquiera puede llamar o crear una instancia de la POU. Adem\u00e1s, si la POU es un FUNCTION_BLOCK , se puede usar para la herencia. No se aplican restricciones. INTERNO La POU solo se puede utilizar dentro de su propio espacio de nombres. Esto permite que las POU est\u00e9n disponibles solo dentro de una determinada biblioteca, por ejemplo. FINAL   El FUNCTION_BLOCK no puede servir como un bloque de funciones principal. Los m\u00e9todos y las propiedades de esta POU no se pueden heredar. FINAL solo est\u00e1 permitido para POU del tipo FUNCTION_BLOCK . La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC . Los especificadores de acceso PRIVATE y PROTECTED no est\u00e1n permitidos en las declaraciones de POU.</p> <p>Si planea utilizar la herencia, la declaraci\u00f3n del bloque de funciones tendr\u00e1 la siguiente estructura:</p> <p>1 FUNCTION_BLOCK   EXTENDS  M\u00e9todos de sobrescritura El nuevo FUNCTION_BLOCK FB_NewEngine , que se deriva de FB_Engine , puede contener propiedades y m\u00e9todos adicionales. Por ejemplo, podemos agregar la propiedad Gear . Esta propiedad se puede utilizar para consultar y cambiar la marcha actual. Es necesario configurar getters y setters para esta propiedad. <p>Sin embargo, tambi\u00e9n debemos asegurarnos de que el par\u00e1metro nGear del m\u00e9todo Start() se pase a esta propiedad. Debido a que el bloque de funciones principal FB_Engine no tiene acceso a esta nueva propiedad, se debe crear un nuevo m\u00e9todo con exactamente los mismos par\u00e1metros en FB_NewEngine . Copiamos el c\u00f3digo existente al nuevo m\u00e9todo y agregamos nuevo c\u00f3digo para que el par\u00e1metro nGear se pase a la propiedad Gear .</p> <p>1 2 3 4 5 6 7 8 9 10 11 12 METHOD PUBLIC Start VAR_INPUT   nGear : INT := 2;   fVelocity : LREAL := 8.0; END_VAR </p> <p>IF (fVelocity &lt; MaxVelocity) THEN   velocityInternal := fVelocity; ELSE   velocityInternal := MaxVelocity; END_IF Gear := nGear; // new La l\u00ednea 12 copia el par\u00e1metro nGear a la propiedad Gear .</p> <p>Cuando un m\u00e9todo o propiedad que ya est\u00e1 presente en el bloque de funciones principal se redefine dentro del bloque de funciones secundario, esto se denomina sobrescritura. El bloque de funciones FB_NewEngine sobrescribe el m\u00e9todo Start() .</p> <p>Por lo tanto, FB_NewEngine tiene la nueva propiedad Gear y sobrescribe el m\u00e9todo Start() .</p> <p>imagen05</p> <p>1 fbNewEngine.Start(1, 7.5); llama al m\u00e9todo Start() en FB_NewEngine , ya que este m\u00e9todo ha sido redefinido (sobrescrito) en FB_NewEngine .</p> <p>Mientras que</p> <p>1 fbNewEngine.Stop(); llama al m\u00e9todo Stop() desde FB_Engine . El m\u00e9todo Stop() ha sido heredado por FB_NewEngine de FB_Engine .</p>"},{"location":"Clases%20y%20Objetos/interface/","title":"Interface","text":""},{"location":"Clases%20y%20Objetos/interface/#interface","title":"interface:","text":"<p>Una interfaz es una clase que contiene m\u00e9todos y propiedades sin implementaci\u00f3n.  La interfaz se puede implementar en cualquier clase, pero esa clase debe implementar todos sus m\u00e9todos. y propiedades.</p> <p>Si bien la herencia es una relaci\u00f3n \"es un\", las interfaces se pueden describir como \"se comporta como\" o \u201ctiene una\u201d relaci\u00f3n.</p> <p>Las interfaces son objetos que permiten que varias clases diferentes tengan algo en com\u00fan con menos dependencias. Las clases y los bloques de funciones pueden implementar varias interfaces diferentes. Uno puede pensar en los m\u00e9todos y propiedades de la interfaz como acciones que significan cosas diferentes dependiendo de qui\u00e9n los est\u00e9 ejecutando. Por ejemplo, la palabra \"Correr\" significa \"mover a una velocidad m\u00e1s r\u00e1pido que un paseo\u201d para un ser humano, pero significa \u201cejecutar\u201d para las computadoras.</p> <p>Las clases o bloques de funciones que no comparten similitudes pueden implementar la misma interfaz. En este caso, la implementaci\u00f3n de los m\u00e9todos en cada clase puede ser totalmente diferente. Esto abre muchos enfoques de programaci\u00f3n poderosos:</p> <ul> <li>Las POU pueden llamar a una interfaz para ejecutar un m\u00e9todo o acceder a una propiedad, sin saber cu\u00e1l clase o FB con el que se trata o c\u00f3mo va a ejecutar la operaci\u00f3n.  La interfaz luego apunta a una clase o bloque de funci\u00f3n que implementa la interfaz y la operaci\u00f3n es ejecutado;</li> <li>Los programadores pueden crear cajas de interruptores f\u00e1cilmente personalizables usando polimorfismo.</li> </ul> <p>\ud83d\udd17Codesys Comando 'Implementar interfaces'</p> <p>\ud83d\udd17Codesys Objeto Interface</p> <p>\ud83d\udd17Codesys Implementando Interfaces</p> <p>\ud83d\udd17Beckhoff Objeto Interface</p> <p>\ud83d\udd17Beckhoff Implementando Interfaces</p>"},{"location":"Clases%20y%20Objetos/metodo/","title":"Metodo","text":""},{"location":"Clases%20y%20Objetos/metodo/#metodos","title":"metodos","text":"<p>Los m\u00e9todos dividen la clase o el bloque de funciones en funciones m\u00e1s peque\u00f1as que se pueden ejecutar en llamada. Solo trabajar\u00e1n con los datos que necesitan e ignorar\u00e1n cualquier dato redundante que puede existir en un determinado bloque de funciones.</p> <p>Los m\u00e9todos pueden acceder y manipular las variables internas de la clase principal, pero tambi\u00e9n pueden usar variables propias a las que la clase principal no puede acceder (a menos que sean de salida) variable). Adem\u00e1s, los m\u00e9todos son una forma mucho m\u00e1s eficiente de ejecutar un programa porque, al dividir una funci\u00f3n en varios m\u00e9todos, el usuario evita ejecutar todo el POU cada vez, ejecutar solo peque\u00f1as porciones de c\u00f3digo siempre que sea necesario llamarlas. Esto es un muy buena manera de evitar errores y corrupci\u00f3n de datos. Los m\u00e9todos tambi\u00e9n tienen un nombre, lo que significa que estas porciones de c\u00f3digo se pueden identificar por su prop\u00f3sitos en lugar de las variables que manipulan, mejorando as\u00ed la lectura de c\u00f3digo y soluci\u00f3n de problemas.</p> <p>La abstracci\u00f3n juega un papel importante aqu\u00ed, si los programadores desean implementar el c\u00f3digo,  solo necesitan llamar al m\u00e9todo. La soluci\u00f3n de problemas tambi\u00e9n se convierte en m\u00e1s simple: entonces el programador no necesita buscar cada instancia del c\u00f3digo, solo necesitan verificar el m\u00e9todo correspondiente. A diferencia de la clase base, los m\u00e9todos usan la memoria temporal del controlador: los datos son vol\u00e1tiles, ya que las variables solo mantendr\u00e1n sus valores mientras se ejecuta el m\u00e9todo. Si se suponen valores que deben mantenerse entre ciclos de ejecuci\u00f3n, entonces la variable debe almacenarse en la clase base o en alg\u00fan otro lugar que retendr\u00e1 los valores de un ciclo al otro (como la variable global lista).</p>"},{"location":"Clases%20y%20Objetos/metodo/#especificadores-de-acceso-para-los-metodos","title":"Especificadores de acceso para los Metodos:","text":"<p>La declaraci\u00f3n del m\u00e9todo puede incluir un especificador de acceso opcional. Esto restringe el acceso al m\u00e9todo.</p> <ul> <li>P\u00daBLICO   - Cualquiera puede llamar al m\u00e9todo, no hay restricciones.</li> <li>PRIVADO   - El m\u00e9todo est\u00e1 disponible solo dentro de la POU. No se puede llamar desde fuera de la POU.</li> <li>PROTEGIDO- Solo su propia POU o las POU derivadas de ella pueden acceder al m\u00e9todo. La derivaci\u00f3n se analiza a continuaci\u00f3n.</li> <li>INTERNO- Solo se puede acceder al m\u00e9todo desde el mismo espacio de nombres. Esto permite que los m\u00e9todos est\u00e9n disponibles solo dentro de una determinada biblioteca, por ejemplo.</li> <li>FINAL -El m\u00e9todo no puede ser sobrescrito por otro m\u00e9todo. La sobrescritura de m\u00e9todos se describe a continuaci\u00f3n.</li> </ul> <p>La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC .</p> <p>Por lo tanto, una declaraci\u00f3n de M\u00e9todo tiene la siguiente estructura: <pre><code>METHOD &lt;Access specifier&gt; &lt;Name&gt; : &lt;Datatype return value&gt;\n</code></pre> No es obligatorio que un M\u00e9todo deba devolver un valor...</p> <p>\ud83d\udd17Documentaci\u00f3n Codesys del Objeto m\u00e9todo</p> <p>\ud83d\udd17Documentaci\u00f3n de Beckhoff del Objeto m\u00e9todo</p>"},{"location":"Clases%20y%20Objetos/propiedad/","title":"Propiedad","text":""},{"location":"Clases%20y%20Objetos/propiedad/#propiedades","title":"propiedades","text":"<p>Las propiedades son las principales variables de una clase. Se pueden utilizar como una alternativa a la clase regular o E/S del bloque de funciones. Las propiedades tienen m\u00e9todos Get \"Obtener\" y Set \"Establecer\" que permiten acceder y/o cambiar las variables:</p> <ul> <li>Get - M\u00e9todo que devuelve el valor de una variable;</li> <li>Set - M\u00e9todo que establece el valor de una variable.</li> </ul> <p>Al eliminar el m\u00e9todo \"Obtener\" o \"Establecer\", un programador puede hacer que las propiedades sean \"de solo escritura\" o \u201csolo lectura\u201d, respectivamente. Dado que estos son m\u00e9todos, significa que las propiedades pueden:</p> <ul> <li>Tener sus propias variables internas;</li> <li>Realizar operaciones antes de devolver su valor;</li> <li>No es necesario adjuntar la variable devuelta a una entrada o salida en particular (o variable interna) de la POU, puede devolver un valor basado en una determinada combinaci\u00f3n de sus variables;</li> <li>Ser accedido por evento en lugar de ser verificado en cada ciclo de ejecuci\u00f3n.</li> </ul> <p>.Propiedades: Getters &amp; Setters</p> <p>para modificar directamente nuestras propiedades lo que se busca es que se haga a trav\u00e9s de los metodos Getters y Setters, el cual var\u00eda la escritura seg\u00fan el lenguaje pero el concepto es el mismo.</p>"},{"location":"Clases%20y%20Objetos/propiedad/#especificadores-de-acceso","title":"Especificadores de acceso:","text":"<p>Al igual que con los m\u00e9todos, las propiedades tambi\u00e9n pueden tomar los siguientes especificadores de acceso: P\u00daBLICO , PRIVADO , PROTEGIDO , INTERNO y FINAL . Cuando no se define ning\u00fan especificador de acceso, la propiedad es PUBLIC . Adem\u00e1s, tambi\u00e9n se puede especificar un especificador de acceso para cada setter y getter. Esto tiene prioridad sobre el propio especificador de acceso de la propiedad.</p> <p>Por lo tanto, una declaraci\u00f3n de propiedad tiene la siguiente estructura:</p> <p><pre><code>PROPERTY &lt;Access specifier&gt; &lt;Name&gt; : &lt;Datatype&gt;\n</code></pre> En el Objeto Propiedad es obligatorio que retorne un valor...</p> <p>\ud83d\udd17Documentaci\u00f3n de Codesys del Objeto propiedad</p> <p>\ud83d\udd17Documentaci\u00f3n de Beckhoff del Objeto propiedad</p> <ul> <li>\ud83d\udd17 https://twincontrols.com/community/twincat-troubleshooting/utilizing-properties/#post-76</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/","title":"Patrones de Dise\u00f1o","text":"<p>PATRONES DE DISE\u00d1OS</p> <p>\u201cLos patrones de dise\u00f1o son  descripciones de objetos y clases  conectadas que se personalizan para  resolver un problema de dise\u00f1o  general en un contexto particular\u201d.  - Gang of Four </p> <p></p> <p></p> <p> </p> <p>Clasificaci\u00f3n seg\u00fan su prop\u00f3sito:  Los patrones de dise\u00f1o se clasificaron originalmente en tres grupos: </p> <ul> <li>Creacionales. </li> <li>Estructurales. </li> <li>De comportamiento. </li> </ul> <p>Clasificaci\u00f3n seg\u00fan su \u00e1mbito:</p> <ul> <li>De clase: Basados en la herencia de clases. </li> <li>De objeto: Basados en la utilizaci\u00f3n din\u00e1mica de objetos. </li> </ul> <p>Patrones creacionales:</p> <ul> <li>Builder</li> <li>Singleton </li> <li>Dependency Injection </li> <li>Service Locator </li> <li>Abstract Factory</li> <li>Factory Method </li> </ul> <p>Patrones estructurales:</p> <ul> <li>Adapter</li> <li>Data Access Object (DAO)  </li> <li>Query Object </li> <li>Decorator </li> <li>Bridge </li> </ul> <p>Patrones de comportamiento:</p> <ul> <li>Command</li> <li>Chain of Responsibility </li> <li>Strategy</li> <li>Template Method </li> <li>Interpreter</li> <li>Observer </li> <li>State </li> <li>Visitor </li> <li>Iterator </li> </ul>"},{"location":"UML/Class%20UML/","title":"Class UML","text":""},{"location":"UML/Class%20UML/#class-uml","title":"Class UML","text":""},{"location":"UML/Class%20UML/#uml","title":"UML:","text":"<ul> <li> <p>\ud83d\udd17 www.lucidchart.com/tutorial-de-diagrama-de-clases-uml</p> </li> <li> <p>\ud83d\udd17 www.edrawsoft.com/uml-class-diagram-explained</p> </li> <li> <p>\ud83d\udd17 blog.visual-paradigm.com/what-are-the-six-types-of-relationships-in-uml-class-diagrams</p> </li> <li> <p>\ud83d\udd17 Ingenier\u00eda del Software: Fundamentos de UML usando Papyrus</p> </li> <li> <p>\ud83d\udd17 plantuml.com/class-diagram</p> </li> <li> <p>\ud83d\udd17 www.planttext.com</p> </li> <li> <p>\ud83d\udd17 UML Infosys Beckhoff</p> </li> </ul>"},{"location":"UML/Statechart%20UML/","title":"StateChart UML","text":""},{"location":"UML/Statechart%20UML/#state-chart","title":"state chart:","text":""},{"location":"UML/UML/","title":"UML","text":""},{"location":"UML/UML/#uml","title":"UML","text":"<ul> <li>https://www.plccoder.com/twincat-uml-class-diagram/</li> </ul>"},{"location":"principios/_principios%20OOP/","title":"4 Pilares","text":"<p> Principios OOP: (4 pilares) </p> <ul> <li>Abstracci\u00f3n -- La forma de plasmar algo hacia el c\u00f3digo para enfocarse en su uso. No enfocarnos tanto en que hay por detras del codigo si no en el uso de este.</li> <li>Encapsulamiento -- No toda la informaci\u00f3n de nuestro objeto es relevante y/o accesible para el usuario.</li> <li>Herencia -- Es la cualidad de heredar caracteristicas de otra clase. (EXTENDS)</li> <li>Polimorfismo -- Las m\u00faltiples formas que puede obtener un objeto si comparte la misma clase o interfaz. (IMPLEMENTS) </li> </ul> <p></p>"},{"location":"principios/abstraccion/","title":"Abstracci\u00f3n","text":""},{"location":"principios/abstraccion/#abstraccion","title":"abstraccion","text":"<p>Abstraction is the process of hiding important information, showing only the most essential  information. It reduces code complexity and isolates the impact of changes. Abstraction can be understood from a real-life example: turning on a television must only  require clicking on a button, as people don\u2019t need to know or the process that it goes through. Even though that process can be complex and important, there is no need for the user to know  how it is implemented. The important information that isn\u2019t required is hidden from the user,  reducing code complexity, enhancing data hiding and reusability, thus making function  blocks easier to implement and modify.</p> <ul> <li>https://www.plccoder.com/abstract/</li> </ul>"},{"location":"principios/encapsulamiento/","title":"Encapsulamiento","text":""},{"location":"principios/encapsulamiento/#encapsulamiento","title":"encapsulamiento","text":"<p>La encapsulaci\u00f3n se utiliza para agrupar datos con los m\u00e9todos que operan en ellos y para ocultar datos en su interior. una clase, evitando que personas no autorizadas accedan directamente a ella. Reduce la complejidad del c\u00f3digo y aumenta la reutilizaci\u00f3n. La separaci\u00f3n del c\u00f3digo permite la creaci\u00f3n de rutinas que pueden ser reutilizadas en lugar de copiar y pegar c\u00f3digo, reduciendo la complejidad del programa principal.</p> <ul> <li>https://www.plccoder.com/encapsulation/</li> </ul>"},{"location":"principios/herencia/","title":"Herencia","text":""},{"location":"principios/herencia/#herencia","title":"herencia","text":"<p>Inheritance allows the user to create classes based on other classes. The inherited classes can  use the base class\u2019s functionalities as well as some additional functionalities that the user may  define. It eliminates redundant code, prevents copying and pasting and makes expansion easier.  This is very useful because it allows classes to be extended of modified (overridden) without  changing the base class\u2019s code implementation. What do an old landline phone and a smartphone have in common? Both of them can be  classified as phones. Should they be classified as objects? No, as they also define the properties  and behaviors of a group of objects. A smartphone works just like a regular phone, but it is also  able to take pictures, navigate the internet, and do many other things. So, old landline phone and smartphone are child classes that extend the parent phone class.</p>"},{"location":"principios/polimorfismo/","title":"Polimorfismo","text":""},{"location":"principios/polimorfismo/#polimorfismo","title":"polimorfismo","text":"<p>The concept of polymorphism is derived by the combination of two words: Poly (Many) and  Morphism (Form). It refactors ugly and complex switch cases/case statements. Object-Oriented PLC Programming 8 Polymorphism allows an object to change its appearance and performance depending on the  practical situation in order to be able to carry out a particular task [10]. It can be either static or  dynamic: static polymorphism occurs when the object\u2019s type is defined by the compiler;  dynamic polymorphism occurs when the type is determined during run-time, making it possible  for a same variable to access different objects while the program is running. A good example to explain polymorphism is a Swiss Army Knife (Figure 2.4): Figure 2.4 - Swiss Army Knife A Swiss Army Knife is a single tool that includes a bunch of resources that can be used to solve different issues. Selecting the proper tool, a Swiss Army Knife can be used to efficiently perform a certain set of valuable tasks. In the dual way, a simple adder block that adapts itself  to cope with, for instance, int, float, string, and time data types is an example of a polymorphic  programming resource.</p> <ul> <li> <p>https://www.plccoder.com/polymorphism/</p> </li> <li> <p>https://www.plccoder.com/abstract/</p> </li> </ul> <p>\u00bfComo conseguir el Polimorfismo?</p> <p>El polimorfismo se puede obtener gracias a las Interfaces y/o las Clases Abstractas.</p> <p>.Interface: (INTERFACE) - Son un contrato que obliga a una clase a implementar las propiedades y/o m\u00e9todos definidos. - Son una plantilla (sin l\u00f3gica).</p> <p>.Clases Abstractas: (ABSTRACT) - Son Clases que no se pueden instanciar, solo pueden ser implementadas a trav\u00e9s de la herencia.</p> <ul> <li> <p>Diferencias:</p> Clases abstractas Interfaces 1.- Limitadas a una sola implementaci\u00f3n. 1. No tiene limitaci\u00f3n de implementaci\u00f3n. 2.- Pueden definir comportamiento base. 2. Expone propiedades y m\u00e9todos abstractos (sin l\u00f3gica). </li> </ul>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/","title":"Principio de Abierto/Cerrado","text":""},{"location":"solid/Principio%20de%20Abierto_Cerrado/#principio-de-abiertocerrado","title":"Principio de Abierto/Cerrado","text":""},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/","title":"Principio de Inversi\u00f3n de Dependencia","text":""},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/#principio-de-inversion-de-dependencia","title":"Principio de Inversi\u00f3n de Dependencia","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/","title":"Principio de Responsabilidad \u00danica","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/#principio-de-responsabilidad-unica","title":"Principio de Responsabilidad \u00danica","text":""},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/","title":"Principio de Segregaci\u00f3n de Interfaz","text":""},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/#principio-de-segregacion-de-interfaz","title":"Principio de Segregaci\u00f3n de Interfaz","text":""},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/","title":"Principio de Sustituci\u00f3n de Liskov","text":""},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/#principio-de-sustitucion-de-liskov","title":"Principio de sustituci\u00f3n de Liskov","text":""},{"location":"solid/_SOLID/","title":"SOLID","text":"<p> - Propuesta por Robert C.Martin en el 2000. - Son recomendaciones para escribir un c\u00f3digo sostenible,mantenible,escalable y robusto. - Beneficios:     - Alta Cohesi\u00f3n. Colaboracion entre clases.     - Bajo Acoplamiento. Evitar que una clase dependa fuertemente de otra clase.</p> <ul> <li>Principio de Responsabilidad \u00danica: Una clase debe tener una raz\u00f3n para existir mas no para cambiar.</li> <li>Principio de Abierto/Cerrado: Las piezas del software deben estar abiertas para la extensi\u00f3n pero cerradas para la modificaci\u00f3n.</li> <li>Principio de Sustituci\u00f3n de Liskov: Las clases subtipos deber\u00edan ser reemplazables por sus clases padres.</li> <li>Principio de Segregaci\u00f3n de Interfaz: Varias interfaces funcionan mejor que una sola.</li> <li>Principio de Inversi\u00f3n de Dependencia: Clases de alto nivel no deben depender de las clases bajo nivel.</li> </ul>"}]}