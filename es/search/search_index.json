{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduccion","text":"<p> \ud83d\udcd6 Curso Programaci\u00f3n Orientada a Objetos Youtube -- OOP : </p> <p>  by Runtimevic -- V\u00edctor Dur\u00e1n Mu\u00f1oz. </p>"},{"location":"#que-es-oop","title":"\u00bf Qu\u00e9 es OOP?","text":"<ul> <li> <p>Es un paradigma que hace uso de los objetos para la construcci\u00f3n de los software.</p> <p>. \u00bf Qu\u00e9 es un paradigma?</p> <ul> <li>Tiene diferentes interpretaciones, puede ser un modelo, ejemplo o patr\u00f3n.</li> <li>Es una forma o un estilo de programar.</li> <li>se busca plasmar la realidad hacia el c\u00f3digo.</li> </ul> </li> </ul>"},{"location":"#como-pensar-en-objetos","title":"\u00bfC\u00f3mo pensar en Objetos?","text":"<ul> <li>Enfocarse en algo de la realidad.</li> <li>Detalla sus atributos, (propiedades)</li> <li>Detalla sus comportamientos (metodos)</li> </ul> <pre><code>\ud83d\udcf1 Ejemplo: (Telefono m\u00f3vil-smartphone)\n\n. \u00bfQu\u00e9 atributos (Propiedades) reconocemos? \n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - Realizar llamadas.\n    - Navegar por internet. \n</code></pre> <pre><code>\ud83d\ude97 Ejemplo: (Coche)\n\n. \u00bfQu\u00e9 atributos (Propiedades) reconocemos? \n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - conducir.\n    - frenar. \n    - acelerar.\n</code></pre>"},{"location":"#links","title":"Links:","text":"<p>\ud83d\udd17 Codesys admite OOP</p> <p>\ud83d\udd17 Beckhoff TwinCAT 3 admite OOP</p>"},{"location":"Interfaz%20fluida/","title":"Interfaz fluida","text":""},{"location":"Interfaz%20fluida/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 fluent-code, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 fluent-interface-and-method-chaining-in-twincat-3</p> </li> </ul>"},{"location":"OOP_Curso_Youtube_Runtimevic/","title":"OOP Curso Youtube Runtimevic","text":"<p> \ud83d\udcd6 Curso Programaci\u00f3n Orientada a Objetos Youtube -- OOP : </p> <p>  by Runtimevic -- V\u00edctor Dur\u00e1n Mu\u00f1oz. </p> <p> . \u00bf Qu\u00e9 es OOP?   . \u00bf Qu\u00e9 es OOP?   - Es un paradigma que hace uso de los objetos para la construcci\u00f3n de los software.       . \u00bf Qu\u00e9 es un paradigma?     - Tiene diferentes interpretaciones, puede ser un **modelo**, **ejemplo** o **patr\u00f3n.**     - Es una **forma** o un **estilo** de programar. - se busca plasmar la realidad hacia el c\u00f3digo.   . \u00bfC\u00f3mo pensar en Objetos?   - Enfocarse en **algo de la realidad.** - Detalla sus **atributos, (propiedades)** - Detalla sus **comportamientos (metodos)**  <pre><code>Ejemplo: (telefono m\u00f3vil-smartphone)\n. \u00bfQu\u00e9 atributos reconocemos? (Propiedades)\n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - Realizar llamadas.\n    - Navegar por internet. \n</code></pre> ***  . Tipos de paradigmas:   - Imperativa -- (**Instrucciones a seguir** para dar soluci\u00f3n a un problema). - Declarativa -- (Se **enfoca en el problema** a solucionar). - Estructurada -- (La soluci\u00f3n a un problema sigue **una secuencia de inico a fin**). -  Orientada a objetos (Construye soluciones **basadas en objetos**).  - Funcional -- (Divide el problema en diversas soluciones que ser\u00e1n ejecutadas por las **funciones declaradas**). ***  . Clases y Objetos:   - Una Clase es una **plantilla**. - Un Objeto es la **instancia de una Clase**.  <p>   ***  . Principios OOP: (4 pilares)  - Abstracci\u00f3n -- La forma de **plasmar algo hacia el c\u00f3digo** para enfocarse en su uso. No enfocarnos tanto en que hay por detras del codigo si no en el uso de este. - Encapsulamiento -- No toda la informaci\u00f3n de nuestro objeto es **relevante y/o accesible** para el usuario. - Herencia -- Es la cualidad de **heredar caracteristicas** de otra clase. (EXTENDS) - Polimorfismo -- Las **m\u00faltiples formas** que puede obtener un objeto si comparte la misma **clase o interfaz**. (IMPLEMENTS)   <p> </p>  *** \u00bfComo conseguir el Polimorfismo?  .Interface: (INTERFACE) - Son un **contrato que obliga** a una clase a **implementar** las **propiedades** y/o **m\u00e9todos** definidos. - Son una plantilla (sin l\u00f3gica).  .Clases Abstractas: (ABSTRACT) - Son Clases que no se pueden instanciar, solo pueden ser implementadas a trav\u00e9s de la herencia.  - Diferencias:      | Clases abstractas | Interfaces |      | :--- | :--- |          | 1.- Limitadas a una sola implementaci\u00f3n.   | 1. No tiene limitaci\u00f3n de implementaci\u00f3n.     |      | 2.- Pueden definir comportamiento base.     | 2. Expone prpiedades y m\u00e9todos abstractos (sin l\u00f3gica).     |   *** .modificadores de acceso:  - public: son accesibles luego de instanciar la clase. - private: son accesibles dentro de la clase. - protected: son accesibles a trav\u00e9s de la herencia. - internal: *** .Propiedades: Getters &amp; Setters  para modificar directamente nuestras propiedades lo que se busca es que se haga a trav\u00e9s de los metodos Getters y Setters, el cual var\u00eda la escritura seg\u00fan el lenguaje pero el concepto es el mismo. *** .Relaciones:  Vamos a ver 2 tipos de relaciones:  - Asociaci\u00f3n.     - De uno a uno: Una clase mantiene una **asociaci\u00f3n de a uno** con otra clase.     - De uno a muchos: Una clase mantiene una asociaci\u00f3n con otra clase **a trav\u00e9s de una colecci\u00f3n**.     - De muchos a muchos: La **asociaci\u00f3n se da en ambos lados** a trav\u00e9s de una colecci\u00f3n. - Colaboraci\u00f3n.     - La colaboraci\u00f3n se da **a trav\u00e9s de una referencia de una clase** con el fin de **lograr un cometido**.    ***  . SOLID: (5 principios)   ![SOLID](./imagenes/SOLID.png) - Propuesta por **Robert C.Martin** en el 2000. - Son **recomendaciones** para escribir un c\u00f3digo **sostenible,mantenible,escalable y robusto**. - Beneficios:       - Alta **Cohesi\u00f3n**. Colaboracion entre clases.     - Bajo **Acoplamiento**. Evitar que una clase dependa fuertemente de otra clase.   - Principio de Responsabilidad \u00danica: Una clase debe tener **una raz\u00f3n** para existir mas no para cambiar. - Principio de Abierto/Cerrado: Las piezas del software deben estar **abiertas para la extensi\u00f3n** pero **cerradas para la modificaci\u00f3n**. - Principio de Sustituci\u00f3n de Liskov: Las **clases subtipos** deber\u00edan ser reemplazables por sus **clases padres**. - Principio de Segregaci\u00f3n de Interfaz: Varias **interfaces** funcionan **mejor que una sola**. - Principio de Inversi\u00f3n de Dependencia: Clases de **alto nivel** no deben depender de las clases **bajo nivel**. ***  ![OOP_Logo](./imagenes/OO_Logo.jpg)         \ud83d\udc69\u200d\ud83c\udfeb \ud83d\udc68\u200d\ud83c\udfeb   ![Placeholder](https://dummyimage.com/600x400/eee/aaa){: align=left }"},{"location":"Tabla%20de%20Modificadores%20de%20acceso/","title":"Tabla de Modificadores de acceso","text":"Modificadores de acceso FUNCTION_BLOCK - FB METODO PROPIEDAD PUBLIC Si Si Si INTERNAL Si Si Si FINAL Si Si Si ABSTRACT Si Si Si PRIVATE No Si Si PROTECTED No Si Si"},{"location":"Tipos%20de%20Dise%C3%B1o%20para%20programacion%20de%20PLC/","title":"Tipos de Dise\u00f1o para programacion de PLC","text":""},{"location":"Tipos%20de%20Dise%C3%B1o%20para%20programacion%20de%20PLC/#tipos-de-diseno-para-programacion-de-plc","title":"Tipos de Dise\u00f1o para programacion de PLC:","text":"<p>Ingenieria de desarrollo para la programaci\u00f3n OOP - Dise\u00f1o por Componente, Unidad, Dispositivo, Objeto...     - Los objetos son las unidades b\u00e1sicas de la programaci\u00f3n orientada a objetos.     - Un componente proporciona servicios, mientras que un objeto proporciona operaciones y m\u00e9todos. Un componente puede ser entendido por todos, mientras que un objeto solo puede ser entendido por los desarrolladores.     - Las unidades son los grupos de c\u00f3digo m\u00e1s peque\u00f1os que se pueden mantener y ejecutar de forma independiente - Dise\u00f1o por Pruebas Unitarias. - Dise\u00f1o en UML.</p> <p>Units: (Ejemplo de Unidades): -FCAnalogSensor -FBGenericUnit</p> <p>!!! puntos que se pueden incluir en el curso!!! - Basic of Structured Text programming Language - Modular Design - Classes - Methods - Properties - Inheritance - Polymorphism - Access Specifiers - Pointers and References - Interfaces and Abstractions - Advanced State Pattern - Wrappers and Features - Layered Design - Final Project covering a real-world problem to be solved using OOP</p>"},{"location":"Tipos%20de%20datos/","title":"Tipos de Datos","text":""},{"location":"Tipos%20de%20datos/#declaracion-de-una-variable","title":"Declaracion de una Variable:","text":"<p>La declaraci\u00f3n de variables en CODESYS \u00f3 TwinCAT incluir\u00e1: - Un nombre de variable - Dos puntos - Un tipo de dato - Un valor inicial opcional - Un punto y coma - Un comentario opcional</p>"},{"location":"Tipos%20de%20datos/#tipos-de-datos","title":"\ud83d\udd17 Tipos de Datos:","text":""},{"location":"Tipos%20de%20datos/#las-ventajas-de-las-estructuras-de-datos","title":"Las ventajas de las estructuras de datos.","text":"<ul> <li>La principal aportaci\u00f3n de las estructuras de datos y los tipos de datos  creados por el usuario es la claridad y el orden del c\u00f3digo resultante.</li> </ul> <ul> <li> <p>Estructuras de datos: (STRUCT)</p> </li> <li> <p>\ud83d\udd17 Extender una Estructura, Infosys Beckhoff</p> </li> <li> <p>Datos de usuario:UDT (User Data Type) Los UDT (User Data Type) son tipos de datos que el usuario crea a su medida,  seg\u00fan las necesidades de cada proyecto.</p> </li> </ul> <p>When programming in TwinCAT, you can use different data types or instances of function blocks. You assign a data type to each identifier. The data type determines how much memory space is allocated and how these values are interpreted.</p> <p>The following groups of data types are available:</p>"},{"location":"Tipos%20de%20datos/#standard-data-types","title":"Standard data types","text":"<p>TwinCAT supports all data types described in the IEC 61131-3 standard.</p> <ul> <li>BOOL</li> <li>Integer Data Types</li> <li>REAL / LREAL</li> <li>STRING</li> <li>WSTRING</li> <li>Time, date and time data types</li> <li>LTIME</li> </ul>"},{"location":"Tipos%20de%20datos/#extensions-of-the-iec-61131-3-standard","title":"Extensions of the IEC 61131-3 standard","text":"<ul> <li>BIT</li> <li>ANY and ANY_ <li>Special data types XINT, UXINT, XWORD and PVOID</li> <li>REFERENCE</li> <li>UNION</li> <li>POINTER</li> <li>Data type __SYSTEM.ExceptionCode</li>"},{"location":"Tipos%20de%20datos/#user-defined-data-types","title":"User-defined data types","text":"<p>Note the recommendations for naming objects.</p> <ul> <li>POINTER</li> <li>REFERENCE</li> <li>ARRAY</li> <li> <p>Subrange Types User-defined data types that you create as DUT object in the TwinCAT PLC project tree:</p> </li> <li> <p>Structure</p> </li> <li>Enumerations</li> <li>Alias</li> <li>UNION</li> </ul>"},{"location":"Tipos%20de%20datos/#further-information","title":"Further Information","text":"<ul> <li>BOOL</li> <li>Integer Data Types</li> <li>Subrange Types</li> <li>BIT</li> <li>REAL / LREAL</li> <li>STRING</li> <li>WSTRING</li> <li>Time, date and time data types</li> <li>ANY and ANY_ <li>Special data types XINT, UXINT, XWORD and PVOID</li> <li>POINTER</li> <li>Data type __SYSTEM.ExceptionCode</li> <li>Interface pointer / INTERFACE</li> <li>REFERENCE https://infosys.beckhoff.com/english.php?content=../content/1033/tc3_plc_intro/2529458827.html&amp;id=</li> <li>ARRAY</li> <li>Structure</li> <li>Enumerations</li> <li>Alias</li> <li>UNION</li>"},{"location":"Tipos%20de%20datos/#links-tipos-de-datos","title":"Links Tipos de Datos:","text":"<ul> <li> <p>\ud83d\udd17 12. TwinCAT 3: Standard data types</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Tipos de datos</p> </li> </ul>"},{"location":"Variable%20types%20and%20special%20variables/","title":"Tipos de variables y variables especiales","text":""},{"location":"Variable%20types%20and%20special%20variables/#variable-types-and-special-variables","title":"Variable types and special variables:","text":"<p>The variable type defines how and where you can use the variable. The variable type is defined during the variable declaration.</p>"},{"location":"Variable%20types%20and%20special%20variables/#further-information","title":"Further Information:","text":"<ul> <li>Local Variables - VAR<ul> <li>Las variables locales se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR y END_VAR.</li> <li>Puede extender las variables locales con una palabra clave de atributo.</li> <li>Puede acceder a variables locales para leer desde fuera de los objetos de programaci\u00f3n a trav\u00e9s de la ruta de instancia. El acceso para escribir desde fuera del objeto de programaci\u00f3n no es posible; Esto ser\u00e1 mostrado por el compilador como un error.</li> <li>Para mantener la encapsulaci\u00f3n de datos prevista, se recomienda encarecidamente no acceder a las variables locales de un POU desde fuera del POU, ni en modo de lectura ni en modo de escritura. (Otros compiladores de lenguaje de alto nivel tambi\u00e9n generan operaciones de acceso de lectura a variables locales como errores). Adem\u00e1s, con los bloques de funciones de biblioteca no se puede garantizar que las variables locales de un bloque de funciones permanezcan sin cambios durante las actualizaciones posteriores. Esto significa que es posible que el proyecto de aplicaci\u00f3n ya no se pueda compilar correctamente despu\u00e9s de la actualizaci\u00f3n de la biblioteca.</li> <li>Tambi\u00e9n observe aqu\u00ed la regla SA0102 del An\u00e1lisis Est\u00e1tico, que determina el acceso a las variables locales para la lectura desde el exterior.</li> </ul> </li> <li>Input Variables - VAR_INPUT<ul> <li>Las variables de entrada son variables de entrada para un bloque de funciones.</li> <li>VAR_INPUT variables se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR_INPUT y END_VAR.</li> <li>Puede ampliar las variables de entrada con una palabra clave de atributo.</li> </ul> </li> <li>Output Variables - VAR_OUTPUT<ul> <li>Las variables de salida son variables de salida de un bloque de funciones.</li> <li>VAR_OUTPUT variables se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR_OUTPUT y END_VAR. TwinCAT devuelve los valores de estas variables al bloque de funci\u00f3n de llamada. All\u00ed puede consultar los valores y continuar us\u00e1ndolos.</li> <li>Puede ampliar las variables de salida con una palabra clave de atributo.    </li> </ul> </li> <li>Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</li> <li>Global Variables - VAR_GLOBAL<ul> <li>Solo es posible su declaraci\u00f3n en GVL (Lista de Variables Global)</li> </ul> </li> <li>Temporary Variable - VAR_TEMP<ul> <li>Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.</li> <li>Las variables temporales se declaran localmente entre las palabras clave VAR_TEMP y END_VAR.</li> <li>VAR_TEMP declaraciones s\u00f3lo son posibles en programas y bloques de funciones.</li> <li>TwinCAT reinicializa las variables temporales cada vez que se llama al bloque de funciones.</li> <li>La aplicaci\u00f3n s\u00f3lo puede acceder a variables temporales en la parte de implementaci\u00f3n de un programa o bloque de funciones.</li> </ul> </li> <li>Static Variables - VAR_STAT<ul> <li>Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.</li> <li>Las variables est\u00e1ticas se declaran localmente entre las palabras clave VAR_STAT y END_VAR. TwinCAT inicializa las variables est\u00e1ticas cuando se llama por primera vez al bloque de funciones respectivo.</li> <li>Puede tener acceso a las variables est\u00e1ticas s\u00f3lo dentro del espacio de nombres donde se declaran las variables (como es el caso de las variables est\u00e1ticas en C). Sin embargo, las variables est\u00e1ticas conservan su valor cuando la aplicaci\u00f3n sale del bloque de funciones. Puede utilizar variables est\u00e1ticas, como contadores para llamadas a funciones, por ejemplo.</li> <li>Puede extender variables est\u00e1ticas con una palabra clave de atributo.</li> <li>Las variables est\u00e1ticas solo existen una vez. Esto tambi\u00e9n se aplica a las variables est\u00e1ticas de un bloque de funciones o un m\u00e9todo de bloque de funciones, incluso si el bloque de funciones se instancia varias veces.</li> </ul> </li> <li>External Variables - VAR_EXTERNAL<ul> <li>Las variables externas son variables globales que se \"importan\" en un bloque de funciones.</li> <li>Puede declarar las variables entre las palabras clave VAR_EXTERNAL y END_VAR. Si la variable global no existe, se emite un mensaje de error.  </li> <li>En TwinCAT 3 PLC no es necesario que las variables se declaren como externas. La palabra clave existe para mantener la compatibilidad con IEC 61131-3.</li> <li>Si, no obstante, utiliza variables externas, aseg\u00farese de abordar las variables asignadas (con AT %I o AT %Q) s\u00f3lo en la lista global de variables. El direccionamiento adicional de las instancias de variables locales dar\u00eda lugar a duplicaciones en la imagen del proceso.</li> <li>Estas variables declaradas tambien tiene que estar declarada la misma variable con el mismo nombre en una GVL (Lista de Varaibles Global)</li> </ul> </li> <li>Instance Variables - VAR_INST<ul> <li>TwinCAT crea una variable VAR_INST de un m\u00e9todo no en la pila de m\u00e9todos como las variables VAR, sino en la pila de la instancia del bloque de funciones. Esto significa que la variable VAR_INST se comporta como otras variables de la instancia del bloque de funci\u00f3n y no se reinicializa cada vez que se llama al m\u00e9todo.</li> <li>VAR_INST variables solo est\u00e1n permitidas en los m\u00e9todos de un bloque de funciones, y el acceso a dicha variable solo est\u00e1 disponible dentro del m\u00e9todo. Puede supervisar los valores de las variables de instancia en la parte de declaraci\u00f3n del m\u00e9todo.</li> <li>Las variables de instancia no se pueden extender con una palabra clave de atributo.</li> </ul> </li> <li>Remanent Variables - PERSISTENT, RETAIN Las variables remanentes pueden conservar sus valores m\u00e1s all\u00e1 del tiempo de ejecuci\u00f3n habitual del programa. Las variables remanentes se pueden declarar como variables RETAIN o incluso m\u00e1s estrictamente como variables PERSISTENTES en el proyecto PLC.</li> </ul> <p>Un requisito previo para la funcionalidad completa de las variables RETAIN es un \u00e1rea de memoria correspondiente en el controlador (NovRam). Las variables persistentes se escriben solo cuando TwinCAT se apaga. Esto requerir\u00e1 generalmente un UPS correspondiente. Excepci\u00f3n: Las variables persistentes tambi\u00e9n se pueden escribir con el bloque de funci\u00f3n FB_WritePersistentData.</p> <p>Si el \u00e1rea de memoria correspondiente no existe, los valores de las variables RETAIN y PERSISTENT se pierden durante un corte de energ\u00eda.</p> <p>La declaraci\u00f3n AT no debe utilizarse en combinaci\u00f3n con VAR RETAIN o VAR PERSISTENT.</p>"},{"location":"Variable%20types%20and%20special%20variables/#variables-persistentes","title":"Variables persistentes","text":"<p>Puede declarar variables persistentes agregando la palabra clave PERSISTENT despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables PERSISTENTES conservan su valor despu\u00e9s de una terminaci\u00f3n no controlada, un Reset cold o una nueva descarga del proyecto PLC. Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. En otras palabras, TwinCAT solo reinicializa las variables PERSISTENTES durante un origen de Restablecer.</p> <p>Un ejemplo de aplicaci\u00f3n para variables persistentes es un contador de horas de funcionamiento, que debe continuar contando despu\u00e9s de un corte de energ\u00eda y cuando el proyecto PLC se descarga nuevamente.</p> <p>Evite usar el tipo de datos POINTER TO en listas de variables persistentes, ya que los valores de direcci\u00f3n pueden cambiar cuando el proyecto PLC se descargue nuevamente. TwinCAT emite las advertencias correspondientes del compilador. Declarar una variable local como PERSISTENTE en una funci\u00f3n no tiene ning\u00fan efecto. La persistencia de datos no se puede utilizar de esta manera. El comportamiento durante un restablecimiento en fr\u00edo puede verse influenciado por el pragma 'TcInitOnReset'</p>"},{"location":"Variable%20types%20and%20special%20variables/#variables-retain","title":"Variables RETAIN","text":"<p>Puede declarar variables RETAIN agregando la palabra clave RETAIN despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables declaradas como RETAIN dependen del sistema de destino, pero normalmente se administran en un \u00e1rea de memoria separada que debe protegerse contra fallas de energ\u00eda. El llamado controlador Retain asegura que las variables RETAIN se escriban al final de un ciclo PLC y solo en el \u00e1rea correspondiente de la NovRam. El manejo del controlador de retenci\u00f3n se describe en el cap\u00edtulo \"Conservar datos\" de la documentaci\u00f3n de C/C++.</p> <p>Las variables RETAIN conservan su valor despu\u00e9s de una terminaci\u00f3n incontrolada (corte de energ\u00eda). Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. TwinCAT reinicializa las variables RETAIN en un origen de restablecimiento.</p> <p>Una posible aplicaci\u00f3n es un contador de piezas en una planta de producci\u00f3n, que debe seguir contando despu\u00e9s de un corte de energ\u00eda.</p> <p>Si declara una variable local como RETAIN en un programa o bloque de funciones, TwinCAT almacena esta variable espec\u00edfica en el \u00e1rea de retenci\u00f3n (como una variable RETEAIN global). Si declara una variable local en una funci\u00f3n como RETAIN, esto no tiene efecto. TwinCAT no almacena la variable en el \u00e1rea de retenci\u00f3n.</p>"},{"location":"Variable%20types%20and%20special%20variables/#cuadro-general-completo","title":"Cuadro general completo","text":"<p>El grado de retenci\u00f3n de las variables RETAIN se incluye autom\u00e1ticamente en el de las variables PERSISTENT.</p> Despu\u00e9s del comando en l\u00ednea VAR VAR RETAIN VAR PERSISTENT Restablecer fr\u00edo Los valores se reinicializan Los valores se mantienen Los valores se mantienen Restablecer origen Los valores se reinicializan Los valores se reinicializan Los valores se reinicializan Descargar Los valores se reinicializan Los valores se mantienen Los valores se mantienen Cambio en l\u00ednea Los valores se mantienen Los valores se mantienen Los valores se mantienen <ul> <li>SUPER</li> <li>THIS</li> <li>Variable types - attribute keywords<ul> <li>RETAIN: for remanent variables of type RETAIN</li> <li>PERSISTENT: for remanent variables of type PERSISTENT</li> <li>CONSTANT: for constants</li> </ul> </li> </ul>"},{"location":"Variable%20types%20and%20special%20variables/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 Local Variables - VAR, infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 Instance Variables - VAR_INST, infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/instance-variables-with-var_inst</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/var_temp-var_stat-and-var_const</p> </li> <li> <p>\ud83d\udd17 Tipos de variables y variables especiales</p> </li> </ul>"},{"location":"inicio/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"inicio/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"inicio/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"inicio/#welcome-to-my-docs","title":"Welcome to My Docs","text":"<p>This is the front page of My Docs.</p>"},{"location":"inicio/#sub","title":"Sub","text":"<p>This is another section.</p>"},{"location":"links/","title":"Document title","text":"<p>...</p>"},{"location":"links/#links","title":"Links","text":""},{"location":"links/#mencion-a-la-fuentes-links-empleadas-para-la-realizacion-de-esta-documentacion","title":"Menci\u00f3n a la Fuentes Links empleadas para la realizaci\u00f3n de esta Documentaci\u00f3n:","text":""},{"location":"page3/","title":"Page3","text":""},{"location":"page3/#esta-es-la-pagina-3","title":"esta es la pagina 3","text":""},{"location":"page3/#contact","title":"contact","text":"<p>este es mi contacto: Victor</p> <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa....</p> <pre><code>diagrama de clase\nnota \"De pato a cebra\"\nAnimal &lt;|-- Duck\nnote for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\"\nAnimal &lt;|-- Fish\nAnimal &lt;|-- Zebra\nAnimal : +int age\nAnimal : +String gender\nAnimal: +isMammal()\nAnimal: +mate()\nclass Duck{\n    +String beakColor\n    +swim()\n    +quack()\n}\nclass Fish{\n    -int sizeInFeet\n    -canEat()\n}\nclass Zebra{\n    +bool is_wild\n    +run()\n}</code></pre> <pre><code>graph TD\nA[Client] --&gt; B[Load Balancer]\nB --&gt; C[Server01]\nB --&gt; D[Server02]</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre> <pre><code>classDiagram\n  Person &lt;|-- Student\n  Person &lt;|-- Professor\n  Person : +String name\n  Person : +String phoneNumber\n  Person : +String emailAddress\n  Person: +purchaseParkingPass()\n  Address \"1\" &lt;-- \"0..1\" Person:lives at\n  class Student{\n    +int studentNumber\n    +int averageMark\n    +isEligibleToEnrol()\n    +getSeminarsTaken()\n  }\n  class Professor{\n    +int salary\n  }\n  class Address{\n    +String street\n    +String city\n    +String state\n    +int postalCode\n    +String country\n    -validate()\n    +outputAsLabel()  \n  }</code></pre>"},{"location":"page4/","title":"Page4","text":""},{"location":"page4/#esta-es-la-pagina-400","title":"esta es la pagina 4.0.0","text":"<p><code>Bold Code</code></p>"},{"location":"page4/#my-first-article","title":"My first article","text":"<p>This is my first article with some code:</p> <pre><code>class Test\n{\nstatic void Main()\n{\nConsole.WriteLine(\"Hello World\");\n}\n}\n</code></pre>"},{"location":"page4/#esta-es-la-pagina-1","title":"esta es la pagina 1","text":"Image caption <pre><code>  graph TD;\n      A--&gt;B;\n      A--&gt;C;\n      B--&gt;D;\n      C--&gt;D;</code></pre>"},{"location":"relaciones/","title":"Relaciones","text":"<p>.Relaciones:</p> <p>Vamos a ver 2 tipos de relaciones:</p> <ul> <li>Asociaci\u00f3n.<ul> <li>De uno a uno: Una clase mantiene una asociaci\u00f3n de a uno con otra clase.</li> <li>De uno a muchos: Una clase mantiene una asociaci\u00f3n con otra clase a trav\u00e9s de una colecci\u00f3n.</li> <li>De muchos a muchos: La asociaci\u00f3n se da en ambos lados a trav\u00e9s de una colecci\u00f3n.</li> </ul> </li> <li>Colaboraci\u00f3n.<ul> <li>La colaboraci\u00f3n se da a trav\u00e9s de una referencia de una clase con el fin de lograr un cometido. </li> </ul> </li> </ul>"},{"location":"requisitos/","title":"Requisitos","text":"<p> \ud83d\udc68\u200d\ud83c\udf93 Requisitos \ud83d\udc69\u200d\ud83c\udf93 : </p> <p></p> <p>Los requisitos necesarios para seguir este curso ser\u00edan tener instalados los siguientes softwares:</p> <ul> <li>\ud83d\udd17 Beckhoff TwinCAT 3 XAE \u00f3 el IDE de \ud83d\udd17 Codesys.</li> <li>Tener cuenta de usuario creada en \ud83d\udd17 GitHub.</li> <li> <p>saber lo m\u00ednimo de Git o apoyarse en herramientas visuales como pueden ser:</p> <ul> <li>\ud83d\udd17 GitHub Desktop.</li> <li>\ud83d\udd17 sourcetree</li> <li>\ud83d\udd17 tortoiseGit, etc...</li> <li>Ser\u00eda bueno tener algo de conocimientos previos de teoria de OOP, aunque sean en otros lenguajes de programaci\u00f3n ya que seran extrapolables para el enfoque de este curso de OOP IEC61131-3 para PLCs.</li> </ul> </li> </ul>"},{"location":"requisitos/#pasos-para-empezar","title":"Pasos para empezar:","text":"<ul> <li> <p>Clonar el repositorio de \ud83d\udd17GitHub:</p> <p>$ git clone https://github.com/runtimevic/OOP-IEC61131-3--Curso-Youtube.git</p> <p>\u00f3 utilizar por ejemplo GitHub Desktop para Clonar el repositorio de GitHub...</p> </li> <li> <p>Nos encontraremos las siguientes carpetas:</p> <ul> <li>\ud83d\udd17 TC3_OOP: Dentro de esta carpeta se encuentra el proyecto de TwinCAT3, con todo lo que se va explicando en los videos de youtube...</li> <li>\ud83d\udd17 Ficheros_PLCOpen_XML: Dentro de esta carpeta nos iremos encontrando los ficheros exportados en formato PLCOpen XML para que puedan ser importados en TwinCAT3 \u00f3 en Codesys de todo lo explicado en Youtube, ya que al ser el formato standarizado de PLCOpen se puede exportar/importar en todas las marcas de PLCs que sigan el estandard PLCOpen..., pero es recomendable intentar realizar lo explicado desde cero para ir practicando y asumir los conceptos explicados...</li> <li>tambien esta alojada la creaci\u00f3n de esta pagina web SSG, (Generador de Sitios Est\u00e1ticos) la cual se ira modificando conforme avancemos en este Curso de OOP IEC-61131-3 PLC...</li> </ul> </li> </ul>"},{"location":"tipos%20de%20paradigmas/","title":"Tipos de paradigmas","text":""},{"location":"tipos%20de%20paradigmas/#tipos-de-paradigmas","title":"Tipos de paradigmas:","text":"<ul> <li>Imperativa -- (Instrucciones a seguir para dar soluci\u00f3n a un problema).</li> <li>Declarativa -- (Se enfoca en el problema a solucionar).</li> <li>Estructurada -- (La soluci\u00f3n a un problema sigue una secuencia de inico a fin).</li> <li> <p>Funcional -- (Divide el problema en diversas soluciones que ser\u00e1n ejecutadas por las funciones declaradas). La programaci\u00f3n procedimental o programaci\u00f3n por procedimientos es un paradigma de la programaci\u00f3n. Muchas veces es aplicable tanto en lenguajes de programaci\u00f3n de bajo nivel como en lenguajes de alto nivel. En el caso de que esta t\u00e9cnica se aplique en lenguajes de alto nivel, recibir\u00e1 el nombre de programaci\u00f3n funcional.</p> <ul> <li>se llaman rutinas separadas desde el programa principal</li> <li>datos en su mayor\u00eda globales -&gt; sin protecci\u00f3n.</li> <li>los procedimientos por lo general no pueden ser independientes -&gt; mala reutilizaci\u00f3n del c\u00f3digo.</li> </ul> </li> </ul> <p></p> <ul> <li> Orientada a objetos  -- Construye soluciones basadas en objetos. <pre><code>wikipedia:\nLa programaci\u00f3n orientada a objetos es un paradigma de programaci\u00f3n\nbasado en el concepto de \"objetos\", que pueden contener datos y c\u00f3digo.\nLos datos est\u00e1n en forma de campos y el c\u00f3digo est\u00e1 en forma de procedimientos.\n</code></pre></li> </ul> <p></p>"},{"location":"tipos%20de%20paradigmas/#ventajas-de-la-programacion-oop","title":"Ventajas de la Programaci\u00f3n OOP:","text":"<ul> <li>rutinas y datos se combinan en un objeto -&gt; Encapsulaci\u00f3n.</li> <li>m\u00e9todos/Propiedades -&gt; interfaces definidas para llamadas y acceso a datos.</li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/","title":"Constructor y Destructor","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#metodos-fb_init-fb_reinit-y-fb_exit","title":"M\u00e9todos 'FB_Init', 'FB_Reinit' y 'FB_Exit':","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_init","title":"FB_Init:","text":"<ul> <li>Dependiendo de la tarea, puede ser necesario que los bloques de funciones requieran par\u00e1metros que solo se usan una vez para las tareas de inicializaci\u00f3n. Una forma posible de pasarlos elegantemente es usar el m\u00e9todo FB_init(). Este m\u00e9todo se ejecuta impl\u00edcitamente una vez antes de que se inicie la tarea del PLC y se puede utilizar para realizar tareas de inicializaci\u00f3n.</li> <li>Tambi\u00e9n es posible sobrescribir FB_init(). En este caso, las mismas variables de entrada deben existir en el mismo orden y ser del mismo tipo de datos que en el FB b\u00e1sico. Sin embargo, se pueden agregar m\u00e1s variables de entrada para que el bloque de funciones derivado reciba par\u00e1metros adicionales.</li> <li>Al pasar los par\u00e1metros por FB_init(),no se pueden leer desde el exterior ni cambiar en tiempo de ejecuci\u00f3n. La \u00fanica excepci\u00f3n ser\u00eda la llamada expl\u00edcita de FB_init() desde la tarea del PLC. Sin embargo, esto debe evitarse principalmente, ya que todas las variables locales de la instancia se reinicializar\u00e1n en este caso. Sin embargo, si a\u00fan debe ser posible el acceso, se pueden crear las propiedades apropiadas para los par\u00e1metros.</li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_reinit","title":"FB_Reinit:","text":"<p>Si es necesario, debe implementar FB_reinit expl\u00edcitamente. Si este m\u00e9todo est\u00e1 presente, se llama autom\u00e1ticamente despu\u00e9s de que se haya copiado la instancia del bloque de funci\u00f3n correspondiente (llamada impl\u00edcita). Esto sucede durante un cambio en l\u00ednea despu\u00e9s de cambios en la declaraci\u00f3n de bloque de funci\u00f3n (cambio de firma) para reinicializar el nuevo bloque de instancia. Este m\u00e9todo se llama despu\u00e9s de la operaci\u00f3n de copia y debe establecer valores definidos para las variables de la instancia. Por ejemplo, puede inicializar variables en consecuencia en la nueva ubicaci\u00f3n en la memoria o notificar a otras partes de la aplicaci\u00f3n sobre la nueva ubicaci\u00f3n de variables espec\u00edficas en la memoria. Dise\u00f1e la implementaci\u00f3n independientemente del cambio en l\u00ednea. El m\u00e9todo tambi\u00e9n se puede llamar desde la aplicaci\u00f3n en cualquier momento para restablecer una instancia de bloque de funciones a su estado original.</p>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_exit","title":"FB_Exit:","text":"<p>Si es necesario, debe implementar FB_exit expl\u00edcitamente. Si este m\u00e9todo est\u00e1 presente, se llama autom\u00e1ticamente (impl\u00edcitamente) antes de que el controlador elimine el c\u00f3digo de la instancia del bloque de funciones (por ejemplo, incluso si TwinCAT cambia del modo Ejecutar al modo de configuraci\u00f3n).</p>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 M\u00e9todos FB_init, FB_reinit and FB_exit, Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 M\u00e9todos 'FB_Init', 'FB_Reinit' y 'FB_Exit', Codesys</p> </li> <li> <p>\ud83d\udd17 iec-61131-3-parameter-transfer-via-fb_init, stefanhenneken.net</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/","title":"FB abstracto frente a interfaz","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#fb-abstracto-frente-a-interface","title":"FB Abstracto frente a Interface:","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#fb-abstracto-frente-a-interface_1","title":"FB Abstracto frente a Interface:","text":"<p>FB abastracto frente a interfaz, stefanhenneken.net</p>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/","title":"Bloque de Funcion Declaracion de variables","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/#tipos-de-variables-que-se-pueden-declarar-en-un-function_block","title":"Tipos de variables que se pueden declarar en un FUNCTION_BLOCK:","text":"<ul> <li>\ud83d\udd17 Local Variables - VAR</li> <li>\ud83d\udd17 Input Variables - VAR_INPUT</li> <li>\ud83d\udd17 Output Variables - VAR_OUTPUT</li> <li> <p>\ud83d\udd17 Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</p> </li> <li> <p>\ud83d\udd17 Temporary Variable - VAR_TEMP</p> </li> <li>\ud83d\udd17 Static Variables - VAR_STAT</li> <li>\ud83d\udd17 External Variables - VAR_EXTERNAL</li> <li>\ud83d\udd17 Instance Variables - VAR_INST</li> <li>\ud83d\udd17 Remanent Variables - PERSISTENT, RETAIN</li> <li>\ud83d\udd17 SUPER</li> <li>\ud83d\udd17 THIS</li> <li> <p>\ud83d\udd17 Variable types - attribute keywords</p> <ul> <li>\ud83d\udd17 RETAIN: for remanent variables of type RETAIN</li> <li>\ud83d\udd17 PERSISTENT: for remanent variables of type PERSISTENT</li> <li>\ud83d\udd17 CONSTANT: for constants</li> </ul> </li> <li> <p>Todos estos tipos de variables que se pueden declarar dentro del FB se pueden repetir los mismos tipos de variables dentro del FB, esto podria valer para diferenciar variables del mismo tipo en la zona de declaraci\u00f3n, ser\u00eda meramente indicativo...</p> </li> <li> <p>Ejemplo de declaraci\u00f3n de variables en un FUNCTION_BLOCK: <pre><code>FUNCTION_BLOCK fb_tipos_de_datos\nVAR_INPUT\nbinput : BOOL;\nEND_VAR\nVAR_INPUT\nbinput2 : BOOL;\nEND_VAR\nVAR_OUTPUT\noutput1 : REAL;\nEND_VAR\nVAR_IN_OUT\nin_out1 : LINT;\nEND_VAR\nVAR_IN_OUT CONSTANT\nin_out_constant1 : DINT;\nEND_VAR\nVAR\nvar1 : STRING;\nEND_VAR\nVAR_TEMP\ntemp1 : ULINT;\nEND_VAR\nVAR_STAT\nnVarStat1 : INT;\nEND_VAR\nVAR_EXTERNAL\nnVarExt1 : INT; // 1st external variable\nEND_VAR\nVAR PERSISTENT\nnVarPers1 : DINT; (* 1. Persistent variable *)\nbVarPers2 : BOOL; (* 2. Persistent variable *)\nEND_VAR\nVAR RETAIN\nnRem1 : INT;\nEND_VAR\nVAR CONSTANT\nn : INT:= 10;\nEND_VAR\n</code></pre></p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/","title":"Bloque de Funcion Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/#modificadores-de-acceso-bloque-de-funciones","title":"Modificadores de acceso Bloque de Funciones:","text":"<p>Podemos tener 2 modificadores de acceso para el Bloque de Funciones:</p> <ul> <li>PUBLIC: <ul> <li>No hay restricciones, se puede llamar desde cualquier lugar. </li> <li>Si no ponemos nada al declarar el FB es lo mismo que PUBLIC.</li> <li>Cualquiera puede llamar o crear una instancia del FB.</li> <li>Se puede usar para la herencia al ser public. </li> <li>Son accesibles luego de instanciar la clase.</li> <li>Corresponde a la especificaci\u00f3n de modificador sin restricci\u00f3n de acceso.</li> </ul> </li> <li>INTERNAL: <ul> <li>Solo se puede acceder al FB desde el mismo espacio de nombres. </li> <li>Esto permite que el FB este disponible solo dentro de una determinada biblioteca. La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC .</li> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).</li> </ul> </li> </ul> <p>Podemos tener otros 2 modificadores de acceso para el Bloque de Funciones: - FINAL:     - (en TwinCAT 3 no sale por defecto para seleccionarlo al crear un FB, pero se puede a\u00f1adir mas tarde despues de crearlo...)      - El FB no puede servir como un bloque de funciones principal.      - Los m\u00e9todos y las propiedades de esta POU no se pueden heredar.      - FINAL solo est\u00e1 permitido para POU del tipo FUNCTION_BLOCK.     - No se permite sobrescribir, en un derivado del bloque de funciones.      - Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.   - ABSTRACT:  bloques de funciones abstractas <pre><code>FUNCTION_BLOCK PUBLIC ABSTRACT FB_Foo\n</code></pre>     - Tan pronto como un m\u00e9todo o una propiedad se declaran como abstractos , el bloque de funciones tambi\u00e9n debe declararse como abstracto .     - No se pueden crear instancias a partir de FB abstractos. Los FB abstractos solo se pueden usar como FB b\u00e1sicos cuando se heredan.     - Todos los m\u00e9todos abstractos y todas las propiedades abstractas deben sobrescribirse para crear un FB no abstracto. Un m\u00e9todo abstracto o una propiedad abstracta se convierte en un m\u00e9todo no abstracto o una propiedad no abstracta al sobrescribir.     - Los bloques de funciones abstractas pueden contener adem\u00e1s m\u00e9todos no abstractos y/o propiedades no abstractas.     - Si no se sobrescriben todos los m\u00e9todos abstractos o todas las propiedades abstractas durante la herencia, el FB heredado solo puede ser un FB abstracto (concretizaci\u00f3n paso a paso).     - Se permiten punteros o referencias de tipo FB abstracto. Sin embargo, estos pueden referirse a FB no abstractos y, por lo tanto, llamar a sus m\u00e9todos o propiedades (polimorfismo).   </p>"},{"location":"Clases%20y%20Objetos/Function%20Block/","title":"Bloques de Funciones","text":""},{"location":"Clases%20y%20Objetos/Function%20Block/#declaracion-de-un-function-block","title":"Declaracion de un Function Block:","text":"<pre><code>FUNCTION_BLOCK &lt;access specifier&gt; &lt;function block&gt; | EXTENDS &lt;function block&gt; | IMPLEMENTS &lt;comma-separated list of interfaces&gt;\n</code></pre>"},{"location":"Clases%20y%20Objetos/Function%20Block/#implementacion-bloque-de-funciones","title":"Implementaci\u00f3n Bloque de Funciones:","text":"<p> EXTENDS:  - Si en la declaraci\u00f3n de un FUNCTION_BLOCK a\u00f1adimos la palabra EXTENDS seguida del nombre del FB del cual queremos heredar, significa que heredamos todos sus metodos y propiedades.(principio de Herencia) - Un FB solo puede heredar de una Clase FB.</p> <p> IMPLEMENTS:  - Si en la declaraci\u00f3n de un FUNCTION_BLOCK a\u00f1adimos la palabra IMPLEMENTS seguido del nombre de la interfaz o interfaces separadas por comas. - Si en el FB se implementa una interfaz es obligatorio en el FB crear la programaci\u00f3n de los metodos y propiedades de la interfaz implementada.</p> <ul> <li>Ejemplos de declaraci\u00f3n de FUNCTION_BLOCK: <pre><code>FUNCTION_BLOCK INTERNAL ABSTRACT FB\nFUNCTION_BLOCK INTERNAL FINAL FB\nFUNCTION_BLOCK PUBLIC FINAL FB\nFUNCTION_BLOCK ABSTRACT FB\nFUNCTION_BLOCK PUBLIC ABSTRACT FB\nFUNCTION_BLOCK FB EXTENDS FB1 IMPLEMENTS Interface1, Interface2, Interface3\n</code></pre></li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/","title":"Metodo Declaracion de variables","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/#tipos-de-variables-que-se-pueden-declarar-en-un-method","title":"Tipos de variables que se pueden declarar en un METHOD:","text":"<ul> <li>\ud83d\udd17 Local Variables - VAR</li> <li>\ud83d\udd17 Input Variables - VAR_INPUT</li> <li>\ud83d\udd17 Output Variables - VAR_OUTPUT</li> <li> <p>\ud83d\udd17 Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</p> </li> <li> <p>\ud83d\udd17 Temporary Variable - VAR_TEMP</p> </li> <li>\ud83d\udd17 Static Variables - VAR_STAT</li> <li>\ud83d\udd17 External Variables - VAR_EXTERNAL</li> <li>\ud83d\udd17 Instance Variables - VAR_INST</li> <li>\ud83d\udd17 Remanent Variables - PERSISTENT, RETAIN</li> <li>\ud83d\udd17 SUPER</li> <li>\ud83d\udd17 THIS</li> <li> <p>\ud83d\udd17 Variable types - attribute keywords</p> <ul> <li>RETAIN: for remanent variables of type RETAIN</li> <li>PERSISTENT: for remanent variables of type PERSISTENT</li> <li>CONSTANT: for constants</li> </ul> </li> <li> <p>Ejemplo de declaraci\u00f3n de variables en un METHOD: <pre><code>METHOD metodo0_Declaracion_variables\nVAR_INPUT\nbinput : BOOL;\nEND_VAR\nVAR_INPUT\nbinput2 : BOOL;\nEND_VAR\nVAR_OUTPUT\noutput1 : REAL;\nEND_VAR\nVAR_IN_OUT\nin_out1 : LINT;\nEND_VAR\nVAR_IN_OUT CONSTANT\nin_out_constant1 : DINT;\nEND_VAR\nVAR\nvar1 : STRING;\nEND_VAR\n//!!! no se pueden declarar variables TEMPORALES dentro de la zona de declaraci\u00f3n de variables del m\u00e9todo!!!\n//VAR_TEMP\n//  temp1 : ULINT;\n//END_VAR\nVAR_INST\ncounter : INT;\nEND_VAR\nVAR_STAT\nnVarStat1 : INT;\naarray  : ARRAY[1..n] OF INT;\nEND_VAR\nVAR_EXTERNAL\nnVarExt1 : INT; // 1st external variable\nEND_VAR\n//!!! no se pueden declarar variables PERSISTENT ni RETAIN dentro de la zona de declaraci\u00f3n de variables del m\u00e9todo!!!\n//VAR PERSISTENT\n//    nVarPers1 : DINT; (* 1. Persistent variable *)\n//    bVarPers2 : BOOL; (* 2. Persistent variable *)\n//END_VAR\n//VAR RETAIN\n//    nRem1 : INT;\n//END_VAR\nVAR CONSTANT\nn : INT:= 10;\nEND_VAR\n</code></pre></p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/","title":"Metodo Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/#especificadores-de-acceso-para-los-metodos","title":"Especificadores de acceso para los Metodos:","text":"<p>La declaraci\u00f3n del m\u00e9todo puede incluir un especificador de acceso opcional. Esto restringe el acceso al m\u00e9todo.</p>"},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/#tipos-de-modificadores-de-acceso-para-el-metodo","title":"Tipos de modificadores de acceso para el M\u00e9todo:","text":"<ul> <li>PUBLIC: <ul> <li>Cualquiera puede llamar al m\u00e9todo, no hay restricciones.</li> </ul> </li> <li>PRIVATE: <ul> <li>El m\u00e9todo est\u00e1 disponible solo dentro de la POU. No se puede llamar desde fuera de la POU.</li> <li>Son accesibles dentro de la clase.</li> <li>El acceso est\u00e1 restringido al bloque de funciones o al programa, respectivamente.</li> </ul> </li> <li>PROTECTED: <ul> <li>Solo su propia POU o las POU derivadas (herencia) de ella pueden acceder al m\u00e9todo. La derivaci\u00f3n se analiza a continuaci\u00f3n.</li> <li>Son accesibles a trav\u00e9s de la herencia.</li> <li>El acceso est\u00e1 restringido al programa o al bloque de funci\u00f3n y sus derivados respectivamente.</li> </ul> </li> <li>INTERNAL: <ul> <li>Solo se puede acceder al m\u00e9todo desde el mismo espacio de nombres. Esto permite que los m\u00e9todos est\u00e9n disponibles solo dentro de una determinada biblioteca, por ejemplo.</li> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).</li> </ul> </li> </ul> <p>La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC .    </p> <ul> <li>FINAL:(se puede a\u00f1adir acompa\u00f1ado con alguno de los anteriores) <ul> <li>El m\u00e9todo no puede ser sobrescrito por otro m\u00e9todo. La sobrescritura de m\u00e9todos se describe a continuaci\u00f3n.</li> <li>No se permite sobrescribir, en un derivado del bloque de funciones. </li> <li>Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.</li> </ul> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/","title":"Metodo tipos de variables de retorno","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#tipos-de-variables-de-retorno","title":"Tipos de variables de retorno:","text":"<ul> <li>No es obligatorio en el metodo retornar un tipo de variable.<ul> <li>Ejemplos de declaraci\u00f3n de M\u00e9todos que nos devuelve una variable de diferentes tipos:     <pre><code>METHOD Method1 : BOOL\nMETHOD Method1 : INT\nMETHOD Method1 : REAL\nMETHOD Method1 : STRING\n</code></pre></li> </ul> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-struct","title":"Retorno por STRUCT:","text":"<p>Acceso a un \u00fanico elemento de un tipo de retorno estructurado durante la llamada a m\u00e9todo/funci\u00f3n/propiedad.</p> <p>La siguiente implementaci\u00f3n se puede utilizar para tener acceso directamente a un elemento individual del tipo de datos estructurado que devuelve el m\u00e9todo/funci\u00f3n/propiedad cuando se llama a un m\u00e9todo, funci\u00f3n o propiedad. </p> <p>Un tipo de datos estructurado es, por ejemplo, una estructura o un bloque de funciones.</p> <p>El tipo devuelto del m\u00e9todo/funci\u00f3n/propiedad se define como: <pre><code>REFERENCE TO &lt;structured type&gt;\n//en lugar de simplemente  \n&lt;structured type&gt;\n</code></pre> Tenga en cuenta que con este tipo de retorno, si, por ejemplo, se va a devolver una instancia local FB del tipo de datos estructurados, se debe usar el operador de referencia REF= en lugar del operador de asignaci\u00f3n \"normal\" :=.</p> <p>Las declaraciones y el ejemplo de esta secci\u00f3n se refieren a la llamada de una propiedad. Sin embargo, son igualmente transferibles a otras llamadas que ofrecen valores devueltos (por ejemplo, m\u00e9todos o funciones).</p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#ejemplo","title":"Ejemplo:","text":"<p>Declaraci\u00f3n de la estructura ST_Sample (STRUCTURE): <pre><code>TYPE ST_Sample :\nSTRUCT\nbVar  : BOOL;\nnVar  : INT;\nEND_STRUCT\nEND_TYPE\n</code></pre> Declaraci\u00f3n del bloque de funciones FB_Sample: <pre><code>FUNCTION_BLOCK FB_Sample\nVAR\nstLocal     : ST_Sample;\nEND_VAR\n</code></pre> Declaraci\u00f3n de la propiedad FB_Sample.MyProp con el tipo de devoluci\u00f3n \"REFERENCE TO ST_Sample\": <pre><code>PROPERTY MyProp : REFERENCE TO ST_Sample\n</code></pre> Implementaci\u00f3n del m\u00e9todo Get de la propiedad FB_Sample.MyProp: <pre><code>MyProp REF= stLocal;\n</code></pre> Implementaci\u00f3n del m\u00e9todo Set de la propiedad FB_Sample.MyProp: <pre><code>stLocal := MyProp;\n</code></pre> Llamando a los m\u00e9todos Get y Set en el programa principal MAIN: <pre><code>PROGRAM MAIN\nVAR\nfbSample    : FB_Sample;\nnSingleGet  : INT;\nstGet       : ST_Sample;    bSet        : BOOL;\nstSet       : ST_Sample;\nEND_VAR\n// Get - single member and complete structure possible\nnSingleGet := fbSample.MyProp.nVar;\nstGet      := fbSample.MyProp;\n\n// Set - only complete structure possible \nIF bSet THEN\nfbSample.MyProp REF= stSet;\nbSet            := FALSE;\nEND_IF\n</code></pre></p> <p>Mediante la declaraci\u00f3n del tipo devuelto de la propiedad MyProp como \"REFERENCE TO ST_Sample\" y mediante el uso del operador de referencia REF= en el m\u00e9todo Get de esta propiedad, se puede acceder a un \u00fanico elemento del tipo de datos estructurados devuelto directamente al llamar a la propiedad. <pre><code>VAR\nfbSample    : FB_Sample;\nnSingleGet  : INT;\nEND_VAR\nnSingleGet := fbSample.MyProp.nVar;\n</code></pre> Si el tipo de retorno solo se declarara como \"ST_Sample\", la estructura devuelta por la propiedad tendr\u00eda que asignarse primero a una instancia de estructura local. Los elementos de estructura individuales podr\u00edan consultarse sobre la base de la instancia de estructura local. <pre><code>VAR\nfbSample    : FB_Sample; stGet       : ST_Sample; nSingleGet  : INT;\nEND_VAR\nstGet      := fbSample.MyProp;\nnSingleGet := stGet.nVar;\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-interface","title":"Retorno por INTERFACE:","text":"<p>Ejemplo de declaraci\u00f3n de un m\u00e9todo que nos devuelve una variable del tipo INTERFACE. <pre><code>METHOD Method1 : interface1\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-function_block","title":"Retorno por FUNCTION_BLOCK:","text":"<p>Ejemplo de declaraci\u00f3n de un m\u00e9todo que nos devuelve una variable del tipo FUNCTION_BLOCK. <pre><code>METHOD Method1 : FB1\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/","title":"SUPER puntero","text":""},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#super-puntero","title":"SUPER^ puntero:","text":"<p>cada bloque de funciones que se deriva de otro bloque de funciones tiene acceso a un puntero llamado SUPER^.  Esto se puede usar para acceder a elementos (m\u00e9todos, propiedades, variables locales, etc.) desde el bloque de funciones principal.</p> <p>En lugar de copiar el c\u00f3digo del bloque de funciones principal al nuevo m\u00e9todo, el puntero SUPER^ se puede usar para llamar al m\u00e9todo desde el bloque de funciones  . Esto elimina la necesidad de copiar el c\u00f3digo.</p>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#links-super-pointer","title":"Links SUPER^ pointer:","text":"<ul> <li> <p>\ud83d\udd17 SUPER puntero Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, SUPER</p> </li> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/","title":"THIS puntero","text":""},{"location":"Clases%20y%20Objetos/THIS%20pointer/#this-puntero","title":"THIS^ puntero:","text":"<p>El puntero THIS^ est\u00e1 disponible para todos los bloques de funciones y apunta a la instancia de bloque de funciones actual.  Este puntero es necesario siempre que un m\u00e9todo contenga una variable local que oculte una variable en el bloque de funciones.</p> <p>Una declaraci\u00f3n de asignaci\u00f3n dentro del m\u00e9todo establece el valor de la variable local.  Si queremos que el m\u00e9todo establezca el valor de la variable local en el bloque de funciones, necesitamos usar el puntero THIS^ para acceder a \u00e9l.</p> <p>Al igual que con el puntero SUPER, el puntero THIS tambi\u00e9n debe estar siempre en may\u00fasculas.</p>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/#links-this-pointer","title":"Links THIS^ pointer:","text":"<ul> <li> <p>\ud83d\udd17 THIS puntero Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, THIS</p> </li> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/","title":"Clases y Objetos","text":""},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#clases-y-objetos","title":"Clases y Objetos:","text":"<ul> <li>Una Clase es una plantilla.</li> <li>Un Objeto es la instancia de una Clase.</li> </ul> <pre><code>En este Ejemplo Nos encontramos la Clase Coche,\ny hemos instanciado esta Clase para tener los Objetos de Coches \nMercedes, Bmw y Audi...\n</code></pre>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#representacion-de-la-clase-coche-en-stl-oop-iec-61131-3","title":"Representacion de la Clase Coche en STL OOP IEC 61131-3","text":"<p><pre><code>FUNCTION_BLOCK Coche\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n    _Marca : STRING;\n    _Color : STRING;\n    accion : STRING;\nEND_VAR\n----------------------------------------------------------------\nMETHOD PUBLIC Acelerar\naccion := 'acelerar';\n----------------------------------------------------------------\nMETHOD PUBLIC Conducir\naccion := 'conducir';\n----------------------------------------------------------------\nMETHOD PUBLIC Frenar\naccion := 'frenar';\n----------------------------------------------------------------\nPROPERTY PUBLIC Color : STRING\nGet\n    Color := _Color;\nSet\n    _Color := Color;\n----------------------------------------------------------------\nPROPERTY PUBLIC Marca : STRING\nGet\n    Marca := _Marca;\nSet\n    _Marca := Marca;\n</code></pre> Instancia de la clase en los Objetos: Mercedes,Bmw y Audi y llamadas a sus metodos y propiedades... <pre><code>PROGRAM _01_Clase_y_Objetos\nVAR\n    // tenemos la Clase Coche y la instanciamos y obtenemos los Objetos: Mercedes, Bmw y Audi.\n    Mercedes : Coche;\n    Bmw : Coche;\n    Audi: Coche;\n\n    Color : STRING;\n    Marca : STRING;\n\n    Acelerar : BOOL;\n    Conducir:  BOOL;\n    Frenar  : BOOL; \nEND_VAR\n\n//Objeto Mercedes\n//llamadas a sus m\u00e9todos.\nIF Acelerar THEN\n    Mercedes.Acelerar();\n    Acelerar := FALSE;\nEND_IF\n\nIF Conducir THEN\n    Mercedes.Conducir();\n    Conducir := FALSE;\nEND_IF\n\nIF Frenar THEN\n    Mercedes.Frenar();\n    Frenar := FALSE;\nEND_IF\n\n//llamadas a sus propiedades.\nMercedes.Marca := 'Mercedes';\nMercedes.Color := 'Negro';\nColor := Mercedes.Color;\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 methods-properties-and-inheritance (stefanhenneken)</li> </ul>"},{"location":"Clases%20y%20Objetos/herencia/","title":"Herencia","text":""},{"location":"Clases%20y%20Objetos/herencia/#herencia","title":"Herencia:","text":"<p>Los bloques de funciones son un medio excelente para mantener las secciones del programa separadas entre s\u00ed. Esto mejora la estructura del software y simplifica significativamente la reutilizaci\u00f3n. Anteriormente, ampliar la funcionalidad de un bloque de funciones existente siempre era una tarea delicada. Esto signific\u00f3 modificar el c\u00f3digo o programar un nuevo bloque de funciones alrededor del bloque existente (es decir, el bloque de funciones existente se incrust\u00f3 efectivamente dentro de un nuevo bloque de funciones). En el \u00faltimo caso, fue necesario crear todas las variables de entrada nuevamente y asignarlas a las variables de entrada para el bloque de funciones existente. Lo mismo se requer\u00eda, en sentido contrario, para las variables de salida.</p> <p>TwinCAT 3 y Codesys (IEC61131-3) introduce el concepto de herencia. La herencia es uno de los principios fundamentales de la programaci\u00f3n orientada a objetos. La herencia implica derivar un nuevo bloque de funciones a partir de un bloque de funciones existente. A continuaci\u00f3n, se puede ampliar el nuevo bloque. En la medida permitida por los especificadores de acceso del bloque de funciones principal, el nuevo bloque de funciones hereda todas las propiedades y m\u00e9todos del bloque de funciones principal. Cada bloque de funciones puede tener cualquier n\u00famero de bloques de funciones secundarios, pero solo un bloque de funciones principal. La derivaci\u00f3n de un bloque de funciones se produce en la nueva declaraci\u00f3n del bloque de funciones. El nombre del nuevo bloque de funciones va seguido de la palabra clave EXTENDS seguida del nombre del bloque de funciones principal. Por ejemplo:</p> <p><pre><code>FUNCTION_BLOCK PUBLIC FB_NewEngine EXTENDS FB_Engine\n</code></pre> El nuevo bloque de funciones derivado ( FB_NewEngine ) posee todas las propiedades y m\u00e9todos de su padre ( FB_Engine ). Sin embargo, los m\u00e9todos y las propiedades solo se heredan cuando el especificador de acceso lo permite.</p> <p>El bloque de funciones secundario tambi\u00e9n hereda todas las variables Locales, VAR_INPUT , VAR_OUTPUT y VAR_IN_OUT del bloque de funciones principal. Este comportamiento no se puede modificar mediante especificadores de acceso.</p> <p>Si los m\u00e9todos o las propiedades del bloque de funciones principal se han declarado como PROTECTED, el bloque de funciones secundario ( FB_NewEngine ) podr\u00e1 acceder a ellos, pero no desde fuera de FB_NewEngine .</p> <p>La herencia se aplica solo a las POU de tipo FUNCTION_BLOCK.</p>"},{"location":"Clases%20y%20Objetos/herencia/#especificadores-de-acceso","title":"Especificadores de acceso:","text":"<p>Las declaraciones FUNCTION_BLOCK , FUNCTION o PROGRAM pueden incluir un especificador de acceso. Esto restringe el acceso y, en su caso, la capacidad de heredar.</p> <ul> <li>PUBLIC:</li> </ul> <p>Cualquiera puede llamar o crear una instancia de la POU. Adem\u00e1s, si la POU es un FUNCTION_BLOCK , se puede usar para la herencia. No se aplican restricciones.</p> <ul> <li>INTERN:</li> </ul> <p>La POU solo se puede utilizar dentro de su propio espacio de nombres. Esto permite que las POU est\u00e9n disponibles solo dentro de una determinada biblioteca, por ejemplo.</p> <ul> <li>FINAL:</li> </ul> <p>El FUNCTION_BLOCK no puede servir como un bloque de funciones principal. Los m\u00e9todos y las propiedades de esta POU no se pueden heredar. FINAL solo est\u00e1 permitido para POU del tipo FUNCTION_BLOCK .</p> <p>La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC. Los especificadores de acceso PRIVATE y PROTECTED no est\u00e1n permitidos en las declaraciones de POU.</p> <p>Si planea utilizar la herencia, la declaraci\u00f3n del bloque de funciones tendr\u00e1 la siguiente estructura:</p> <pre><code>FUNCTION_BLOCK &lt;Access specifier&gt; &lt;Name&gt; EXTENDS &lt;Name basic function block&gt;\n</code></pre>"},{"location":"Clases%20y%20Objetos/herencia/#metodos-de-sobrescritura","title":"M\u00e9todos de Sobrescritura:","text":"<p>El nuevo FUNCTION_BLOCK FB_NewEngine , que se deriva de FB_Engine , puede contener propiedades y m\u00e9todos adicionales. Por ejemplo, podemos agregar la propiedad Gear . Esta propiedad se puede utilizar para consultar y cambiar la marcha actual. Es necesario configurar getters y setters para esta propiedad.</p> <p>Sin embargo, tambi\u00e9n debemos asegurarnos de que el par\u00e1metro nGear del m\u00e9todo Start() se pase a esta propiedad. Debido a que el bloque de funciones principal FB_Engine no tiene acceso a esta nueva propiedad, se debe crear un nuevo m\u00e9todo con exactamente los mismos par\u00e1metros en FB_NewEngine . Copiamos el c\u00f3digo existente al nuevo m\u00e9todo y agregamos nuevo c\u00f3digo para que el par\u00e1metro nGear se pase a la propiedad Gear .</p> <p><pre><code>METHOD PUBLIC Start\nVAR_INPUT\nnGear : INT := 2;\nfVelocity : LREAL := 8.0;\nEND_VAR IF (fVelocity &lt; MaxVelocity) THEN\nvelocityInternal := fVelocity;\nELSE\nvelocityInternal := MaxVelocity;\nEND_IF\nGear := nGear; // new\n</code></pre> La l\u00ednea 12 copia el par\u00e1metro nGear a la propiedad Gear.</p> <p>Cuando un m\u00e9todo o propiedad que ya est\u00e1 presente en el bloque de funciones principal se redefine dentro del bloque de funciones secundario, esto se denomina sobrescritura. El bloque de funciones FB_NewEngine sobrescribe el m\u00e9todo Start() .</p> <p>Por lo tanto, FB_NewEngine tiene la nueva propiedad Gear y sobrescribe el m\u00e9todo Start() .</p> <p></p> <p><pre><code>fbNewEngine.Start(1, 7.5);\n</code></pre> llama al m\u00e9todo Start() en FB_NewEngine, ya que este m\u00e9todo ha sido redefinido (sobrescrito) en FB_NewEngine .</p> <p>Mientras que:</p> <p><pre><code>fbNewEngine.Stop();\n</code></pre> llama al m\u00e9todo Stop() desde FB_Engine . El m\u00e9todo Stop() ha sido heredado por FB_NewEngine de FB_Engine .</p>"},{"location":"Clases%20y%20Objetos/herencia/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</li> <li>\ud83d\udd17 Simple Codesys OOP - Inheritance</li> </ul>"},{"location":"Clases%20y%20Objetos/interface/","title":"Interface","text":""},{"location":"Clases%20y%20Objetos/interface/#interface","title":"Interface:","text":"<p>Una interfaz es una clase que contiene m\u00e9todos y propiedades sin implementaci\u00f3n.  La interfaz se puede implementar en cualquier clase, pero esa clase debe implementar todos sus m\u00e9todos. y propiedades.</p> <p>Si bien la herencia es una relaci\u00f3n \"es un\", las interfaces se pueden describir como \"se comporta como\" o \u201ctiene una\u201d relaci\u00f3n.</p> <p>Las interfaces son objetos que permiten que varias clases diferentes tengan algo en com\u00fan con menos dependencias. Las clases y los bloques de funciones pueden implementar varias interfaces diferentes. Uno puede pensar en los m\u00e9todos y propiedades de la interfaz como acciones que significan cosas diferentes dependiendo de qui\u00e9n los est\u00e9 ejecutando. Por ejemplo, la palabra \"Correr\" significa \"mover a una velocidad m\u00e1s r\u00e1pido que un paseo\u201d para un ser humano, pero significa \u201cejecutar\u201d para las computadoras.</p> <p>Las clases o bloques de funciones que no comparten similitudes pueden implementar la misma interfaz. En este caso, la implementaci\u00f3n de los m\u00e9todos en cada clase puede ser totalmente diferente. Esto abre muchos enfoques de programaci\u00f3n poderosos:</p> <ul> <li>Las POU pueden llamar a una interfaz para ejecutar un m\u00e9todo o acceder a una propiedad, sin saber cu\u00e1l clase o FB con el que se trata o c\u00f3mo va a ejecutar la operaci\u00f3n.  La interfaz luego apunta a una clase o bloque de funci\u00f3n que implementa la interfaz y la operaci\u00f3n que es ejecutado.</li> <li>Los programadores pueden crear cajas de interruptores f\u00e1cilmente personalizables usando polimorfismo.</li> </ul>"},{"location":"Clases%20y%20Objetos/interface/#links-interface","title":"Links Interface:","text":"<ul> <li> <p>\ud83d\udd17 Codesys Comando 'Implementar interfaces'</p> </li> <li> <p>\ud83d\udd17 Codesys Objeto Interface</p> </li> <li> <p>\ud83d\udd17 Codesys Implementando Interfaces</p> </li> <li> <p>\ud83d\udd17 Beckhoff Objeto Interface</p> </li> <li> <p>\ud83d\udd17 Beckhoff Implementando Interfaces</p> </li> <li> <p>\ud83d\udd17 Extender Interfaces, Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 TC09.Beckhoff TwinCAT3 Function Block-Part4 Interface.JP</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/metodo/","title":"Metodo","text":""},{"location":"Clases%20y%20Objetos/metodo/#method","title":"METHOD:","text":"<p>Los M\u00e9todos dividen la clase (bloque de funciones) en funciones m\u00e1s peque\u00f1as que se pueden ejecutar en llamada. Solo trabajar\u00e1n con los datos que necesitan e ignorar\u00e1n cualquier dato redundante que puede existir en un determinado bloque de funciones.</p> <p>Los m\u00e9todos pueden acceder y manipular las variables internas de la clase principal, pero tambi\u00e9n pueden usar variables propias a las que la clase principal no puede acceder (a menos que sean de salida la variable).</p> <p>Adem\u00e1s, los m\u00e9todos son una forma mucho m\u00e1s eficiente de ejecutar un programa porque, al dividir una funci\u00f3n en varios m\u00e9todos, el usuario evita ejecutar todo el POU cada vez, ejecutar solo peque\u00f1as porciones de c\u00f3digo siempre que sea necesario llamarlas. </p> <p>Esto es un muy buena manera de evitar errores y corrupci\u00f3n de datos. Los m\u00e9todos tambi\u00e9n tienen un nombre, lo que significa que estas porciones de c\u00f3digo se pueden identificar por su prop\u00f3sito en lugar de las variables que manipulan, mejorando as\u00ed la lectura de c\u00f3digo, comprensi\u00f3n y la soluci\u00f3n de problemas.</p> <p>La abstracci\u00f3n juega un papel importante aqu\u00ed, si los programadores desean implementar el c\u00f3digo,  solo necesitan llamar al m\u00e9todo.</p> <p>La soluci\u00f3n de problemas tambi\u00e9n se convierte en m\u00e1s simple: entonces el programador no necesita buscar cada instancia del c\u00f3digo, solo necesitan verificar el m\u00e9todo correspondiente. A diferencia de la clase base, los m\u00e9todos usan la memoria temporal del controlador: los datos son vol\u00e1tiles, ya que las variables solo mantendr\u00e1n sus valores mientras se ejecuta el m\u00e9todo. Si se suponen valores que deben mantenerse entre ciclos de ejecuci\u00f3n, entonces la variable debe almacenarse en la clase base o en alg\u00fan otro lugar que retendr\u00e1 los valores de un ciclo al otro (como la  lista de variables globales -- GVL), o tambi\u00e9n se puede utilizar la variable de tipo VAR_INST.</p> <p>Por lo tanto, una declaraci\u00f3n de M\u00e9todo tiene la siguiente estructura: <pre><code>METHOD &lt;Access specifier&gt; &lt;Name&gt; : &lt;Datatype return value&gt;\n</code></pre> No es obligatorio que un M\u00e9todo deba devolver un valor...</p>"},{"location":"Clases%20y%20Objetos/metodo/#ejemplo-de-declaracion-de-method","title":"Ejemplo de declaraci\u00f3n de METHOD:","text":"<pre><code>METHOD Method1 : BOOL\nVAR_INPUT\nnIn1  : INT;\nbIn2  : BOOL;\nEND_VAR\nVAR_OUTPUT\nfOut1 : REAL;\nsOut2 : STRING;\nEND_VAR\n</code></pre>"},{"location":"Clases%20y%20Objetos/metodo/#links-del-objeto-metodo","title":"Links del Objeto Metodo:","text":"<ul> <li> <p>\ud83d\udd17 Documentaci\u00f3n Codesys del Objeto m\u00e9todo</p> </li> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Beckhoff del Objeto m\u00e9todo</p> </li> <li> <p>\ud83d\udd17 TC08.Beckhoff TwinCAT3 Function Block-Part3 Method.JP</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/modificadores%20de%20acceso/","title":"Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/modificadores%20de%20acceso/#modificadores-de-acceso","title":"Modificadores de Acceso:","text":"<ul> <li>PUBLIC: <ul> <li>Son accesibles luego de instanciar la clase.</li> <li>Corresponde a la especificaci\u00f3n de modificador sin restricci\u00f3n de acceso.</li> </ul> </li> <li>PRIVATE: <ul> <li>Son accesibles dentro de la clase.</li> <li>El acceso est\u00e1 restringido al bloque de funciones o al programa, respectivamente.</li> </ul> </li> <li>PROTECTED: <ul> <li>Son accesibles a trav\u00e9s de la herencia.</li> <li>El acceso est\u00e1 restringido al programa o al bloque de funci\u00f3n y sus derivados respectivamente.</li> </ul> </li> <li>INTERNAL:<ul> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).  </li> </ul> </li> <li>FINAL:<ul> <li>No se permite sobrescribir, en un derivado del bloque de funciones. </li> <li>Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.</li> </ul> </li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/","title":"puntero y referencia","text":"<p>Pointers_Basics.pdf</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#links-de-puntero-y-referencia","title":"Links de Puntero y Referencia:","text":"<ul> <li> <p>\ud83d\udd17 Perre Garriga,Pointer&amp;Reference</p> </li> <li> <p>\ud83d\udd17 Control and use of Pointers In Codesys</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Pointers</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/propiedad/","title":"Objeto Propiedad","text":""},{"location":"Clases%20y%20Objetos/propiedad/#propiedades","title":"Propiedades:","text":"<p>Las propiedades son las principales variables de una clase. Se pueden utilizar como una alternativa a la clase regular o E/S del bloque de funciones. Las propiedades tienen m\u00e9todos Get \"Obtener\" y Set \"Establecer\" que permiten acceder y/o cambiar las variables:</p> <ul> <li>Get - M\u00e9todo que devuelve el valor de una variable.</li> <li>Set - M\u00e9todo que establece el valor de una variable.</li> </ul> <p>Al eliminar el m\u00e9todo \"Obtener\" o \"Establecer\", un programador puede hacer que las propiedades sean \"de solo escritura\" o \u201csolo lectura\u201d, respectivamente. Dado que estos son m\u00e9todos, significa que las propiedades pueden:</p> <ul> <li>Tener sus propias variables internas.</li> <li>Realizar operaciones antes de devolver su valor.</li> <li>No es necesario adjuntar la variable devuelta a una entrada o salida en particular (o variable interna) de la POU, puede devolver un valor basado en una determinada combinaci\u00f3n de sus variables.</li> <li>Ser accedido por evento en lugar de ser verificado en cada ciclo de ejecuci\u00f3n.</li> </ul>"},{"location":"Clases%20y%20Objetos/propiedad/#propiedades-getters-setters","title":"Propiedades: Getters &amp; Setters:","text":"<p>para modificar directamente nuestras propiedades lo que se busca es que se haga a trav\u00e9s de los metodos Getters y Setters, el cual var\u00eda la escritura seg\u00fan el lenguaje pero el concepto es el mismo.</p> <p>Por lo tanto, una declaraci\u00f3n de propiedad tiene la siguiente estructura:</p> <p><pre><code>PROPERTY &lt;Access specifier&gt; &lt;Name&gt; : &lt;Datatype&gt;\n</code></pre> En el Objeto Propiedad es obligatorio que retorne un valor.</p>"},{"location":"Clases%20y%20Objetos/propiedad/#especificadores-de-acceso","title":"Especificadores de acceso:","text":"<p>Al igual que con los m\u00e9todos, las propiedades tambi\u00e9n pueden tomar los siguientes especificadores de acceso: PUBLIC , PRIVATE , PROTECTED , INTERNAL y FINAL . Cuando no se define ning\u00fan especificador de acceso, la propiedad es PUBLIC . Adem\u00e1s, tambi\u00e9n se puede especificar un especificador de acceso para cada setter y getter. Esto tiene prioridad sobre el propio especificador de acceso de la propiedad.</p> <p>Las propiedades son reconocibles por las siguientes caracter\u00edsticas:</p> <p>Especificador de acceso:</p> <ul> <li>PUBLIC: <ul> <li>Corresponde a la especificaci\u00f3n de modificador sin acceso.</li> </ul> </li> <li>PRIVATE: <ul> <li>El acceso a la propiedad est\u00e1 limitado solo al bloque de funciones.</li> </ul> </li> <li>PROTECTED:<ul> <li>El acceso a la propiedad est\u00e1 limitado al programa o al bloque de funci\u00f3n y sus derivados.</li> </ul> </li> <li>INTERNAL:<ul> <li>El acceso a la propiedad est\u00e1 limitado al espacio de nombres, es decir, a la biblioteca.</li> </ul> </li> <li>FINAL: <ul> <li>No se permite sobrescribir la propiedad en un derivado del bloque de funciones. Esto significa que la propiedad no se puede sobrescribir ni extender en una subclase posiblemente existente.</li> <li>Las propiedades pueden ser abstractas, lo que significa que una propiedad no tiene una implementaci\u00f3n inicial y que la implementaci\u00f3n real se proporciona en el bloque de funciones derivado.</li> </ul> </li> </ul> <p>Los pragmas son muy \u00fatiles para monitorear propiedades en modo en l\u00ednea. Para esto, escr\u00edbalos en la parte superior de las declaraciones de propiedades (attribute 'monitoring'):</p> <p>{attribute 'monitoring := 'variable'}:  Al acceder a una propiedad, TwinCAT almacena el valor real en una variable y muestra el valor de esta \u00faltima. Este valor puede volverse obsoleto si el c\u00f3digo ya no accede a la propiedad.</p> <p>{attribute 'monitoring' := 'call'}:  Cada vez que se muestra el valor, TwinCAT llama al c\u00f3digo del descriptor de acceso Get. Cualquier efecto secundario, provocado por ese c\u00f3digo, puede aparecer en el seguimiento.</p>"},{"location":"Clases%20y%20Objetos/propiedad/#links-del-objeto-propiedad","title":"Links del Objeto Propiedad:","text":"<ul> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Codesys del Objeto propiedad</p> </li> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Beckhoff del Objeto propiedad</p> </li> <li> <p>\ud83d\udd17 utilizing-properties,twincontrols.com</p> </li> <li> <p>\ud83d\udd17 object-oriented-programming-in-programmable-logic-controllers-plc-whats-really-new,en.grse.de</p> </li> <li> <p>\ud83d\udd17 TC07.Beckhoff TwinCAT3 Function Block-Part2 Property.JP- DUT</p> </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Strategy%20pattern/","title":"Patron de Estrategia","text":"<p>TwinCAT with Head First Design Patterns Ch.1 - IntroStrategy Pattern.docx</p>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/","title":"Patrones de Dise\u00f1o","text":"<p>PATRONES DE DISE\u00d1OS</p> <p>\u201cLos patrones de dise\u00f1o son  descripciones de objetos y clases  conectadas que se personalizan para  resolver un problema de dise\u00f1o  general en un contexto particular\u201d.  - Gang of Four </p> <p></p> <p></p> <p> </p> <p>Clasificaci\u00f3n seg\u00fan su prop\u00f3sito:  Los patrones de dise\u00f1o se clasificaron originalmente en tres grupos: </p> <ul> <li>Creacionales. </li> <li>Estructurales. </li> <li>De comportamiento. </li> </ul> <p>Clasificaci\u00f3n seg\u00fan su \u00e1mbito:</p> <ul> <li>De clase: Basados en la herencia de clases. </li> <li>De objeto: Basados en la utilizaci\u00f3n din\u00e1mica de objetos. </li> </ul> <p>Patrones creacionales:</p> <ul> <li>Builder</li> <li>Singleton </li> <li>Dependency Injection </li> <li>Service Locator </li> <li>Abstract Factory</li> <li>Factory Method </li> </ul> <p>Patrones estructurales:</p> <ul> <li>Adapter</li> <li>Data Access Object (DAO)  </li> <li>Query Object </li> <li>Decorator </li> <li>Bridge </li> </ul> <p>Patrones de comportamiento:</p> <ul> <li>Command</li> <li>Chain of Responsibility </li> <li>Strategy</li> <li>Template Method </li> <li>Interpreter</li> <li>Observer </li> <li>State </li> <li>Visitor </li> <li>Iterator </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li>IEC 61131-3: SOLID \u2013 The Interface Segregation Principle</li> </ul>"},{"location":"UML/Class%20UML/","title":"Class UML","text":""},{"location":"UML/Class%20UML/#class-uml","title":"Class UML","text":""},{"location":"UML/Class%20UML/#uml","title":"UML:","text":"<ul> <li> <p>\ud83d\udd17 www.lucidchart.com/tutorial-de-diagrama-de-clases-uml</p> </li> <li> <p>\ud83d\udd17 www.edrawsoft.com/uml-class-diagram-explained</p> </li> <li> <p>\ud83d\udd17 blog.visual-paradigm.com/what-are-the-six-types-of-relationships-in-uml-class-diagrams</p> </li> <li> <p>\ud83d\udd17 Ingenier\u00eda del Software: Fundamentos de UML usando Papyrus</p> </li> <li> <p>\ud83d\udd17 plantuml.com/class-diagram</p> </li> <li> <p>\ud83d\udd17 www.planttext.com</p> </li> <li> <p>\ud83d\udd17 UML Infosys Beckhoff</p> </li> </ul>"},{"location":"UML/Statechart%20UML/","title":"StateChart UML","text":""},{"location":"UML/Statechart%20UML/#state-chart","title":"state chart:","text":""},{"location":"UML/UML/","title":"UML","text":""},{"location":"UML/UML/#uml","title":"UML","text":"<ul> <li>https://www.plccoder.com/twincat-uml-class-diagram/</li> </ul>"},{"location":"principios/_principios%20OOP/","title":"4 Pilares","text":"<p> Principios OOP: (4 pilares) </p> <ul> <li>Abstracci\u00f3n -- La forma de plasmar algo hacia el c\u00f3digo para enfocarse en su uso. No enfocarnos tanto en que hay por detras del codigo si no en el uso de este.</li> <li>Encapsulamiento -- No toda la informaci\u00f3n de nuestro objeto es relevante y/o accesible para el usuario.</li> <li>Herencia -- Es la cualidad de heredar caracteristicas de otra clase. (EXTENDS)</li> <li>Polimorfismo -- Las m\u00faltiples formas que puede obtener un objeto si comparte la misma clase o interfaz. (IMPLEMENTS) </li> </ul> <p></p>"},{"location":"principios/abstraccion/","title":"Abstracci\u00f3n","text":""},{"location":"principios/abstraccion/#abstraccion","title":"abstraccion","text":"<p>Abstraction is the process of hiding important information, showing only the most essential  information. It reduces code complexity and isolates the impact of changes. Abstraction can be understood from a real-life example: turning on a television must only  require clicking on a button, as people don\u2019t need to know or the process that it goes through. Even though that process can be complex and important, there is no need for the user to know  how it is implemented. The important information that isn\u2019t required is hidden from the user,  reducing code complexity, enhancing data hiding and reusability, thus making function  blocks easier to implement and modify.</p> <p>La palabra clave ABSTRACT est\u00e1 disponible para bloques de funciones, m\u00e9todos y propiedades. Permite la implementaci\u00f3n de un proyecto PLC con niveles de abstracci\u00f3n.</p> <p>La abstracci\u00f3n es un concepto clave de la programaci\u00f3n orientada a objetos. Los diferentes niveles de abstracci\u00f3n contienen aspectos de implementaci\u00f3n generales o espec\u00edficos.</p>"},{"location":"principios/abstraccion/#aplicacion-de-la-abstraccion","title":"Aplicaci\u00f3n de la abstracci\u00f3n:","text":"<p>Es \u00fatil implementar funciones b\u00e1sicas o puntos en com\u00fan de diferentes clases en una clase b\u00e1sica abstracta. Se implementan aspectos espec\u00edficos en subclases no abstractas. El principio es similar al uso de una interfaz. Las interfaces corresponden a clases puramente abstractas que contienen s\u00f3lo m\u00e9todos y propiedades abstractas. Una clase abstracta tambi\u00e9n puede contener m\u00e9todos y propiedades no abstractos.</p> <p>Reglas para el uso de la palabra clave ABSTRACT - No se pueden instanciar bloques de funciones abstractas. - Los bloques de funciones abstractas pueden contener m\u00e9todos y propiedades abstractos y no abstractos. - Los m\u00e9todos abstractos o las propiedades no contienen ninguna implementaci\u00f3n (s\u00f3lo la declaraci\u00f3n). - Si un bloque de funci\u00f3n contiene un m\u00e9todo o propiedad abstracta, debe ser abstracto. - Los bloques de funciones abstractas deben extenderse para poder implementar los m\u00e9todos o propiedades abstractos. - Por lo tanto: un FB derivado debe implementar los m\u00e9todos/propiedades de su FB b\u00e1sico o tambi\u00e9n debe definirse como abstracto.</p> <ul> <li> <p>\ud83d\udd17 ABSTRACT,www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 ABSTRACION Concepto, Infosys Beckhoff</p> </li> </ul>"},{"location":"principios/encapsulamiento/","title":"Encapsulamiento","text":""},{"location":"principios/encapsulamiento/#encapsulamiento","title":"encapsulamiento","text":"<p>La encapsulaci\u00f3n se utiliza para agrupar datos con los m\u00e9todos que operan en ellos y para ocultar datos en su interior. una clase, evitando que personas no autorizadas accedan directamente a ella. Reduce la complejidad del c\u00f3digo y aumenta la reutilizaci\u00f3n. La separaci\u00f3n del c\u00f3digo permite la creaci\u00f3n de rutinas que pueden ser reutilizadas en lugar de copiar y pegar c\u00f3digo, reduciendo la complejidad del programa principal.</p> <ul> <li>https://www.plccoder.com/encapsulation/</li> </ul>"},{"location":"principios/herencia/","title":"Herencia","text":""},{"location":"principios/herencia/#herencia","title":"herencia","text":"<p>Inheritance allows the user to create classes based on other classes. The inherited classes can  use the base class\u2019s functionalities as well as some additional functionalities that the user may  define. It eliminates redundant code, prevents copying and pasting and makes expansion easier.  This is very useful because it allows classes to be extended of modified (overridden) without  changing the base class\u2019s code implementation. What do an old landline phone and a smartphone have in common? Both of them can be  classified as phones. Should they be classified as objects? No, as they also define the properties  and behaviors of a group of objects. A smartphone works just like a regular phone, but it is also  able to take pictures, navigate the internet, and do many other things. So, old landline phone and smartphone are child classes that extend the parent phone class.</p> <p>Superclase: la clase cuyas caracter\u00edsticas se heredan se conoce como superclase (o una clase base o una clase principal).  Subclase: la clase que hereda la otra clase se conoce como subclase (o una clase derivada, clase extendida o clase hija).</p> <ul> <li>\ud83d\udd17 [stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance](https://stefanhenneken.net/2017/04/23/</li> </ul>"},{"location":"principios/polimorfismo/","title":"Polimorfismo","text":""},{"location":"principios/polimorfismo/#polimorfismo","title":"polimorfismo","text":"<p>The concept of polymorphism is derived by the combination of two words: Poly (Many) and  Morphism (Form). It refactors ugly and complex switch cases/case statements. Object-Oriented PLC Programming 8 Polymorphism allows an object to change its appearance and performance depending on the  practical situation in order to be able to carry out a particular task [10]. It can be either static or  dynamic: static polymorphism occurs when the object\u2019s type is defined by the compiler;  dynamic polymorphism occurs when the type is determined during run-time, making it possible  for a same variable to access different objects while the program is running. A good example to explain polymorphism is a Swiss Army Knife (Figure 2.4): Figure 2.4 - Swiss Army Knife A Swiss Army Knife is a single tool that includes a bunch of resources that can be used to solve different issues. Selecting the proper tool, a Swiss Army Knife can be used to efficiently perform a certain set of valuable tasks. In the dual way, a simple adder block that adapts itself  to cope with, for instance, int, float, string, and time data types is an example of a polymorphic  programming resource.</p> <p>\u00bfComo conseguir el Polimorfismo?</p> <p>El polimorfismo se puede obtener gracias a las Interfaces y/o las Clases Abstractas.</p> <p>.Interface: (INTERFACE) - Son un contrato que obliga a una clase a implementar las propiedades y/o m\u00e9todos definidos. - Son una plantilla (sin l\u00f3gica).</p> <p>.Clases Abstractas: (ABSTRACT) - Son Clases que no se pueden instanciar, solo pueden ser implementadas a trav\u00e9s de la herencia.</p> <ul> <li> <p>Diferencias:</p> Clases abstractas Interfaces 1.- Limitadas a una sola implementaci\u00f3n. 1. No tiene limitaci\u00f3n de implementaci\u00f3n. 2.- Pueden definir comportamiento base. 2. Expone propiedades y m\u00e9todos abstractos (sin l\u00f3gica). *** ### Links Polimorfismo: </li> <li> <p>\ud83d\udd17 polymorphism, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 abstract, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 [stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance](https://stefanhenneken.net/2017/04/23/</p> </li> </ul>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/","title":"Principio de Abierto/Cerrado","text":""},{"location":"solid/Principio%20de%20Abierto_Cerrado/#principio-de-abiertocerrado","title":"Principio de Abierto/Cerrado","text":"<p>La definici\u00f3n del principio abierto/cerrado El Principio Abierto/Cerrado (OCP) fue formulado por Bertrand Meyer en 1988 y establece:</p> <p>Una entidad de software debe estar abierta a extensiones, pero al mismo tiempo cerrada a modificaciones. Entidad de software: Esto significa una clase, bloque de funci\u00f3n, m\u00f3dulo, m\u00e9todo, servicio, ...</p> <p>Abierto: el comportamiento de los m\u00f3dulos de software debe ser extensible.</p> <p>Cerrado: la capacidad de expansi\u00f3n no debe lograrse cambiando el software existente.</p> <p>Cuando Bertrand Meyer defini\u00f3 el Principio Abierto/Cerrado (OCP) a fines de la d\u00e9cada de 1980, la atenci\u00f3n se centr\u00f3 en el lenguaje de programaci\u00f3n C++. Usaba herencia, bien conocida en el mundo orientado a objetos. La disciplina de la orientaci\u00f3n a objetos, que a\u00fan era joven en ese momento, promet\u00eda grandes mejoras en la reutilizaci\u00f3n y la mantenibilidad al permitir que clases concretas se usaran como clases base para nuevas clases.</p> <p>Cuando Robert C. Martin se hizo cargo del principio de Bertrand Meyer en la d\u00e9cada de 1990, lo implement\u00f3 t\u00e9cnicamente de manera diferente. C ++ permite el uso de herencia m\u00faltiple, mientras que la herencia m\u00faltiple rara vez se encuentra en los lenguajes de programaci\u00f3n m\u00e1s nuevos. Por este motivo, Robert C. Martin se centr\u00f3 en el uso de interfaces. Se puede encontrar m\u00e1s informaci\u00f3n al respecto en el libro (enlace publicitario de Amazon *) Arquitectura limpia: el manual pr\u00e1ctico para el dise\u00f1o de software profesional.</p> <p>Resumen Sin embargo, adherirse al principio abierto/cerrado (OCP) conlleva el riesgo de un exceso de ingenier\u00eda. La opci\u00f3n de extensiones solo debe implementarse donde sea espec\u00edficamente necesario. El software no puede dise\u00f1arse de tal manera que todas las extensiones imaginables puedan implementarse sin realizar ajustes en el c\u00f3digo fuente.</p> <p>!!! este link es en aleman, poner el link en ingles cuando salga:!!!</p>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net, iec-61131-3-solid-das-open-closed-principle</li> </ul>"},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/","title":"Principio de Inversi\u00f3n de Dependencia","text":""},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/#principio-de-inversion-de-dependencia","title":"Principio de Inversi\u00f3n de Dependencia:","text":""},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-dependency-inversion-principle</li> </ul>"},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/","title":"Principio de Responsabilidad \u00danica","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/#principio-de-responsabilidad-unica","title":"Principio de Responsabilidad \u00danica:","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-single-responsibility-principle</li> </ul>"},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/","title":"Principio de Segregaci\u00f3n de Interfaz","text":""},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/#principio-de-segregacion-de-interfaz","title":"Principio de Segregaci\u00f3n de Interfaz","text":""},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-interface-segregation-principle</li> </ul>"},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/","title":"Principio de Sustituci\u00f3n de Liskov","text":""},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/#principio-de-sustitucion-de-liskov","title":"Principio de sustituci\u00f3n de Liskov","text":""},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-liskov-substitution-principle</li> </ul>"},{"location":"solid/_SOLID/","title":"SOLID","text":"<p> - Propuesta por Robert C.Martin en el 2000. - Son recomendaciones para escribir un c\u00f3digo sostenible,mantenible,escalable y robusto. - Beneficios:     - Alta Cohesi\u00f3n. Colaboracion entre clases.     - Bajo Acoplamiento. Evitar que una clase dependa fuertemente de otra clase.</p> <ul> <li>Principio de Responsabilidad \u00danica: Una clase debe tener una raz\u00f3n para existir mas no para cambiar.</li> <li>Principio de Abierto/Cerrado: Las piezas del software deben estar abiertas para la extensi\u00f3n pero cerradas para la modificaci\u00f3n.</li> <li>Principio de Sustituci\u00f3n de Liskov: Las clases subtipos deber\u00edan ser reemplazables por sus clases padres.</li> <li>Principio de Segregaci\u00f3n de Interfaz: Varias interfaces funcionan mejor que una sola.</li> <li>Principio de Inversi\u00f3n de Dependencia: Clases de alto nivel no deben depender de las clases bajo nivel.</li> </ul> <p>Adem\u00e1s de los principios SOLID, existen otros principios como: - Keep It Simple, Stupid (KISS). - Don't Repeat Yourself (DRY). - Law Of Demeter (LOD). - You Ain't Gonna Need It (YAGNI).</p> <p>Todos estos principios tienen el objetivo com\u00fan de mejorar la mantenibilidad y la reutilizaci\u00f3n del software.</p>"},{"location":"solid/_SOLID/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 C\u00f3mo explicar conceptos de programaci\u00f3n orientada a objetos a un ni\u00f1o de 6 a\u00f1os</li> </ul>"}]}