{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduccion","text":"<p> \ud83d\udcd6 Curso Programaci\u00f3n Orientada a Objetos Youtube -- OOP : </p> <p>  by Runtimevic -- V\u00edctor Dur\u00e1n Mu\u00f1oz. </p>"},{"location":"#que-es-oop","title":"\u00bf Qu\u00e9 es OOP?","text":"<ul> <li> <p>Es un paradigma que hace uso de los objetos para la construcci\u00f3n de los software.</p> <p>. \u00bf Qu\u00e9 es un paradigma?</p> <ul> <li>Tiene diferentes interpretaciones, puede ser un modelo, ejemplo o patr\u00f3n.</li> <li>Es una forma o un estilo de programar.</li> <li>se busca plasmar la realidad hacia el c\u00f3digo.</li> </ul> </li> </ul>"},{"location":"#como-pensar-en-objetos","title":"\u00bfC\u00f3mo pensar en Objetos?","text":"<ul> <li>Enfocarse en algo de la realidad.</li> <li>Detalla sus atributos, (propiedades)</li> <li>Detalla sus comportamientos (metodos)</li> </ul> <pre><code>\ud83d\udcf1 Ejemplo: (Telefono m\u00f3vil-smartphone)\n\n. \u00bfQu\u00e9 atributos (Propiedades) reconocemos? \n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - Realizar llamadas.\n    - Navegar por internet. \n</code></pre> <pre><code>\ud83d\ude97 Ejemplo: (Coche)\n\n. \u00bfQu\u00e9 atributos (Propiedades) reconocemos? \n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - conducir.\n    - frenar. \n    - acelerar.\n</code></pre>"},{"location":"#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 Codesys admite OOP</p> </li> <li> <p>\ud83d\udd17 Beckhoff TwinCAT 3 admite OOP</p> </li> <li> <p>\ud83d\udd17 Why Object Oriented PLC Programming is Essential for Industrial Automation</p> </li> </ul>"},{"location":"#link-al-video-de-youtube-001","title":"Link al Video de Youtube 001:","text":"<ul> <li>\ud83d\udd17 001 - OOP IEC 61131-3 PLC -- Introducci\u00f3n a la pagina de documentaci\u00f3n SSG, repositorio...</li> </ul>"},{"location":"OOP_Curso_Youtube_Runtimevic/","title":"OOP Curso Youtube Runtimevic","text":"<p> \ud83d\udcd6 Curso Programaci\u00f3n Orientada a Objetos Youtube -- OOP : </p> <p>  by Runtimevic -- V\u00edctor Dur\u00e1n Mu\u00f1oz. </p> <p> . \u00bf Qu\u00e9 es OOP?   . \u00bf Qu\u00e9 es OOP?   - Es un paradigma que hace uso de los objetos para la construcci\u00f3n de los software.       . \u00bf Qu\u00e9 es un paradigma?     - Tiene diferentes interpretaciones, puede ser un **modelo**, **ejemplo** o **patr\u00f3n.**     - Es una **forma** o un **estilo** de programar. - se busca plasmar la realidad hacia el c\u00f3digo.   . \u00bfC\u00f3mo pensar en Objetos?   - Enfocarse en **algo de la realidad.** - Detalla sus **atributos, (propiedades)** - Detalla sus **comportamientos (metodos)**  <pre><code>Ejemplo: (telefono m\u00f3vil-smartphone)\n. \u00bfQu\u00e9 atributos reconocemos? (Propiedades)\n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - Realizar llamadas.\n    - Navegar por internet. \n</code></pre> ***  . Tipos de paradigmas:   - Imperativa -- (**Instrucciones a seguir** para dar soluci\u00f3n a un problema). - Declarativa -- (Se **enfoca en el problema** a solucionar). - Estructurada -- (La soluci\u00f3n a un problema sigue **una secuencia de inico a fin**). -  Orientada a objetos (Construye soluciones **basadas en objetos**).  - Funcional -- (Divide el problema en diversas soluciones que ser\u00e1n ejecutadas por las **funciones declaradas**). ***  . Clases y Objetos:   - Una Clase es una **plantilla**. - Un Objeto es la **instancia de una Clase**.  <p>   ***  . Principios OOP: (4 pilares)  - Abstracci\u00f3n -- La forma de **plasmar algo hacia el c\u00f3digo** para enfocarse en su uso. No enfocarnos tanto en que hay por detras del codigo si no en el uso de este. - Encapsulamiento -- No toda la informaci\u00f3n de nuestro objeto es **relevante y/o accesible** para el usuario. - Herencia -- Es la cualidad de **heredar caracteristicas** de otra clase. (EXTENDS) - Polimorfismo -- Las **m\u00faltiples formas** que puede obtener un objeto si comparte la misma **clase o interfaz**. (IMPLEMENTS)   <p> </p>  *** \u00bfComo conseguir el Polimorfismo?  .Interface: (INTERFACE) - Son un **contrato que obliga** a una clase a **implementar** las **propiedades** y/o **m\u00e9todos** definidos. - Son una plantilla (sin l\u00f3gica).  .Clases Abstractas: (ABSTRACT) - Son Clases que no se pueden instanciar, solo pueden ser implementadas a trav\u00e9s de la herencia.  - Diferencias:      | Clases abstractas | Interfaces |      | :--- | :--- |          | 1.- Limitadas a una sola implementaci\u00f3n.   | 1. No tiene limitaci\u00f3n de implementaci\u00f3n.     |      | 2.- Pueden definir comportamiento base.     | 2. Expone prpiedades y m\u00e9todos abstractos (sin l\u00f3gica).     |   *** .modificadores de acceso:  - public: son accesibles luego de instanciar la clase. - private: son accesibles dentro de la clase. - protected: son accesibles a trav\u00e9s de la herencia. - internal: *** .Propiedades: Getters &amp; Setters  para modificar directamente nuestras propiedades lo que se busca es que se haga a trav\u00e9s de los metodos Getters y Setters, el cual var\u00eda la escritura seg\u00fan el lenguaje pero el concepto es el mismo. *** .Relaciones:  Vamos a ver 2 tipos de relaciones:  - Asociaci\u00f3n.     - De uno a uno: Una clase mantiene una **asociaci\u00f3n de a uno** con otra clase.     - De uno a muchos: Una clase mantiene una asociaci\u00f3n con otra clase **a trav\u00e9s de una colecci\u00f3n**.     - De muchos a muchos: La **asociaci\u00f3n se da en ambos lados** a trav\u00e9s de una colecci\u00f3n. - Colaboraci\u00f3n.     - La colaboraci\u00f3n se da **a trav\u00e9s de una referencia de una clase** con el fin de **lograr un cometido**.    ***  . SOLID: (5 principios)   ![SOLID](./imagenes/SOLID.png) - Propuesta por **Robert C.Martin** en el 2000. - Son **recomendaciones** para escribir un c\u00f3digo **sostenible,mantenible,escalable y robusto**. - Beneficios:       - Alta **Cohesi\u00f3n**. Colaboracion entre clases.     - Bajo **Acoplamiento**. Evitar que una clase dependa fuertemente de otra clase.   - Principio de Responsabilidad \u00danica: Una clase debe tener **una raz\u00f3n** para existir mas no para cambiar. - Principio de Abierto/Cerrado: Las piezas del software deben estar **abiertas para la extensi\u00f3n** pero **cerradas para la modificaci\u00f3n**. - Principio de Sustituci\u00f3n de Liskov: Las **clases subtipos** deber\u00edan ser reemplazables por sus **clases padres**. - Principio de Segregaci\u00f3n de Interfaz: Varias **interfaces** funcionan **mejor que una sola**. - Principio de Inversi\u00f3n de Dependencia: Clases de **alto nivel** no deben depender de las clases **bajo nivel**. ***  ![OOP_Logo](./imagenes/OO_Logo.jpg)         \ud83d\udc69\u200d\ud83c\udfeb \ud83d\udc68\u200d\ud83c\udfeb   ![Placeholder](https://dummyimage.com/600x400/eee/aaa){: align=left }"},{"location":"Tipos%20de%20Dise%C3%B1o%20para%20programacion%20de%20PLC/","title":"Tipos de Dise\u00f1o para programacion de PLC","text":""},{"location":"Tipos%20de%20Dise%C3%B1o%20para%20programacion%20de%20PLC/#tipos-de-diseno-para-programacion-de-plc","title":"Tipos de Dise\u00f1o para programacion de PLC:","text":"<p>Ingenieria de desarrollo para la programaci\u00f3n OOP - Dise\u00f1o por Componente, Unidad, Dispositivo, Objeto...     - Los objetos son las unidades b\u00e1sicas de la programaci\u00f3n orientada a objetos.     - Un componente proporciona servicios, mientras que un objeto proporciona operaciones y m\u00e9todos. Un componente puede ser entendido por todos, mientras que un objeto solo puede ser entendido por los desarrolladores.     - Las unidades son los grupos de c\u00f3digo m\u00e1s peque\u00f1os que se pueden mantener y ejecutar de forma independiente - Dise\u00f1o por Pruebas Unitarias. - Dise\u00f1o en UML.</p> <p>Units: (Ejemplo de Unidades): -FBTimer -FCAnalogSensor -FBGenericUnit</p> <p>!!! puntos que se pueden incluir en el curso!!!</p> <ul> <li>Basic of Structured Text programming Language</li> <li>UDT (estructuras)</li> <li>Modular Design</li> <li>Polymorphism</li> <li>Access Specifiers</li> <li>Advanced State Pattern</li> <li>Wrappers and Features</li> <li>Layered Design</li> <li> <p>Final Project covering a real-world problem to be solved using OOP</p> </li> <li> <p>Texto estructurado (ST), Texto estructurado extendido (ExST)</p> </li> </ul>"},{"location":"links/","title":"Links","text":""},{"location":"links/#links-de-oop","title":"Links de OOP:","text":""},{"location":"links/#mencion-a-la-fuentes-links-empleadas-para-la-realizacion-de-esta-documentacion","title":"Menci\u00f3n a la Fuentes Links empleadas para la realizaci\u00f3n de esta Documentaci\u00f3n:","text":""},{"location":"page3/","title":"Page3","text":""},{"location":"page3/#esta-es-la-pagina-3","title":"esta es la pagina 3","text":""},{"location":"page3/#contact","title":"contact","text":"<p>este es mi contacto: Victor</p> <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa....</p> <pre><code>diagrama de clase\nnota \"De pato a cebra\"\nAnimal &lt;|-- Duck\nnote for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\"\nAnimal &lt;|-- Fish\nAnimal &lt;|-- Zebra\nAnimal : +int age\nAnimal : +String gender\nAnimal: +isMammal()\nAnimal: +mate()\nclass Duck{\n    +String beakColor\n    +swim()\n    +quack()\n}\nclass Fish{\n    -int sizeInFeet\n    -canEat()\n}\nclass Zebra{\n    +bool is_wild\n    +run()\n}</code></pre> <pre><code>graph TD\nA[Client] --&gt; B[Load Balancer]\nB --&gt; C[Server01]\nB --&gt; D[Server02]</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre> <pre><code>classDiagram\n  Person &lt;|-- Student\n  Person &lt;|-- Professor\n  Person : +String name\n  Person : +String phoneNumber\n  Person : +String emailAddress\n  Person: +purchaseParkingPass()\n  Address \"1\" &lt;-- \"0..1\" Person:lives at\n  class Student{\n    +int studentNumber\n    +int averageMark\n    +isEligibleToEnrol()\n    +getSeminarsTaken()\n  }\n  class Professor{\n    +int salary\n  }\n  class Address{\n    +String street\n    +String city\n    +String state\n    +int postalCode\n    +String country\n    -validate()\n    +outputAsLabel()  \n  }</code></pre>"},{"location":"page4/","title":"Page4","text":""},{"location":"page4/#esta-es-la-pagina-400","title":"esta es la pagina 4.0.0","text":"<p><code>Bold Code</code></p>"},{"location":"page4/#my-first-article","title":"My first article","text":"<p>This is my first article with some code:</p> <pre><code>class Test\n{\nstatic void Main()\n{\nConsole.WriteLine(\"Hello World\");\n}\n}\n</code></pre>"},{"location":"page4/#esta-es-la-pagina-1","title":"esta es la pagina 1","text":"Image caption <pre><code>  graph TD;\n      A--&gt;B;\n      A--&gt;C;\n      B--&gt;D;\n      C--&gt;D;</code></pre>"},{"location":"requisitos/","title":"Requisitos","text":"<p> \ud83d\udc68\u200d\ud83c\udf93 Requisitos \ud83d\udc69\u200d\ud83c\udf93 : </p> <p></p> <p>Los requisitos necesarios para seguir este curso ser\u00edan tener instalados los siguientes softwares:</p> <ul> <li>\ud83d\udd17 Beckhoff TwinCAT 3 XAE \u00f3 el IDE de \ud83d\udd17 Codesys.</li> <li>Tener cuenta de usuario creada en \ud83d\udd17 GitHub.</li> <li> <p>saber lo m\u00ednimo de Git o apoyarse en herramientas visuales como pueden ser:</p> <ul> <li>\ud83d\udd17 GitHub Desktop.</li> <li>\ud83d\udd17 sourcetree</li> <li>\ud83d\udd17 tortoiseGit, etc...</li> <li>Ser\u00eda bueno tener algo de conocimientos previos de teoria de OOP, aunque sean en otros lenguajes de programaci\u00f3n ya que seran extrapolables para el enfoque de este curso de OOP IEC61131-3 para PLCs.</li> </ul> </li> </ul>"},{"location":"requisitos/#pasos-para-empezar","title":"Pasos para empezar:","text":"<ul> <li> <p>Clonar el repositorio de \ud83d\udd17GitHub:</p> <p>$ git clone https://github.com/runtimevic/OOP-IEC61131-3--Curso-Youtube.git</p> <p>\u00f3 utilizar por ejemplo GitHub Desktop para Clonar el repositorio de GitHub...</p> </li> <li> <p>Nos encontraremos las siguientes carpetas:</p> <ul> <li>\ud83d\udd17 TC3_OOP: Dentro de esta carpeta se encuentra el proyecto de TwinCAT3, con todo lo que se va explicando en los videos de youtube...</li> <li>\ud83d\udd17 Ficheros_PLCOpen_XML: Dentro de esta carpeta nos iremos encontrando los ficheros exportados en formato PLCOpen XML para que puedan ser importados en TwinCAT3 \u00f3 en Codesys de todo lo explicado en Youtube, ya que al ser el formato standarizado de PLCOpen se puede exportar/importar en todas las marcas de PLCs que sigan el estandard PLCOpen..., pero es recomendable intentar realizar lo explicado desde cero para ir practicando y asumir los conceptos explicados...</li> <li>tambien esta alojada la creaci\u00f3n de esta pagina web SSG, (Generador de Sitios Est\u00e1ticos) la cual se ira modificando conforme avancemos en este Curso de OOP IEC-61131-3 PLC...</li> </ul> </li> </ul>"},{"location":"requisitos/#link-al-video-de-youtube-001","title":"Link al Video de Youtube 001:","text":"<ul> <li>\ud83d\udd17 001 - OOP IEC 61131-3 PLC -- Introducci\u00f3n a la pagina de documentaci\u00f3n SSG, repositorio...</li> </ul>"},{"location":"tipos%20de%20paradigmas/","title":"Tipos de paradigmas","text":""},{"location":"tipos%20de%20paradigmas/#tipos-de-paradigmas","title":"Tipos de paradigmas:","text":"<ul> <li>Imperativa -- (Instrucciones a seguir para dar soluci\u00f3n a un problema).</li> <li>Declarativa -- (Se enfoca en el problema a solucionar).</li> <li>Estructurada -- (La soluci\u00f3n a un problema sigue una secuencia de inico a fin).</li> <li> <p>Funcional -- (Divide el problema en diversas soluciones que ser\u00e1n ejecutadas por las funciones declaradas). La programaci\u00f3n procedimental o programaci\u00f3n por procedimientos es un paradigma de la programaci\u00f3n. Muchas veces es aplicable tanto en lenguajes de programaci\u00f3n de bajo nivel como en lenguajes de alto nivel. En el caso de que esta t\u00e9cnica se aplique en lenguajes de alto nivel, recibir\u00e1 el nombre de programaci\u00f3n funcional.</p> <ul> <li>se llaman rutinas separadas desde el programa principal</li> <li>datos en su mayor\u00eda globales -&gt; sin protecci\u00f3n.</li> <li>los procedimientos por lo general no pueden ser independientes -&gt; mala reutilizaci\u00f3n del c\u00f3digo.</li> </ul> </li> </ul> <p></p> <ul> <li> Orientada a objetos  -- Construye soluciones basadas en objetos. <pre><code>wikipedia:\nLa programaci\u00f3n orientada a objetos es un paradigma de programaci\u00f3n\nbasado en el concepto de \"objetos\", que pueden contener datos y c\u00f3digo.\nLos datos est\u00e1n en forma de campos y el c\u00f3digo est\u00e1 en forma de procedimientos.\n</code></pre></li> </ul> <p></p>"},{"location":"tipos%20de%20paradigmas/#ventajas-de-la-programacion-oop","title":"Ventajas de la Programaci\u00f3n OOP:","text":"<ul> <li>rutinas y datos se combinan en un objeto -&gt; Encapsulaci\u00f3n.</li> <li>m\u00e9todos/Propiedades -&gt; interfaces definidas para llamadas y acceso a datos.</li> </ul>"},{"location":"tipos%20de%20paradigmas/#link-al-video-de-youtube-002","title":"Link al Video de Youtube 002:","text":"<ul> <li>\ud83d\udd17 002 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> <li>\ud83d\udd17 003 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/","title":"Constructor y Destructor","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#metodos-fb_init-fb_reinit-y-fb_exit","title":"M\u00e9todos 'FB_Init', 'FB_Reinit' y 'FB_Exit':","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_init","title":"FB_Init:","text":"<ul> <li>Dependiendo de la tarea, puede ser necesario que los bloques de funciones requieran par\u00e1metros que solo se usan una vez para las tareas de inicializaci\u00f3n. Una forma posible de pasarlos elegantemente es usar el m\u00e9todo FB_init(). Este m\u00e9todo se ejecuta impl\u00edcitamente una vez antes de que se inicie la tarea del PLC y se puede utilizar para realizar tareas de inicializaci\u00f3n.</li> <li>Tambi\u00e9n es posible sobrescribir FB_init(). En este caso, las mismas variables de entrada deben existir en el mismo orden y ser del mismo tipo de datos que en el FB b\u00e1sico. Sin embargo, se pueden agregar m\u00e1s variables de entrada para que el bloque de funciones derivado reciba par\u00e1metros adicionales.</li> <li>Al pasar los par\u00e1metros por FB_init(),no se pueden leer desde el exterior ni cambiar en tiempo de ejecuci\u00f3n. La \u00fanica excepci\u00f3n ser\u00eda la llamada expl\u00edcita de FB_init() desde la tarea del PLC. Sin embargo, esto debe evitarse principalmente, ya que todas las variables locales de la instancia se reinicializar\u00e1n en este caso. Sin embargo, si a\u00fan debe ser posible el acceso, se pueden crear las propiedades apropiadas para los par\u00e1metros.</li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_reinit","title":"FB_Reinit:","text":"<p>Si es necesario, debe implementar FB_reinit expl\u00edcitamente. Si este m\u00e9todo est\u00e1 presente, se llama autom\u00e1ticamente despu\u00e9s de que se haya copiado la instancia del bloque de funci\u00f3n correspondiente (llamada impl\u00edcita). Esto sucede durante un cambio en l\u00ednea despu\u00e9s de cambios en la declaraci\u00f3n de bloque de funci\u00f3n (cambio de firma) para reinicializar el nuevo bloque de instancia. Este m\u00e9todo se llama despu\u00e9s de la operaci\u00f3n de copia y debe establecer valores definidos para las variables de la instancia. Por ejemplo, puede inicializar variables en consecuencia en la nueva ubicaci\u00f3n en la memoria o notificar a otras partes de la aplicaci\u00f3n sobre la nueva ubicaci\u00f3n de variables espec\u00edficas en la memoria. Dise\u00f1e la implementaci\u00f3n independientemente del cambio en l\u00ednea. El m\u00e9todo tambi\u00e9n se puede llamar desde la aplicaci\u00f3n en cualquier momento para restablecer una instancia de bloque de funciones a su estado original.</p>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_exit","title":"FB_Exit:","text":"<p>Si es necesario, debe implementar FB_exit expl\u00edcitamente. Si este m\u00e9todo est\u00e1 presente, se llama autom\u00e1ticamente (impl\u00edcitamente) antes de que el controlador elimine el c\u00f3digo de la instancia del bloque de funciones (por ejemplo, incluso si TwinCAT cambia del modo Ejecutar al modo de configuraci\u00f3n).</p>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 M\u00e9todos FB_init, FB_reinit and FB_exit, Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 M\u00e9todos 'FB_Init', 'FB_Reinit' y 'FB_Exit', Codesys</p> </li> <li> <p>\ud83d\udd17 iec-61131-3-parameter-transfer-via-fb_init, stefanhenneken.net</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#link-al-video-de-youtube-003","title":"Link al Video de Youtube 003:","text":"<ul> <li>\ud83d\udd17 003 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/","title":"FB abstracto frente a interfaz","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#fb-abstracto-frente-a-interface","title":"FB Abstracto frente a Interface:","text":"<p>la diferencia entre utilizar un bloque de funci\u00f3n abstracto y una interfaz es que el FB Abstracto es un tipo de plantilla que define un conjunto de variables y par\u00e1metros de entrada/salida para ser utilizados en diferentes partes del programa. </p> <p>Por otro lado, una interfaz define un conjunto de m\u00e9todos y atributos (propiedades) que deben ser implementados por cualquier clase que la implemente. </p> <p>En resumen, los bloques de funci\u00f3n abstractos son \u00fatiles cuando se necesita reutilizar c\u00f3digo en diferentes partes del programa, mientras que las interfaces son \u00fatiles cuando se quiere asegurar que determinadas clases implementen ciertos m\u00e9todos.</p> <p>Imaginar que tienes un programa que controla diferentes tipos de motores, como motores el\u00e9ctricos, motores a gasolina y motores diesel. Para crear una estructura modular y reutilizable, podr\u00edas crear un bloque de funci\u00f3n abstracto llamado \"Controlador de Motor\" que tenga entradas para el tipo de motor, la velocidad y la direcci\u00f3n. Luego, este bloque de funci\u00f3n abstracto puede ser utilizado en diferentes partes del programa para controlar los diferentes motores. El bloque de funci\u00f3n abstracto define una plantilla com\u00fan que se utiliza en diferentes partes del programa. Por otro lado, si quisieras asegurarte de que todas las clases que controlan motores implementen ciertos m\u00e9todos (por ejemplo, un m\u00e9todo para encender el motor y otro para apagarlo), podr\u00edas crear una interfaz llamada \"Controlador de Motor\" que defina estos m\u00e9todos. Luego, cualquier clase que implemente esta interfaz deber\u00e1 implementar estos m\u00e9todos obligatoriamente. En resumen, los bloques de funci\u00f3n abstractos son \u00fatiles cuando se necesita reutilizar c\u00f3digo en diferentes partes del programa, mientras que las interfaces son \u00fatiles cuando se quiere asegurar que determinadas clases implementen ciertos m\u00e9todos.</p> <ul> <li>Los bloques de funciones, los m\u00e9todos y las propiedades se pueden marcar como abstractos. \"desde TwinCAT V3.1 build 4024\".</li> <li>Los FB abstractos solo se pueden usar como FB b\u00e1sicos para la herencia.</li> <li>La instanciaci\u00f3n directa de FBs abstractos no es posible.Por lo tanto, los FB abstractos tienen cierta similitud con las interfaces.</li> </ul> <p>Ahora, la pregunta es en qu\u00e9 caso se debe usar una interfaz y en qu\u00e9 caso un FB abstracto.</p>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#metodos-abstractos","title":"M\u00e9todos abstractos:","text":"<pre><code>METHOD PUBLIC ABSTRACT DoSomething : LREAL\n</code></pre> <ul> <li>Consisten exclusivamente en la declaraci\u00f3n y no contienen ninguna implementaci\u00f3n. El cuerpo del m\u00e9todo est\u00e1 vac\u00edo.</li> <li>Puede ser p\u00fablico , protegido o interno . El modificador de acceso privado no est\u00e1 permitido.</li> <li>No puede ser declarada adicionalmente como definitiva.</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#propiedades-abstractas","title":"Propiedades abstractas:","text":"<pre><code>PROPERTY PUBLIC ABSTRACT nAnyValue : UINT\n</code></pre> <ul> <li>Puede contener getters, setters o ambos.</li> <li>Getter y setter consisten solo en la declaraci\u00f3n y no contienen ninguna implementaci\u00f3n.</li> <li>Puede ser p\u00fablico , protegido o interno . El modificador de acceso privado no est\u00e1 permitido.</li> <li>No puede ser declarada adicionalmente como definitiva .</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#bloques-de-funciones-abstractas","title":"Bloques de funciones abstractas:","text":"<pre><code>FUNCTION_BLOCK PUBLIC ABSTRACT FB_Foo\n</code></pre> <ul> <li>Tan pronto como un m\u00e9todo o una propiedad se declaran como abstractos , el bloque de funciones tambi\u00e9n debe declararse como abstracto .</li> <li>No se pueden crear instancias a partir de FB abstractos. Los FB abstractos solo se pueden usar como FB b\u00e1sicos cuando se heredan.</li> <li>Todos los m\u00e9todos abstractos y todas las propiedades abstractas deben sobrescribirse para crear un FB no abstracto. Un m\u00e9todo abstracto o una propiedad abstracta se convierte en un m\u00e9todo no abstracto o una propiedad no abstracta al sobrescribir.</li> <li>Los bloques de funciones abstractas pueden contener adem\u00e1s m\u00e9todos no abstractos y/o propiedades no abstractas.</li> <li>Si no se sobrescriben todos los m\u00e9todos abstractos o todas las propiedades abstractas durante la herencia, el FB heredado solo puede ser un FB abstracto (concretizaci\u00f3n paso a paso).</li> <li>Se permiten punteros o referencias de tipo FB abstracto. Sin embargo, estos pueden referirse a FB no abstractos y, por lo tanto, llamar a sus m\u00e9todos o propiedades (polimorfismo).</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#diferencias-entre-un-fb-abstracto-y-una-interfaz","title":"Diferencias entre un FB abstracto y una interfaz:","text":"<p>Si un bloque de funciones consta exclusivamente de m\u00e9todos abstractos y propiedades abstractas, entonces no contiene ninguna implementaci\u00f3n y, por lo tanto, tiene cierta similitud con las interfaces. Sin embargo, hay algunas caracter\u00edsticas especiales a considerar en detalle.</p> Interfaz FB Abstracto admite herencia m\u00faltiple + - puede contener variables locales - + puede contener m\u00e9todos no abstractos - + puede contener propiedades no abstractas - + admite m\u00e1s modificadores de acceso adem\u00e1s de p\u00fablico - + aplicable con matriz + solo atrav\u00e9s de PUNTERO <p>La tabla puede dar la impresi\u00f3n de que las interfaces pueden reemplazarse casi por completo por FB abstractos. Sin embargo, las interfaces ofrecen una mayor flexibilidad porque se pueden usar en diferentes jerarqu\u00edas de herencia.</p> <p>Por lo tanto, como desarrollador, desea saber cu\u00e1ndo se debe usar una interfaz y cu\u00e1ndo se debe usar un FB abstracto. La respuesta simple es preferiblemente ambos al mismo tiempo. Esto proporciona una implementaci\u00f3n est\u00e1ndar en el FB base abstracto, lo que facilita su derivaci\u00f3n. Sin embargo, cada desarrollador tiene la libertad de implementar la interfaz directamente.</p>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#ejemplo","title":"Ejemplo:","text":"<p>Los bloques de funciones deben dise\u00f1arse para la gesti\u00f3n de datos de los empleados. Se hace una distinci\u00f3n entre empleados permanentes ( FB_FullTimeEmployee ) y empleados por contrato ( FB_ContractEmployee ). Cada empleado se identifica por su nombre ( sFirstName ), apellido ( sLastName ) y el n\u00famero de personal ( nPersonnelNumber ). Las propiedades correspondientes se proporcionan para este prop\u00f3sito. Adem\u00e1s, se requiere un m\u00e9todo que genere el nombre completo, incluido el n\u00famero de personal, como una cadena formateada ( GetFullName() ). El c\u00e1lculo de los ingresos mensuales se realiza mediante el m\u00e9todo GetMonthlySalary().</p> <p>Lo resolveremos de 3 formas distintas:</p>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#1-enfoque-de-solucion-fb-abstracto","title":"1. Enfoque de soluci\u00f3n: FB abstracto","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#2-enfoque-de-solucion-interfaz","title":"2. Enfoque de soluci\u00f3n: Interfaz","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#3-enfoque-de-solucion-combinacion-de-fb-abstracto-e-interfaz","title":"3. Enfoque de soluci\u00f3n: combinaci\u00f3n de FB abstracto e interfaz","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#resumen-conclusiones","title":"Resumen, Conclusiones:","text":"<ul> <li>Si el usuario no debe crear una instancia propia del FB (porque esto no parece ser \u00fatil), entonces los FB abstractos o las interfaces son \u00fatiles.</li> <li>Si se quiere tener la posibilidad de generalizar en m\u00e1s de un tipo b\u00e1sico, se debe utilizar una interfaz.</li> <li>Si se puede configurar un FB sin implementar m\u00e9todos o propiedades, se debe preferir una interfaz a un FB abstracto.</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#links-fb-abstracto-frente-a-interface","title":"links FB Abstracto frente a Interface:","text":"<ul> <li> <p>\ud83d\udd17 FB abastracto frente a interfaz, stefanhenneken.net</p> </li> <li> <p>\ud83d\udd17 The ABSTRACT keyword, www.plccoder.com </p> </li> <li> <p>\ud83d\udd17 ABSTRACT concept, infosys.beckhoff.com </p> </li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#link-al-video-de-youtube-013","title":"Link al Video de Youtube 013:","text":"<ul> <li>\ud83d\udd17 013 - OOP IEC 61131-3 PLC -- FB Abstract vs Interface</li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/","title":"Bloque de Funcion Declaracion de variables","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/#tipos-de-variables-que-se-pueden-declarar-en-un-function_block","title":"Tipos de variables que se pueden declarar en un FUNCTION_BLOCK:","text":"<ul> <li>\ud83d\udd17 Local Variables - VAR</li> <li>\ud83d\udd17 Input Variables - VAR_INPUT</li> <li>\ud83d\udd17 Output Variables - VAR_OUTPUT</li> <li> <p>\ud83d\udd17 Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</p> </li> <li> <p>\ud83d\udd17 Temporary Variable - VAR_TEMP</p> </li> <li>\ud83d\udd17 Static Variables - VAR_STAT</li> <li>\ud83d\udd17 External Variables - VAR_EXTERNAL</li> <li>\ud83d\udd17 Instance Variables - VAR_INST</li> <li>\ud83d\udd17 Remanent Variables - PERSISTENT, RETAIN</li> <li>\ud83d\udd17 SUPER</li> <li>\ud83d\udd17 THIS</li> <li> <p>\ud83d\udd17 Variable types - attribute keywords</p> <ul> <li>\ud83d\udd17 RETAIN: for remanent variables of type RETAIN</li> <li>\ud83d\udd17 PERSISTENT: for remanent variables of type PERSISTENT</li> <li>\ud83d\udd17 CONSTANT: for constants</li> </ul> </li> <li> <p>Todos estos tipos de variables que se pueden declarar dentro del FB se pueden repetir los mismos tipos de variables dentro del FB, esto podria valer para diferenciar variables del mismo tipo en la zona de declaraci\u00f3n, ser\u00eda meramente indicativo...</p> </li> <li> <p>Ejemplo de declaraci\u00f3n de variables en un FUNCTION_BLOCK: <pre><code>FUNCTION_BLOCK fb_tipos_de_datos\nVAR_INPUT\nbinput : BOOL;\nEND_VAR\nVAR_INPUT\nbinput2 : BOOL;\nEND_VAR\nVAR_OUTPUT\noutput1 : REAL;\nEND_VAR\nVAR_IN_OUT\nin_out1 : LINT;\nEND_VAR\nVAR_IN_OUT CONSTANT\nin_out_constant1 : DINT;\nEND_VAR\nVAR\nvar1 : STRING;\nEND_VAR\nVAR_TEMP\ntemp1 : ULINT;\nEND_VAR\nVAR_STAT\nnVarStat1 : INT;\nEND_VAR\nVAR_EXTERNAL\nnVarExt1 : INT; // 1st external variable\nEND_VAR\nVAR PERSISTENT\nnVarPers1 : DINT; (* 1. Persistent variable *)\nbVarPers2 : BOOL; (* 2. Persistent variable *)\nEND_VAR\nVAR RETAIN\nnRem1 : INT;\nEND_VAR\nVAR CONSTANT\nn : INT:= 10;\nEND_VAR\n</code></pre></p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/#link-al-video-de-youtube-004","title":"Link al Video de Youtube 004:","text":"<ul> <li>\ud83d\udd17 004 - OOP IEC 61131-3 PLC -- Clase y Objeto </li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/","title":"Bloque de Funcion Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/#modificadores-de-acceso-bloque-de-funciones","title":"Modificadores de acceso Bloque de Funciones:","text":"<p>Podemos tener 2 modificadores de acceso para el Bloque de Funciones:</p> <ul> <li>PUBLIC: <ul> <li>No hay restricciones, se puede llamar desde cualquier lugar. </li> <li>Si no ponemos nada al declarar el FB es lo mismo que PUBLIC.</li> <li>Cualquiera puede llamar o crear una instancia del FB.</li> <li>Se puede usar para la herencia al ser public. </li> <li>Son accesibles luego de instanciar la clase.</li> <li>Corresponde a la especificaci\u00f3n de modificador sin restricci\u00f3n de acceso.</li> </ul> </li> <li>INTERNAL: <ul> <li>Solo se puede acceder al FB desde el mismo espacio de nombres. </li> <li>Esto permite que el FB este disponible solo dentro de una determinada biblioteca. La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC .</li> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).</li> </ul> </li> </ul> <p>Podemos tener otros 2 modificadores de acceso para el Bloque de Funciones: - FINAL:     - (en TwinCAT 3 no sale por defecto para seleccionarlo al crear un FB, pero se puede a\u00f1adir mas tarde despues de crearlo...)      - El FB no puede servir como un bloque de funciones principal.      - Los m\u00e9todos y las propiedades de esta POU no se pueden heredar.      - FINAL solo est\u00e1 permitido para POU del tipo FUNCTION_BLOCK.     - No se permite sobrescribir, en un derivado del bloque de funciones.      - Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.   - ABSTRACT:  bloques de funciones abstractas <pre><code>FUNCTION_BLOCK PUBLIC ABSTRACT FB_Foo\n</code></pre>     - Tan pronto como un m\u00e9todo o una propiedad se declaran como abstractos , el bloque de funciones tambi\u00e9n debe declararse como abstracto .     - No se pueden crear instancias a partir de FB abstractos. Los FB abstractos solo se pueden usar como FB b\u00e1sicos cuando se heredan.     - Todos los m\u00e9todos abstractos y todas las propiedades abstractas deben sobrescribirse para crear un FB no abstracto. Un m\u00e9todo abstracto o una propiedad abstracta se convierte en un m\u00e9todo no abstracto o una propiedad no abstracta al sobrescribir.     - Los bloques de funciones abstractas pueden contener adem\u00e1s m\u00e9todos no abstractos y/o propiedades no abstractas.     - Si no se sobrescriben todos los m\u00e9todos abstractos o todas las propiedades abstractas durante la herencia, el FB heredado solo puede ser un FB abstracto (concretizaci\u00f3n paso a paso).     - Se permiten punteros o referencias de tipo FB abstracto. Sin embargo, estos pueden referirse a FB no abstractos y, por lo tanto, llamar a sus m\u00e9todos o propiedades (polimorfismo).</p>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/#link-al-video-de-youtube-004","title":"Link al Video de Youtube 004:","text":"<ul> <li>\ud83d\udd17 004 - OOP IEC 61131-3 PLC -- Clase y Objeto </li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block/","title":"Bloques de Funciones","text":""},{"location":"Clases%20y%20Objetos/Function%20Block/#declaracion-de-un-function-block","title":"Declaracion de un Function Block:","text":"<pre><code>FUNCTION_BLOCK &lt;access specifier&gt; &lt;function block&gt; | EXTENDS &lt;function block&gt; | IMPLEMENTS &lt;comma-separated list of interfaces&gt;\n</code></pre>"},{"location":"Clases%20y%20Objetos/Function%20Block/#implementacion-bloque-de-funciones","title":"Implementaci\u00f3n Bloque de Funciones:","text":"<p> EXTENDS:  - Si en la declaraci\u00f3n de un FUNCTION_BLOCK a\u00f1adimos la palabra EXTENDS seguida del nombre del FB del cual queremos heredar, significa que heredamos todos sus metodos y propiedades.(principio de Herencia) - Un FB solo puede heredar de una Clase FB.</p> <p> IMPLEMENTS:  - Si en la declaraci\u00f3n de un FUNCTION_BLOCK a\u00f1adimos la palabra IMPLEMENTS seguido del nombre de la interfaz o interfaces separadas por comas. - Si en el FB se implementa una interfaz es obligatorio en el FB crear la programaci\u00f3n de los metodos y propiedades de la interfaz implementada.</p> <ul> <li>Ejemplos de declaraci\u00f3n de FUNCTION_BLOCK:</li> </ul> <pre><code>FUNCTION_BLOCK INTERNAL ABSTRACT FB\nFUNCTION_BLOCK INTERNAL FINAL FB\nFUNCTION_BLOCK PUBLIC FINAL FB\nFUNCTION_BLOCK ABSTRACT FB\nFUNCTION_BLOCK PUBLIC ABSTRACT FB\nFUNCTION_BLOCK FB EXTENDS FB1 IMPLEMENTS Interface1, Interface2, Interface3\n</code></pre>"},{"location":"Clases%20y%20Objetos/Function%20Block/#link-al-video-de-youtube-003","title":"Link al Video de Youtube 003:","text":"<ul> <li>\ud83d\udd17 003 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block/#link-al-video-de-youtube-004","title":"Link al Video de Youtube 004:","text":"<ul> <li>\ud83d\udd17 004 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/","title":"Interfaz fluida","text":""},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#interfaz-fluida","title":"Interfaz Fluida:","text":"<p>Un dise\u00f1o de programaci\u00f3n popular en lenguajes de alto nivel como C# es el llamado 'c\u00f3digo fluido' o 'interfaz fluida'.  Descrito en 2005 por Martin Fowler. Pero, \u00bfqu\u00e9 es una interfaz fluida y c\u00f3mo implementarla en texto estructurado? nos centraremos en una implementaci\u00f3n de una interfaz fluida en texto estructurado.</p>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#que-es-una-interfaz-fluida","title":"\u00bfQu\u00e9 es una interfaz fluida?","text":"<p>Seg\u00fan wikipedia:</p> <p>En ingenier\u00eda de software, una interfaz fluida es una API orientada a objetos cuyo dise\u00f1o se basa en gran medida en el encadenamiento de m\u00e9todos. Su objetivo es aumentar la legibilidad del c\u00f3digo mediante la creaci\u00f3n de un lenguaje espec\u00edfico de dominio (DSL). El t\u00e9rmino fue acu\u00f1ado en 2005 por Eric Evans y Martin Fowler.</p> <p>Un buen ejemplo de este 'encadenamiento de m\u00e9todos' se puede ver con las declaraciones LINQ de C#:</p> <p><pre><code>EmployeeNames = EmployeeList.Where(x=\u203a x.Age \u203a 65) .Select(x=\u203a x) .Where(x=\u203a x.YearsOfEmployment \u203a 20) .Select(x=\u203a x.FullName); </code></pre> Al encadenar continuamente los m\u00e9todos, podemos construir nuestra declaraci\u00f3n completa. \u00a1Es bueno saber que una interfaz fluida se usa a menudo junto con un patr\u00f3n de construcci\u00f3n!. Podemos pensar en la interfaz fluida como un concepto, mientras que el encadenamiento de m\u00e9todos es una implementaci\u00f3n. El objetivo del dise\u00f1o fluido de la interfaz es poder aplicar m\u00faltiples propiedades a un objeto conectando los m\u00e9todos con puntos (.) en lugar de tener que aplicar cada m\u00e9todo individualmente.</p>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#por-que-queremos-esto-en-texto-estructurado","title":"\u00bfPor qu\u00e9 queremos esto en texto estructurado?","text":"<ul> <li>por legilibilidad, mas legible</li> <li>mas simple.</li> <li>por mantenimiento</li> <li>por claridad</li> <li>por facilidad de escribir</li> <li>f\u00e1cil de extender..</li> </ul>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#como-construimos-una-interfaz-fluida","title":"\u00bfC\u00f3mo construimos una interfaz fluida?","text":"<p>Al hacer que el c\u00f3digo sea comprensible y fluido, la interfaz fluida le da la impresi\u00f3n de que est\u00e1 leyendo una oraci\u00f3n. Para lograr este patr\u00f3n de dise\u00f1o, necesitar\u00eda usar el encadenamiento de m\u00e9todos.</p> <p>En esta t\u00e9cnica, cada m\u00e9todo devuelve un objeto y puede encadenar todos los m\u00e9todos.</p> <ul> <li>veanse los links a los que se hace referencia, veremos un ejemplo en el cual implementaremos una interface fluida para realizar operaciones matematicas...</li> </ul> <p></p>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#links-interface-fluida","title":"Links Interface Fluida:","text":"<ul> <li> <p>\ud83d\udd17 fluent-code, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 fluent-interface-and-method-chaining-in-twincat-3</p> </li> <li> <p>\ud83d\udd17 tc3-data-logger creado con interface fluida, github.com/benhar-dev</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#link-al-video-de-youtube-014","title":"Link al Video de Youtube 014:","text":"<ul> <li>\ud83d\udd17 014 - OOP IEC 61131-3 PLC -- Interface Fluida</li> </ul>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/","title":"Palabra clave Abstracto","text":""},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#palabra-clave-abstracto","title":"Palabra Clave Abstracto:","text":""},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#concepto-abstracto","title":"Concepto ABSTRACTO:","text":"<p>La palabra clave ABSTRACT est\u00e1 disponible para bloques de funciones, m\u00e9todos y propiedades. Permite la implementaci\u00f3n de un proyecto PLC con niveles de abstracci\u00f3n. La abstracci\u00f3n es un concepto clave de la programaci\u00f3n orientada a objetos. Los diferentes niveles de abstracci\u00f3n contienen aspectos de implementaci\u00f3n generales o espec\u00edficos.</p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#disponibilidad-abstracto","title":"Disponibilidad ABSTRACTO:","text":"<p>Ya estaba disponible en CODESYS, pero con el lanzamiento de TwinCAT 4024 ahora tambi\u00e9n est\u00e1 disponible en TwinCAT: la palabra clave ABSTRACT. (Disponible en TC3.1 Build 4024).</p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#aplicacion-de-la-abstraccion","title":"Aplicaci\u00f3n de la abstracci\u00f3n:","text":"<p>Es \u00fatil implementar funciones b\u00e1sicas o puntos en com\u00fan de diferentes clases en una clase b\u00e1sica abstracta. Se implementan aspectos espec\u00edficos en subclases no abstractas. El principio es similar al uso de una interfaz. Las interfaces corresponden a clases puramente abstractas que contienen s\u00f3lo m\u00e9todos y propiedades abstractas. Una clase abstracta tambi\u00e9n puede contener m\u00e9todos y propiedades no abstractos.</p> <p>La abstracci\u00f3n y el uso de la palabra clave abstract es una pr\u00e1ctica com\u00fan en OOP y muchos lenguajes de nivel superior como C# lo admiten. A menudo se considera como el cuarto pilar de la programaci\u00f3n orientada a objetos. </p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#por-que-necesitamos-la-abstraccion","title":"\u00bfPor qu\u00e9 necesitamos la abstracci\u00f3n?","text":"<p>Para comprender por qu\u00e9 la abstracci\u00f3n es tan importante en la programaci\u00f3n orientada a objetos, volvamos r\u00e1pidamente a la definici\u00f3n de abstracci\u00f3n. La abstracci\u00f3n consiste en ocultar al usuario detalles de implementaci\u00f3n innecesarios y centrarse en la funcionalidad.</p> <p>Considere un bloque de funciones que implementa una funcionalidad b\u00e1sica de celda de carga. Para usar esto, todo lo que necesitamos saber es que necesita una se\u00f1al de entrada sin procesar y un factor de escala, y nos proporcionar\u00e1 un valor de salida en Newton. No necesitamos saber c\u00f3mo se convierte, filtra y escala el valor de salida. Deja que alguien m\u00e1s se preocupe por eso. No es de influencia en nuestro programa. Solo trabajaremos con una interfaz simple de una celda de carga.</p> <p>Es bueno saber que el uso de abstracciones est\u00e1 estrechamente relacionado con el principio de inversi\u00f3n de dependencia,  uno de los principios SOLID . Esto se vuelve especialmente importante cuando comienzas a trabajar con pruebas unitarias.</p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#reglas-para-el-uso-de-la-palabra-clave-abstract","title":"Reglas para el uso de la palabra clave ABSTRACT:","text":"<ul> <li>Los bloques de funciones abstractas no se pueden instanciar.</li> <li>Los bloques de funciones abstractas pueden contener m\u00e9todos y propiedades abstractos y no abstractos.</li> <li>Los m\u00e9todos abstractos o las propiedades no contienen ninguna implementaci\u00f3n (solo la declaraci\u00f3n).</li> <li>Si un bloque de funciones contiene un m\u00e9todo o propiedad abstracta, debe ser abstracta.</li> <li>Los bloques de funciones abstractas deben extenderse para poder implementar los m\u00e9todos o propiedades abstractas. Por lo tanto: Un FB derivado debe implementar los m\u00e9todos / propiedades de su FB b\u00e1sico o tambi\u00e9n debe definirse como abstracto. Muestra Clase b\u00e1sica abstracta: <pre><code>FUNCTION_BLOCK ABSTRACT FB_System_Base\n</code></pre> Los puntos en com\u00fan de todos los m\u00f3dulos del sistema se implementan en esta clase b\u00e1sica abstracta. Contiene la propiedad no abstracta \"nSystemID\" y el m\u00e9todo abstracto \"Execute\" para esto: <pre><code>PROPERTY nSystemID : UINT\n</code></pre> <pre><code>METHOD ABSTRACT Execute\n</code></pre> mientras que la implementaci\u00f3n de \"nSystemID\" es la misma para todos los sistemas, la implementaci\u00f3n del m\u00e9todo \"Execute\" difiere para los sistemas individuales.</li> </ul> <p>Subclase no abstracta: <pre><code>FUNCTION_BLOCK FB_StackSystem EXTENDS FB_System_Base\n</code></pre> Las clases no abstractas que se derivan de la clase b\u00e1sica se implementan para los sistemas espec\u00edficos. Esta subclase representa una pila. Dado que no es abstracto, debe implementar el m\u00e9todo \"Execute\" que define la ejecuci\u00f3n espec\u00edfica de la pila: <pre><code>METHOD Execute\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#ejemplo-de-demostracion-de-la-palabra-clave-abstract-en-twincat","title":"Ejemplo de Demostracion de la palabra clave ABSTRACT en TwinCAT:","text":"<ul> <li>\ud83d\udd17 The ABSTRACT keyword, www.plccoder.com </li> </ul>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#links-de-abstract","title":"Links de ABSTRACT:","text":"<ul> <li>\ud83d\udd17 ABSTRACT concept, infosys.beckhoff.com</li> <li>\ud83d\udd17 The ABSTRACT keyword, www.plccoder.com </li> </ul>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#link-al-video-de-youtube-012","title":"Link al Video de Youtube 012:","text":"<ul> <li>\ud83d\udd17 012 - OOP IEC 61131-3 PLC -- Abstract</li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/","title":"Metodo Declaracion de variables","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/#tipos-de-variables-que-se-pueden-declarar-en-un-method","title":"Tipos de variables que se pueden declarar en un METHOD:","text":"<ul> <li>\ud83d\udd17 Local Variables - VAR</li> <li>\ud83d\udd17 Input Variables - VAR_INPUT</li> <li>\ud83d\udd17 Output Variables - VAR_OUTPUT</li> <li> <p>\ud83d\udd17 Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</p> </li> <li> <p>\ud83d\udd17 Temporary Variable - VAR_TEMP</p> </li> <li>\ud83d\udd17 Static Variables - VAR_STAT</li> <li>\ud83d\udd17 External Variables - VAR_EXTERNAL</li> <li>\ud83d\udd17 Instance Variables - VAR_INST</li> <li>\ud83d\udd17 Remanent Variables - PERSISTENT, RETAIN</li> <li>\ud83d\udd17 SUPER</li> <li>\ud83d\udd17 THIS</li> <li> <p>\ud83d\udd17 Variable types - attribute keywords</p> <ul> <li>RETAIN: for remanent variables of type RETAIN</li> <li>PERSISTENT: for remanent variables of type PERSISTENT</li> <li>CONSTANT: for constants</li> </ul> </li> <li> <p>Ejemplo de declaraci\u00f3n de variables en un METHOD: <pre><code>METHOD metodo0_Declaracion_variables\nVAR_INPUT\nbinput : BOOL;\nEND_VAR\nVAR_INPUT\nbinput2 : BOOL;\nEND_VAR\nVAR_OUTPUT\noutput1 : REAL;\nEND_VAR\nVAR_IN_OUT\nin_out1 : LINT;\nEND_VAR\nVAR_IN_OUT CONSTANT\nin_out_constant1 : DINT;\nEND_VAR\nVAR\nvar1 : STRING;\nEND_VAR\n//!!! no se pueden declarar variables TEMPORALES dentro de la zona de declaraci\u00f3n de variables del m\u00e9todo!!!\n//VAR_TEMP\n//  temp1 : ULINT;\n//END_VAR\nVAR_INST\ncounter : INT;\nEND_VAR\nVAR_STAT\nnVarStat1 : INT;\naarray  : ARRAY[1..n] OF INT;\nEND_VAR\nVAR_EXTERNAL\nnVarExt1 : INT; // 1st external variable\nEND_VAR\n//!!! no se pueden declarar variables PERSISTENT ni RETAIN dentro de la zona de declaraci\u00f3n de variables del m\u00e9todo!!!\n//VAR PERSISTENT\n//    nVarPers1 : DINT; (* 1. Persistent variable *)\n//    bVarPers2 : BOOL; (* 2. Persistent variable *)\n//END_VAR\n//VAR RETAIN\n//    nRem1 : INT;\n//END_VAR\nVAR CONSTANT\nn : INT:= 10;\nEND_VAR\n</code></pre></p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/#link-al-video-de-youtube-005","title":"Link al Video de Youtube 005:","text":"<ul> <li>\ud83d\udd17 005 - OOP IEC 61131-3 PLC -- Objeto Metodo </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/","title":"Metodo Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/#especificadores-de-acceso-para-los-metodos","title":"Especificadores de acceso para los Metodos:","text":"<p>La declaraci\u00f3n del m\u00e9todo puede incluir un especificador de acceso opcional. Esto restringe el acceso al m\u00e9todo.</p>"},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/#tipos-de-modificadores-de-acceso-para-el-metodo","title":"Tipos de modificadores de acceso para el M\u00e9todo:","text":"<ul> <li>PUBLIC: <ul> <li>Cualquiera puede llamar al m\u00e9todo, no hay restricciones.</li> </ul> </li> <li>PRIVATE: <ul> <li>El m\u00e9todo est\u00e1 disponible solo dentro de la POU. No se puede llamar desde fuera de la POU.</li> <li>Son accesibles dentro de la clase.</li> <li>El acceso est\u00e1 restringido al bloque de funciones o al programa, respectivamente.</li> </ul> </li> <li>PROTECTED: <ul> <li>Solo su propia POU o las POU derivadas (herencia) de ella pueden acceder al m\u00e9todo. La derivaci\u00f3n se analiza a continuaci\u00f3n.</li> <li>Son accesibles a trav\u00e9s de la herencia.</li> <li>El acceso est\u00e1 restringido al programa o al bloque de funci\u00f3n y sus derivados respectivamente.</li> </ul> </li> <li>INTERNAL: <ul> <li>Solo se puede acceder al m\u00e9todo desde el mismo espacio de nombres. Esto permite que los m\u00e9todos est\u00e9n disponibles solo dentro de una determinada biblioteca, por ejemplo.</li> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).</li> </ul> </li> </ul> <p>La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC .    </p> <ul> <li>FINAL:(se puede a\u00f1adir acompa\u00f1ado con alguno de los anteriores) <ul> <li>El m\u00e9todo no puede ser sobrescrito por otro m\u00e9todo. La sobrescritura de m\u00e9todos se describe a continuaci\u00f3n.</li> <li>No se permite sobrescribir, en un derivado del bloque de funciones. </li> <li>Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.</li> </ul> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/#link-al-video-de-youtube-005","title":"Link al Video de Youtube 005:","text":"<ul> <li>\ud83d\udd17 005 - OOP IEC 61131-3 PLC -- Objeto Metodo</li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/","title":"Metodo tipos de variables de retorno","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#tipos-de-variables-de-retorno","title":"Tipos de variables de retorno:","text":"<ul> <li>No es obligatorio en el metodo retornar un tipo de variable.<ul> <li>Ejemplos de declaraci\u00f3n de M\u00e9todos que nos devuelve una variable de diferentes tipos:     <pre><code>METHOD Method1 : BOOL\nMETHOD Method1 : INT\nMETHOD Method1 : REAL\nMETHOD Method1 : STRING\n</code></pre></li> </ul> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-struct","title":"Retorno por STRUCT:","text":"<p>Acceso a un \u00fanico elemento de un tipo de retorno estructurado durante la llamada a m\u00e9todo/funci\u00f3n/propiedad.</p> <p>La siguiente implementaci\u00f3n se puede utilizar para tener acceso directamente a un elemento individual del tipo de datos estructurado que devuelve el m\u00e9todo/funci\u00f3n/propiedad cuando se llama a un m\u00e9todo, funci\u00f3n o propiedad. </p> <p>Un tipo de datos estructurado es, por ejemplo, una estructura o un bloque de funciones.</p> <p>El tipo devuelto del m\u00e9todo/funci\u00f3n/propiedad se define como: <pre><code>REFERENCE TO &lt;structured type&gt;\n//en lugar de simplemente  \n&lt;structured type&gt;\n</code></pre> Tenga en cuenta que con este tipo de retorno, si, por ejemplo, se va a devolver una instancia local FB del tipo de datos estructurados, se debe usar el operador de referencia REF= en lugar del operador de asignaci\u00f3n \"normal\" :=.</p> <p>Las declaraciones y el ejemplo de esta secci\u00f3n se refieren a la llamada de una propiedad. Sin embargo, son igualmente transferibles a otras llamadas que ofrecen valores devueltos (por ejemplo, m\u00e9todos o funciones).</p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#ejemplo","title":"Ejemplo:","text":"<p>Declaraci\u00f3n de la estructura ST_Sample (STRUCTURE): <pre><code>TYPE ST_Sample :\nSTRUCT\nbVar  : BOOL;\nnVar  : INT;\nEND_STRUCT\nEND_TYPE\n</code></pre> Declaraci\u00f3n del bloque de funciones FB_Sample: <pre><code>FUNCTION_BLOCK FB_Sample\nVAR\nstLocal     : ST_Sample;\nEND_VAR\n</code></pre> Declaraci\u00f3n de la propiedad FB_Sample.MyProp con el tipo de devoluci\u00f3n \"REFERENCE TO ST_Sample\": <pre><code>PROPERTY MyProp : REFERENCE TO ST_Sample\n</code></pre> Implementaci\u00f3n del m\u00e9todo Get de la propiedad FB_Sample.MyProp: <pre><code>MyProp REF= stLocal;\n</code></pre> Implementaci\u00f3n del m\u00e9todo Set de la propiedad FB_Sample.MyProp: <pre><code>stLocal := MyProp;\n</code></pre> Llamando a los m\u00e9todos Get y Set en el programa principal MAIN: <pre><code>PROGRAM MAIN\nVAR\nfbSample    : FB_Sample;\nnSingleGet  : INT;\nstGet       : ST_Sample;    bSet        : BOOL;\nstSet       : ST_Sample;\nEND_VAR\n// Get - single member and complete structure possible\nnSingleGet := fbSample.MyProp.nVar;\nstGet      := fbSample.MyProp;\n\n// Set - only complete structure possible \nIF bSet THEN\nfbSample.MyProp REF= stSet;\nbSet            := FALSE;\nEND_IF\n</code></pre></p> <p>Mediante la declaraci\u00f3n del tipo devuelto de la propiedad MyProp como \"REFERENCE TO ST_Sample\" y mediante el uso del operador de referencia REF= en el m\u00e9todo Get de esta propiedad, se puede acceder a un \u00fanico elemento del tipo de datos estructurados devuelto directamente al llamar a la propiedad. <pre><code>VAR\nfbSample    : FB_Sample;\nnSingleGet  : INT;\nEND_VAR\nnSingleGet := fbSample.MyProp.nVar;\n</code></pre> Si el tipo de retorno solo se declarara como \"ST_Sample\", la estructura devuelta por la propiedad tendr\u00eda que asignarse primero a una instancia de estructura local. Los elementos de estructura individuales podr\u00edan consultarse sobre la base de la instancia de estructura local. <pre><code>VAR\nfbSample    : FB_Sample; stGet       : ST_Sample; nSingleGet  : INT;\nEND_VAR\nstGet      := fbSample.MyProp;\nnSingleGet := stGet.nVar;\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-interface","title":"Retorno por INTERFACE:","text":"<p>Ejemplo de declaraci\u00f3n de un m\u00e9todo que nos devuelve una variable del tipo INTERFACE. <pre><code>METHOD Method1 : interface1\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-function_block","title":"Retorno por FUNCTION_BLOCK:","text":"<p>Ejemplo de declaraci\u00f3n de un m\u00e9todo que nos devuelve una variable del tipo FUNCTION_BLOCK. <pre><code>METHOD Method1 : FB1\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#link-al-video-de-youtube-005","title":"Link al Video de Youtube 005:","text":"<ul> <li>\ud83d\udd17 005 - OOP IEC 61131-3 PLC -- Objeto Metodo</li> </ul>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/","title":"SUPER puntero","text":""},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#super-puntero","title":"SUPER^ puntero:","text":"<p>En la programaci\u00f3n orientada a objetos (OOP) en PLCs, el puntero SUPER^ se utiliza para referirse al objeto o instancia de una clase superior o padre. Supongamos que tienes una clase llamada \"Sensor\" y otra clase llamada \"Sensor_de_Temperatura\", que hereda de la primera. La clase \"Sensor\" es la clase padre o superior y la clase \"Sensor_de_Temperatura\" es la clase hija o inferior. Si est\u00e1s programando en la clase \"Sensor_de_Temperatura\" y necesitas acceder a un m\u00e9todo o propiedad de la clase \"Sensor\", puedes utilizar el puntero SUPER^ para referirte a la instancia de la clase \"Sensor\" a la que pertenece el objeto actual. Por ejemplo, si quieres acceder al m\u00e9todo \"obtener_valor()\" de la clase \"Sensor\", puedes hacerlo as\u00ed: SUPER^.obtener_valor(). Esto indica que quieres llamar al m\u00e9todo \"obtener_valor()\" de la instancia de la clase \"Sensor\" a la que pertenece el objeto actual.</p> <p>cada bloque de funciones que se deriva de otro bloque de funciones tiene acceso a un puntero llamado SUPER^.  Esto se puede usar para acceder a elementos (m\u00e9todos, propiedades, variables locales, etc.) desde el bloque de funciones principal.</p> <p>En lugar de copiar el c\u00f3digo del bloque de funciones principal al nuevo m\u00e9todo, el puntero SUPER^ se puede usar para llamar al m\u00e9todo desde el bloque de funciones  . Esto elimina la necesidad de copiar el c\u00f3digo.</p> <pre><code>SUPER^();                 // Llamada del cuerpo FB de la clase base.\nSUPER^.METH_DoIt();       // Llamada del m\u00e9todo METH_DoIt que se implementa en la clase base.\n</code></pre>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#ejemplo","title":"Ejemplo:","text":"<ul> <li>Usando los punteros SUPER y THIS:</li> </ul> <p>Bloque de Funci\u00f3n -- FB_Base: <pre><code>FUNCTION_BLOCK FB_Base\nVAR_OUTPUT\nnCnt : INT;\nEND_VAR\n</code></pre> Metodo -- FB_Base.METH_DoIt: <pre><code>METHOD METH_DoIt : BOOL\nnCnt := -1;\n</code></pre> Metodo -- FB_Base.METH_DoAlso: <pre><code>METHOD METH_DoAlso : BOOL\nMETH_DoAlso := TRUE;\n</code></pre> Bloque de Funci\u00f3n -- FB_1: <pre><code>FUNCTION_BLOCK FB_1 EXTENDS FB_Base\nVAR_OUTPUT\nnBase: INT;\nEND_VAR\nTHIS^.METH_DoIt();      // llamada al metodo METH_DoIt del FB_1.\nTHIS^.METH_DoAlso();\n\nSUPER^.METH_DoIt();     // llamada al metodo METH_DoIt del FB_Base.\nSUPER^.METH_DoAlso();\nnBase := SUPER^.nCnt;\n</code></pre> Metodo -- FB_1.METH_DoIt: <pre><code>METHOD METH_DoIt : BOOL\nnCnt := 1111;    METH_DoIt := TRUE;\n</code></pre> Metodo -- FB_1.METH_DoAlso: <pre><code>METHOD METH_DoAlso : BOOL\nnCnt := 123;    METH_DoAlso := FALSE;\n</code></pre> Programa MAIN: <pre><code>PROGRAM MAIN\nVAR\nfbMyBase : FB_Base;\nfbMyFB_1 : FB_1;\nnTHIS    : INT;\nnBase    : INT;\nEND_VAR\nfbMyBase();\nnBase := fbmyBase.nCnt;\nfbMyFB_1();\nnTHIS := fbMyFB_1.nCnt;\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#links-super-pointer","title":"Links SUPER^ pointer:","text":"<ul> <li> <p>\ud83d\udd17 SUPER puntero Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, SUPER</p> </li> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#link-al-video-de-youtube-009","title":"Link al Video de Youtube 009:","text":"<ul> <li>\ud83d\udd17 009 - OOP IEC 61131-3 PLC -- Punteros THIS^ y SUPER^</li> </ul>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/","title":"THIS puntero","text":""},{"location":"Clases%20y%20Objetos/THIS%20pointer/#this-puntero","title":"THIS^ puntero:","text":"<p>El puntero THIS^ se utiliza para referenciar la instancia actual de una clase en un programa orientado a objetos. En otras palabras, cuando se crea un objeto de una clase, el puntero THIS^ se utiliza para acceder a los atributos y m\u00e9todos de ese objeto espec\u00edfico. Por ejemplo, si tenemos una clase llamada \"Motor\" con un atributo \"velocidad\" y un m\u00e9todo \"acelerar\", al crear un objeto de la clase Motor, podemos utilizar el puntero THIS^ para hacer referencia a ese objeto y modificar su velocidad o acelerar.</p> <p>El puntero THIS^ est\u00e1 disponible para todos los bloques de funciones y apunta a la instancia de bloque de funciones actual.  Este puntero es necesario siempre que un m\u00e9todo contenga una variable local que oculte una variable en el bloque de funciones.</p> <p>Una declaraci\u00f3n de asignaci\u00f3n dentro del m\u00e9todo establece el valor de la variable local.  Si queremos que el m\u00e9todo establezca el valor de la variable local en el bloque de funciones, necesitamos usar el puntero THIS^ para acceder a \u00e9l.</p> <p>Al igual que con el puntero SUPER, el puntero THIS tambi\u00e9n debe estar siempre en may\u00fasculas.</p> <pre><code>THIS^.METH_DoIt();\n</code></pre>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/#ejemplos","title":"Ejemplos:","text":"<ul> <li>La variable del bloque de funciones nVarB se establece aunque nVarB est\u00e1 oculta.</li> </ul> <pre><code>FUNCTION_BLOCK FB_A\nVAR_INPUT\nnVarA: INT;\nEND_VAR\n\nnVarA := 1;\n\nFUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR_INPUT\nnVarB : INT := 0;\nEND_VAR\n\nnVarA := 11;\nnVarB := 2;\n\nMETHOD DoIt : BOOL\nVAR_INPUT\nEND_VAR\nVAR\nnVarB : INT;\nEND_VAR\n\nnVarB := 22; // Se establece la variable local nVarB.\nTHIS^.nVarB := 222; // La variable del bloque de funciones nVarB se establece aunque nVarB est\u00e1 oculta.\n\nPROGRAM MAIN\nVAR\nfbMyfbB : FB_B;\nEND_VAR\n\nfbMyfbB(nVarA:=0, nVarB:= 0);\nfbMyfbB.DoIt();\n</code></pre> <ul> <li>Una llamada de funci\u00f3n necesita la referencia a la propia instancia de FB.</li> </ul> <pre><code>FUNCTION F_FunA : INT\nVAR_INPUT\nfbMyFbA : FB_A;\nEND_VAR\n...;\n\nFUNCTION_BLOCK FB_A\nVAR_INPUT\nnVarA: INT;\nEND_VAR\n...;\n\nFUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR_INPUT\nnVarB: INT := 0;\nEND_VAR\n\nnVarA := 11;\nnVarB := 2;\n\nMETHOD DoIt : BOOL\nVAR_INPUT\nEND_VAR\nVAR\nnVarB: INT;\nEND_VAR\n\nnVarB := 22;  //Se establece la variable local nVarB.\nF_FunA(fbMyFbA := THIS^);  //F_FunA es llamado via THIS^.\n\nPROGRAM MAIN\nVAR\nfbMyFbB: FB_B;\nEND_VAR\n\nfbMyFbB(nVarA:=0 , nVarB:= 0);\nfbMyFbB.DoIt();\n</code></pre>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/#links-this-pointer","title":"Links THIS^ pointer:","text":"<ul> <li> <p>\ud83d\udd17 THIS puntero Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, THIS</p> </li> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/#link-al-video-de-youtube-009","title":"Link al Video de Youtube 009:","text":"<ul> <li>\ud83d\udd17 009 - OOP IEC 61131-3 PLC -- Punteros THIS^ y SUPER^</li> </ul>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/","title":"Clases y Objetos","text":""},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#clases-y-objetos","title":"Clases y Objetos:","text":"<ul> <li>Una Clase es una plantilla.</li> <li>Un Objeto es la instancia de una Clase.</li> </ul> <pre><code>En este Ejemplo Nos encontramos la Clase Coche,\ny hemos instanciado esta Clase para tener los Objetos de Coches \nMercedes, Bmw y Audi...\n</code></pre>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#representacion-de-la-clase-coche-en-stl-oop-iec-61131-3","title":"Representacion de la Clase Coche en STL OOP IEC 61131-3","text":"<p><pre><code>FUNCTION_BLOCK Coche\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n    _Marca : STRING;\n    _Color : STRING;\n    accion : STRING;\nEND_VAR\n----------------------------------------------------------------\nMETHOD PUBLIC Acelerar\naccion := 'acelerar';\n----------------------------------------------------------------\nMETHOD PUBLIC Conducir\naccion := 'conducir';\n----------------------------------------------------------------\nMETHOD PUBLIC Frenar\naccion := 'frenar';\n----------------------------------------------------------------\nPROPERTY PUBLIC Color : STRING\nGet\n    Color := _Color;\nSet\n    _Color := Color;\n----------------------------------------------------------------\nPROPERTY PUBLIC Marca : STRING\nGet\n    Marca := _Marca;\nSet\n    _Marca := Marca;\n</code></pre> Instancia de la clase en los Objetos: Mercedes,Bmw y Audi y llamadas a sus metodos y propiedades... <pre><code>PROGRAM _01_Clase_y_Objetos\nVAR\n    // tenemos la Clase Coche y la instanciamos y obtenemos los Objetos: Mercedes, Bmw y Audi.\n    Mercedes : Coche;\n    Bmw : Coche;\n    Audi: Coche;\n\n    Color : STRING;\n    Marca : STRING;\n\n    Acelerar : BOOL;\n    Conducir:  BOOL;\n    Frenar  : BOOL; \nEND_VAR\n\n//Objeto Mercedes\n//llamadas a sus m\u00e9todos.\nIF Acelerar THEN\n    Mercedes.Acelerar();\n    Acelerar := FALSE;\nEND_IF\n\nIF Conducir THEN\n    Mercedes.Conducir();\n    Conducir := FALSE;\nEND_IF\n\nIF Frenar THEN\n    Mercedes.Frenar();\n    Frenar := FALSE;\nEND_IF\n\n//llamadas a sus propiedades.\nMercedes.Marca := 'Mercedes';\nMercedes.Color := 'Negro';\nColor := Mercedes.Color;\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 methods-properties-and-inheritance (stefanhenneken)</li> </ul>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#link-al-video-de-youtube-002","title":"Link al Video de Youtube 002:","text":"<ul> <li>\ud83d\udd17 002 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/interface/","title":"Interface","text":""},{"location":"Clases%20y%20Objetos/interface/#interface","title":"Interface:","text":"<p>En la programaci\u00f3n orientada a objetos (OOP) en PLCs, una interfaz es un tipo de estructura que define un conjunto de m\u00e9todos y propiedades que una clase debe implementar. En otras palabras, una interfaz define un contrato entre diferentes partes del c\u00f3digo para asegurar que se cumplan ciertos requisitos y se mantenga una estructura coherente. En t\u00e9rminos pr\u00e1cticos, esto significa que cuando se crea una clase que implementa una interfaz, esa clase debe proporcionar los m\u00e9todos y propiedades definidos en la interfaz. Esto permite que diferentes clases compartan un conjunto com\u00fan de m\u00e9todos y propiedades y se comuniquen entre s\u00ed de manera coherente. Por ejemplo, si tienes una interfaz \"I_Sensor\" con los m\u00e9todos: \"LeerValor\",\"Calibrar\" y \"Descalibrar\" y las Propiedades: \"Temperatura\", \"Consigna\" y \"Calibrado\" cualquier clase que implemente esa interfaz debe proporcionar esos tres m\u00e9todos y las tres propiedades. Esto asegura que cualquier otra parte del c\u00f3digo que trabaje con esa clase pueda confiar en que esos m\u00e9todos y propiedades estar\u00e1n disponibles.</p> <p></p> <ul> <li>Una interfaz es una clase que contiene m\u00e9todos y propiedades sin implementaci\u00f3n. </li> <li>La interfaz se puede implementar en cualquier clase, pero esa clase debe implementar todos sus m\u00e9todos. y propiedades.</li> <li>Si bien la herencia es una relaci\u00f3n \"es un\", las interfaces se pueden describir como \"se comporta como\" o \u201ctiene una\u201d relaci\u00f3n.</li> <li>Las interfaces son objetos que permiten que varias clases diferentes tengan algo en com\u00fan con menos dependencias. Las clases y los bloques de funciones pueden implementar varias interfaces diferentes. Uno puede pensar en los m\u00e9todos y propiedades de la interfaz como acciones que significan cosas diferentes dependiendo de qui\u00e9n los est\u00e9 ejecutando. Por ejemplo, la palabra \"Correr\" significa \"mover a una velocidad m\u00e1s r\u00e1pido que un paseo\u201d para un ser humano, pero significa \u201cejecutar\u201d para las computadoras.</li> <li>Las clases o bloques de funciones que no comparten similitudes pueden implementar la misma interfaz. En este caso, la implementaci\u00f3n de los m\u00e9todos en cada clase puede ser totalmente diferente. Esto abre muchos enfoques de programaci\u00f3n poderosos:</li> <li>Las POU pueden llamar a una interfaz para ejecutar un m\u00e9todo o acceder a una propiedad, sin saber cu\u00e1l clase o FB con el que se trata o c\u00f3mo va a ejecutar la operaci\u00f3n.  La interfaz luego apunta a una clase o bloque de funci\u00f3n que implementa la interfaz y la operaci\u00f3n que es ejecutado.</li> <li>Los programadores pueden crear cajas de interruptores f\u00e1cilmente personalizables usando polimorfismo.</li> </ul>"},{"location":"Clases%20y%20Objetos/interface/#links-interface","title":"Links Interface:","text":"<ul> <li> <p>\ud83d\udd17 Codesys Comando 'Implementar interfaces'</p> </li> <li> <p>\ud83d\udd17 Codesys Objeto Interface</p> </li> <li> <p>\ud83d\udd17 Codesys Implementando Interfaces</p> </li> <li> <p>\ud83d\udd17 Beckhoff Objeto Interface</p> </li> <li> <p>\ud83d\udd17 Beckhoff Implementando Interfaces</p> </li> <li> <p>\ud83d\udd17 Extender Interfaces, Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 TC09.Beckhoff TwinCAT3 Function Block-Part4 Interface.JP</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/interface/#link-al-video-de-youtube-010","title":"Link al Video de Youtube 010:","text":"<ul> <li>\ud83d\udd17 010 - OOP IEC 61131-3 PLC -- Interface</li> </ul>"},{"location":"Clases%20y%20Objetos/metodo/","title":"Metodo","text":""},{"location":"Clases%20y%20Objetos/metodo/#method","title":"METHOD:","text":"<p>Los M\u00e9todos dividen la clase (bloque de funciones) en funciones m\u00e1s peque\u00f1as que se pueden ejecutar en llamada. Solo trabajar\u00e1n con los datos que necesitan e ignorar\u00e1n cualquier dato redundante que puede existir en un determinado bloque de funciones.</p> <p>Los m\u00e9todos pueden acceder y manipular las variables internas de la clase principal, pero tambi\u00e9n pueden usar variables propias a las que la clase principal no puede acceder (a menos que sean de salida la variable).</p> <p>Adem\u00e1s, los m\u00e9todos son una forma mucho m\u00e1s eficiente de ejecutar un programa porque, al dividir una funci\u00f3n en varios m\u00e9todos, el usuario evita ejecutar todo el POU cada vez, ejecutar solo peque\u00f1as porciones de c\u00f3digo siempre que sea necesario llamarlas. </p> <p>Esto es un muy buena manera de evitar errores y corrupci\u00f3n de datos. Los m\u00e9todos tambi\u00e9n tienen un nombre, lo que significa que estas porciones de c\u00f3digo se pueden identificar por su prop\u00f3sito en lugar de las variables que manipulan, mejorando as\u00ed la lectura de c\u00f3digo, comprensi\u00f3n y la soluci\u00f3n de problemas.</p> <p>La abstracci\u00f3n juega un papel importante aqu\u00ed, si los programadores desean implementar el c\u00f3digo,  solo necesitan llamar al m\u00e9todo.</p> <p>La soluci\u00f3n de problemas tambi\u00e9n se convierte en m\u00e1s simple: entonces el programador no necesita buscar cada instancia del c\u00f3digo, solo necesitan verificar el m\u00e9todo correspondiente. A diferencia de la clase base, los m\u00e9todos usan la memoria temporal del controlador: los datos son vol\u00e1tiles, ya que las variables solo mantendr\u00e1n sus valores mientras se ejecuta el m\u00e9todo. Si se suponen valores que deben mantenerse entre ciclos de ejecuci\u00f3n, entonces la variable debe almacenarse en la clase base o en alg\u00fan otro lugar que retendr\u00e1 los valores de un ciclo al otro (como la  lista de variables globales -- GVL), o tambi\u00e9n se puede utilizar la variable de tipo VAR_INST.</p> <p>Por lo tanto, una declaraci\u00f3n de M\u00e9todo tiene la siguiente estructura: <pre><code>METHOD &lt;Access specifier&gt; &lt;Name&gt; : &lt;Datatype return value&gt;\n</code></pre> No es obligatorio que un M\u00e9todo deba devolver un valor...</p>"},{"location":"Clases%20y%20Objetos/metodo/#ejemplo-de-declaracion-de-method","title":"Ejemplo de declaraci\u00f3n de METHOD:","text":"<pre><code>METHOD Method1 : BOOL\nVAR_INPUT\nnIn1  : INT;\nbIn2  : BOOL;\nEND_VAR\nVAR_OUTPUT\nfOut1 : REAL;\nsOut2 : STRING;\nEND_VAR\n</code></pre>"},{"location":"Clases%20y%20Objetos/metodo/#links-del-objeto-metodo","title":"Links del Objeto Metodo:","text":"<ul> <li> <p>\ud83d\udd17 Documentaci\u00f3n Codesys del Objeto m\u00e9todo</p> </li> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Beckhoff del Objeto m\u00e9todo</p> </li> <li> <p>\ud83d\udd17 TC08.Beckhoff TwinCAT3 Function Block-Part3 Method.JP</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/metodo/#link-al-video-de-youtube-005","title":"Link al Video de Youtube 005:","text":"<ul> <li>\ud83d\udd17 005 - OOP IEC 61131-3 PLC -- Objeto Metodo</li> </ul>"},{"location":"Clases%20y%20Objetos/modificadores%20de%20acceso/","title":"Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/modificadores%20de%20acceso/#modificadores-de-acceso","title":"Modificadores de Acceso:","text":"<ul> <li>PUBLIC: <ul> <li>Son accesibles luego de instanciar la clase.</li> <li>Corresponde a la especificaci\u00f3n de modificador sin restricci\u00f3n de acceso.</li> </ul> </li> <li>PRIVATE: <ul> <li>Son accesibles dentro de la clase.</li> <li>El acceso est\u00e1 restringido al bloque de funciones o al programa, respectivamente.</li> </ul> </li> <li>PROTECTED: <ul> <li>Son accesibles a trav\u00e9s de la herencia.</li> <li>El acceso est\u00e1 restringido al programa o al bloque de funci\u00f3n y sus derivados respectivamente.</li> </ul> </li> <li>INTERNAL:<ul> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).  </li> </ul> </li> <li>FINAL:<ul> <li>No se permite sobrescribir, en un derivado del bloque de funciones. </li> <li>Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.</li> </ul> </li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/","title":"puntero y referencia","text":""},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#puntero-y-referencia","title":"Puntero y Referencia:","text":"<p>En la programaci\u00f3n orientada a objetos (OOP) en PLC IEC 61131-3, los punteros y las referencias son dos conceptos importantes que se utilizan para acceder a los datos y m\u00e9todos de un objeto.  Un puntero es una variable que almacena la direcci\u00f3n de memoria de otra variable.  Una referencia es una variable que se utiliza para acceder a otra variable sin tener que conocer su direcci\u00f3n de memoria.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#que-es-un-puntero","title":". \u00bfQu\u00e9 es un puntero?","text":"<ul> <li>Es un dato que apunta o se\u00f1ala hacia una direcci\u00f3n de memoria.</li> <li>Es una variable que contiene la direcci\u00f3n de memoria donde \u201cvive\u201d la variable.</li> <li>Con el empleo de punteros se accede a la memoria de forma directa,por lo que es una buena t\u00e9cnica para reducir el tiempo de ejecuci\u00f3n de un programa y otras muchas m\u00e1s funcionalidades.</li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#tipos-de-punteros","title":". Tipos de Punteros:","text":"<ul> <li>Hay un tipo de puntero para cada tipo de dato, programa, Function Block, funciones, etc. </li> <li>Seg\u00fan sea el \u201cobjeto\u201d al que se desea acceder se necesita un puntero de un tipo u otro.</li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#declaracion-de-punteros","title":". Declaraci\u00f3n de punteros:","text":"<p>El compilador necesita conocer todos los punteros que se vayan a emplear en el proyecto, por lo que hay que declararlos, como cualquier otra variable.  En el c\u00f3digo se muestra el script necesario para la declaraci\u00f3n de varios tipos de punteros:</p> <pre><code>// Un puntero no deja de ser una variable, la diferencia est\u00e1 en que su contenido no es un valor determinado sino que es la direcci\u00f3n \n// de memoria donde se ubica la variable de la que se quiere leer o escribir su valor. Y al igual que hay que declarar todas las\n// variables del tipo correspondiente. tambi\u00e9n hay que declarar todas las variables -punteros- que contendr\u00e1n esas direcciones de \n// memoria y su correspondiente tipo.\nVAR\nstTest1 : stTipo1; //Declara una estructura de datos del tipo stTipo1.\n\npin01 : POINTER TO INT; //Declara un puntero para acceder a variables del tipo INT.\nps20  : POINTER TO STRING[20]; //Declara un puntero para acceder a variables del tipo STRING de 20 caracteres.\npa20 : POINTER TO ARRAY [1..20] OF INT; //Declara un puntero para acceder a variables del tipo ARRAY de 20 elementos del tipo INT.\npDword : POINTER TO DWORD; //Declara un puntero para acceder a variables del tipo DWORD.\npast1  : POINTER TO stTipo1; //Declara un puntero para acceder a variables del tipo stTipo1.\npReal  : POINTER TO REAL; //Declara un puntero para acceder a variables del tipo REAL.\nEND_VAR\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#como-saber-que-direccion-asignar-al-puntero","title":". Como saber qu\u00e9 direcci\u00f3n asignar al puntero:","text":"<ul> <li>Para poder acceder a una variable mediante un puntero se necesita conocer su direcci\u00f3n de memoria,  Para ello se dispone de un operador llamado ADR que asigna la direcci\u00f3n de la variable deseada, al puntero.</li> <li>Es conveniente verificar que el valor del puntero no es cero, antes de utilizarlo. Por otra parte, para poder leer / escribir el valor de la variable, a la que se\u00f1ala el puntero,  se dispone del operador de contenido ^. Cuando se hace referencia al contenido, de la direcci\u00f3n de memoria apuntada, se habla de desreferenciar el puntero. En el siguiente c\u00f3digo se muestra un ejemplo:</li> </ul> <pre><code>PROGRAM SR_Main_02\nVAR\nin01    : INT; //Declaraci\u00f3n de la variable in01 de tipo entero.\nin02    : INT := 123; //Declaraci\u00f3n e inicializaci\u00f3n de la variable in02 de tipo entero.\nin03    : INT; //Declaraci\u00f3n de la variable in03 de tipo entero.\n\npint    : POINTER TO INT; //Declaraci\u00f3n de un puntero para acceder a variables del tipo entero.\nEND_VAR\n\n// Ejemplo de uso b\u00e1sico de los operadores ADR y del operador de contenido ^\n// Se muestra como asignar a un puntero la direcci\u00f3n de memoria de una variable y como leer/escribir\n// as\u00ed como un ejemplo de acceso a variables locales de otros programas.\n\npint := ADR(in01); //Asignamos al puntero la direcci\u00f3n de memoria donde se ubica la variable in01.\npint^ := 44;     //A la posici\u00f3n de memoria indicada por el puntero, le asignamos el valor 44\n//Por tanto a la variable in01 se le ha escrito el valor 44.\n\nin02 := in01; // in02 ser\u00e1 igual a 44.\n\npint := ADR(in02); //Cambiamos la direcci\u00f3n para acceder a la direcci\u00f3n de la variable in02.\nin03 := pint^; // in03 tomara el valor del contenido de la posici\u00f3n de memoria contenida en el\n// que hemos asignado la direcci\u00f3n de in02, por tanto in03= 123.\n\npint := ADR(SR_Main_01.inLocalAway); //Cargamos la direcci\u00f3n de memoria de una variable local de \n// otro programa, la que ser\u00eda inaccesible por otros medios.\npint^ := 240 ; // La varible local del programa SR_Main_01.inLocalAway tomar\u00e1 el valor 240                                                \n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#que-es-un-acceso-indirecto","title":". \u00bfQu\u00e9 es un acceso indirecto?","text":"<p>Lo primero, decir que no tiene nada que ver con un puntero. Un acceso indirecto permite elegir un n\u00famero de elemento dentro de un array, hay una variable, llamada \u00edndice, que contiene el n\u00famero del elemento del array al que se desea acceder. En este caso no se puede acceder a ninguna otra variable m\u00e1s all\u00e1 de los elementos del array, insisto en que no tiene nada que ver con los punteros. Con un puntero se puede acceder a cualquier dato u objeto que est\u00e9 en la memoria del control. Con un acceso indirecto solo se puede acceder a los elementos de un array. En el siguiente c\u00f3digo se muestra unos ejemplos de acceso indirecto a un array:</p> <p><pre><code>PROGRAM SR_Main_01\nVAR\naR20: ARRAY[1..20] OF REAL; //Declara un array de 20 elementos del tipo REAL.\ninIndex: INT; //Declara la variable de indice del array para el acceso indirecto\nxNewVal: BOOL; //Indica que hay una nueva lectura del sensor de fuerza.\nrFuerza: REAL; //Valor de fuerza del sensor.\nEND_VAR\n\n// Ejemplo01: Se asigna valores del 1 al 20 a cada elemento del array mediante un bucle.\nFOR inIndex:=1 TO 20 BY 1 DO  // Se empieza por el valor de la variable indice a 1, hasta 20\naR20[inIndex] := inIndex; // Al elemento aR20[inIndex] se le asigna el valor de inIndex\nEND_FOR;                      // Se incrementa inIndex y se repite el proceso.\n\n// Ejemplo02: Creamos un FIFO en el que guardamos un valor anal\u00f3gico de fuera a cada impulso de la se\u00f1al xNewVal.\nIF xNewVal THEN                // Si hay un nuevo valor de fuerza realizamos el codigo.\nxNewVal := FALSE;          // Reset de la se\u00f1al xNewVal.\n\nFOR inIndex:=20 TO 2 BY -1 DO // Variable indice a 20, hasta 2.\naR20[inIndex] := aR20[inIndex-1]; //Desplazamiento de los valores en el FIFO ---&gt;\nEND_FOR;                             // Se decrementa inIndex y se repite el proceso.\n\naR20[1] := rFuerza; // Entrada del valor de fuerza en el primer elemento del FIFO.\nEND_IF\n</code></pre> A este mismo array se puede acceder empleando un puntero, como se ver\u00e1 m\u00e1s adelante, lo que resulta m\u00e1s r\u00e1pido en tiempo de ejecuci\u00f3n,  pero no tan claro para quien no suele usar los punteros. </p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#acceso-a-una-estructura-de-datos-mediante-punteros","title":". Acceso a una estructura de datos mediante punteros:","text":"<p>El proceso es el mismo que ya se ha visto para acceder a una variable del tipo INT, pero se tendr\u00e1 que declarar un puntero del tipo adecuado, que coincida con el tipo de estructura a la que se desea acceder, ve\u00e1moslo en el siguiente c\u00f3digo:</p> <pre><code>PROGRAM SR_Main_03\nVAR\nstMotor_01 : stMotorCtrl; // Estructura de control del motor 1\nstMotor_02 : stMotorCtrl; // Estructura de control del motor 2\nstMotor_03 : stMotorCtrl; // Estructura de control del motor 3\npstMotorCtrl : POINTER TO stMotorCtrl; // Puntero para acceder a estructuras del tipo stMotorCtrl.\nxMarcha : BOOL; // Pulsador marcha motores.\nEND_VAR\n\n// Ejemplo b\u00e1sico de como acceder a estructuras de datos mediante punteros.\n// La estructura de datos empleada es una llamada a stMotorCtrl, que coincide un bit de marcha, otro de paro y\n// valores de velocidad en Rpms y tiempo de aceleraci\u00f3n/deceleraci\u00f3n.\n\n// Asignamos valores a la estructura para el control del motor 1.\n\nstMotor_01.rTpoAcelDecel := 5.4; // Tiempo para acelerar/decelerar hasta alcanazar la velocidad.\nstMotor_01.rVelRpm := 1436.2; // Velocidad en RPM.\nstMotor_01.xMotorOff := TRUE; // Bit de paro ON.\nstMotor_01.xMotorOn := FALSE   ; // Bit de marcha OFF.\n\npstMotorCtrl := ADR(stMotor_01); // Cargamos la direcci\u00f3n de memoria de la estructura del motor 1\nstMotor_02 := pstMotorCtrl^; // Copia el contenido de la zona de memoria apuntada a la\n// estructura del motor 2, en este caso el resultado es el mismo\n// que se obtendr\u00eda con stMotor_02:= stMotor_01;\n\nstMotor_03 := stMotor_02; // Copia los mismos valores al motor 3;\n\nIF xMarcha THEN         // Si se pulsa marcha m\u00e1quina\npstMotorCtrl^.xMotorOn := TRUE; // Se activa el bit de marcha al que apunta el puntero (stMotor_01).\npstMotorCtrl^.xMotorOff := FALSE; // Se desactiva el bit de paro al que apunta el puntero (stMotor_01)\nEND_IF\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#acceso-a-un-array-mediante-punteros","title":". Acceso a un array mediante punteros:","text":"<p>El proceso es el mismo que ya se ha visto para acceder a una variable del tipo INT, pero se tendr\u00e1 que declarar un puntero a un array del n\u00famero de elementos y tipo de datos adecuados,  ve\u00e1moslo en el siguiente c\u00f3digo:</p> <pre><code>PROGRAM SR_Main_03\nVAR\naintFIFO    : ARRAY[1..20] OF INT; // Array de 20 enteros.\naintFIFO2   : ARRAY[1..20] OF INT; // Array de 20 enteros.\npaint       : POINTER TO ARRAY[1..20] OF INT; // Puntero al array.\npint        : POINTER TO INT; // Puntero a un entero.\nEND_VAR\n\n// Ejemplo basico de como acceder a arrays mediante punteros:\npaint := ADR(aintFIFO); // _Asignamos la direcci\u00f3n del array al puntero.\npaint^[3] := 4; // Dentro del array podemos acceder a un elemento en concreto\naintFIFO2 := paint^; // O copiar el array apuntado entero, sobre otro array\npint := paint + (4 * SIZEOF (INT)); // Tambien se puede crear un puntero a un INT para acceder a uno de los\n// elementos del array. Tomamos la direcci\u00f3n inicial del array y le\n// sumampos un offeset de tantos bytes como se necesitan para el tipo de \n// datos INT y lo multiplicamos por el indice del array al que queremos\n// acceder. SIZEOF (TYPE) retorna el n\u00famero de bytes seg\u00fan el tipo de datos.\n\npint^ := 5;                         // Asignamos el valor de 5, aintFIFO[5]:=5 ser\u00eda lo mismo. \n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#acceso-a-datos-por-referencias","title":". Acceso a datos por referencias:","text":"<p>El acceso por referencia no deja de ser un acceso por puntero, pero en este caso la direcci\u00f3n de una referencia es la misma que la del objeto al que apunta. Un puntero tiene su propia direcci\u00f3n y esta contiene la direcci\u00f3n del objeto al que se quiere hacer referencia.  Las referencias se inicializan al principio del programa y no pueden cambiar durante su ejecuci\u00f3n.  A un puntero se le puede cambiar su direcci\u00f3n tanto como sea necesario durante la ejecuci\u00f3n del programa. Otra forma de entender las referencias es como si fuesen otra manera de referirse a un mismo objeto/variable, como si fuese un alias. Frente a los punteros, las referencias presentan las siguientes ventajas:</p> <ul> <li>1) Facilidad de uso.</li> <li>2) Sintaxis m\u00e1s sencilla a la hora de pasar par\u00e1metros a funciones.</li> <li>3) Minimiza errores en la escritura del c\u00f3digo.</li> </ul> <p>El resumen de todo esto, que se puede prestar a mucha confusi\u00f3n, es que, como se ver\u00e1 m\u00e1s adelante, el gran valor de las referencias es a la hora de pasar grandes  cantidades de datos como par\u00e1metros de entrada a funciones.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#diversas-formas-de-pase-de-parametros-a-funciones","title":". Diversas formas de pase de par\u00e1metros a funciones:","text":"<p>Normalmente una funci\u00f3n realiza unas operaciones con unos par\u00e1metros de entrada y retorna un valor - o varios - como resultado.  En el ejemplo que veremos seguidamente se trata de una funci\u00f3n para calcular el \u00e1rea de un rect\u00e1ngulo, a la que le pasaremos los valores del lado A y el lado B para que nos retorne el resultado del \u00e1rea. </p> <p>Lo primero definiremos un tipo de dato [stRect\u00e1ngulo] que contendr\u00e1 el lado A, el B y el \u00e1rea. </p> <p>Crearemos tres rect\u00e1ngulos, [stRectangulo01], [stRectangulo02] y [stRectangulo03]. </p> <p>Junto con tres variantes de la funci\u00f3n para el c\u00e1lculo del \u00e1rea:</p> <ul> <li>[Fc_AreaCalcVal] - pase por valores - </li> <li>[Fc_AreaCalcPoint] - pase por puntero - </li> <li>[Fc_AreaCalcRef] - pase por referencia \u2013</li> </ul> <p>A continuaci\u00f3n, el c\u00f3digo de las tres funciones:</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#pase-de-valores","title":"Pase de valores:","text":"<pre><code>// Funci\u00f3n para calcular el area de un Rectangulo, pasando los valores de los lados del Rectangulo\n// la funci\u00f3n retorna el resultado del area calculado\n\nFUNCTION Fc_AreaCalcVal : REAL // La funci\u00f3n retona un n\u00famero real\nVAR_INPUT\ni_rASide    : REAL; // Par\u00e1metro de entrada que contiene el lado A del rectangulo.\ni_rBSide    : REAL; // Par\u00e1metro de entrada que contiene el lado B del rectangulo.\nEND_VAR\n\nFc_AreaCalcVal := i_rASide * i_rBSide; // Retorna el resultado de multiplicar el lado A por el lado B.\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#pase-por-puntero","title":"Pase por puntero:","text":"<pre><code>// Funci\u00f3n para calcular el area de un Rectangulo, con los valores contenidos en una estructura de datos del tipo stRectangulo\n// La estructura se pasa mediante un puntero a la estructura stRectangulo deseada y la funci\u00f3n retorna el resultado a la \n// misma estructura.\n\nFUNCTION Fc_AreaCalcPoint : REAL\nVAR_INPUT\ni_ptstRect : POINTER TO st_Rectangulo; // Puntero de entrada con la direcci\u00f3n de la estructura.\nEND_VAR\n\n// El valor del area, de la estructura indicada por la direcci\u00f3n del puntero es igual al\n// valor del lado A de la estructura indicada por la direcci\u00f3n del puntero por\n// el valor del lado B de la estructura indicada por la direcci\u00f3n del puntero\ni_ptstRect^.rArea := i_ptstRect^.rASide * i_ptstRect^.rBSide;\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#pase-por-referencia","title":"Pase por Referencia:","text":"<pre><code>// Funci\u00f3n para calcular el area de un Rectangulo, con los valores contenidos en una estructura de datos del tipo stRectangulo\n// La estructura se pasa por referencia.\n\nFUNCTION Fc_AreaCalcRef : REAL\nVAR_INPUT\ni_Ref : REFERENCE TO st_Rectangulo;\nEND_VAR\n\ni_Ref.rArea := i_Ref.rASide * i_Ref.rBSide;\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#ejemplo-de-codigo-de-llamadas-a-las-funciones","title":"Ejemplo de c\u00f3digo de llamadas a las funciones:","text":"<p><pre><code>PROGRAM SR_Main_01\nVAR\ninLocalAway : INT; // Variable integer local de SR_Main_01 para ser accedida externamente\nstRectangulo1 : st_Rectangulo; // Estructura que contiene los datos del rectangulo1 A, B y su area\nstRectangulo2 : st_Rectangulo; // Estructura que contiene los datos del rectangulo2 A, B y su area\nstRectangulo3 : st_Rectangulo; // Estructura que contiene los datos del rectangulo3 A, B y su area\n\nrefRectangulo : REFERENCE TO st_Rectangulo := stRectangulo3; // Hace Referencia a stRectangulo3   \nEND_VAR\n\n// Asignaci\u00f3n de valores a los lados de los tres rect\u00e1ngulos.\n\n// Asignaci\u00f3n de valores de los lados del rect\u00e1ngulo 1\nstRectangulo1.rAside := 44; //Valor del lado A.\nstRectangulo1.rBside := 32; //Valor del lado B.\n\n// Asignaci\u00f3n de valores de los lados del rect\u00e1ngulo 2\nstRectangulo2.rAside := 12.8; //Valor del lado A.\nstRectangulo2.rBside := 320.4; //Valor del lado B.\n\n// Asignaci\u00f3n de valores de los lados del rect\u00e1ngulo 3\nstRectangulo3.rAside := 1024.2; //Valor del lado A.\nstRectangulo3.rBside := 2048.4; //Valor del lado B.\n\n// C\u00e1lculo del \u00e1rea del rect\u00e1ngulo pasando valores a la funci\u00f3n\nstRectangulo1.rArea := Fc_AreaCalcVal(i_rAside:=stRectangulo1.rAside, i_rBside:= stRectangulo1.rBside);\n\n// C\u00e1lculo del \u00e1rea del rect\u00e1ngulo pasando un puntero a la funci\u00f3n\nFc_AreaCalcPoint(ADR(stRectangulo2));\n\n// C\u00e1lculo del \u00e1rea del rect\u00e1ngulo pasando una referencia a la funci\u00f3n\nFc_AreaCalcRef(refRectangulo);\n</code></pre> En este caso puede que las diferencias pueden parecer insignificantes, puesto que la cantidad de datos que se le pasan a la funci\u00f3n son pocos. Pero seguidamente veremos un ejemplo con mayor n\u00famero de par\u00e1metros de entrada para poder apreciar las ventajas del pase de par\u00e1metros por, especialmente, referencia y tambi\u00e9n por puntero.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#caso-de-pase-de-grandes-cantidades-de-datos-a-funciones","title":".Caso de pase de grandes cantidades de datos a funciones:","text":"<p>Cuando se precisa pasar estructuras con gran cantidad de datos a funciones \u00f3 a FB\u00b4s, el pase de par\u00e1metros por valores no es el m\u00e9todo m\u00e1s adecuado puesto que se requieren gran cantidad de par\u00e1metros de entrada, cada par\u00e1metro implica crear una nueva variable local de la funci\u00f3n, o del FB, lo que supone gasto de memoria y tiempo de ejecuci\u00f3n en copiar los datos. Caso de estructuras de datos de varios Kbytes, o arrays de centenares o miles de elementos, este m\u00e9todo es impensable.  En el caso de tener que pasar grandes cantidades de datos, la soluci\u00f3n es el empleo de punteros, o mejor a\u00fan, el pase de datos por referencia.  Seguidamente se muestra un ejemplo de una funci\u00f3n para calcular el valor promedio de un array de 20 elementos, pasando los valores a la funci\u00f3n y  pasando los valores mediante una referencia.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#codigo-de-la-funcion-fc_averagevalues-para-pase-de-valores","title":"C\u00f3digo de la funci\u00f3n Fc_AverageValues para pase de valores:","text":"<pre><code>// Esta funci\u00f3n calcula la media de un buffer de 20 elementos. Solo a modo de ejemplo comparativo\n// no ser\u00eda una forma muy adecuada de hacerlo as\u00ed\n\nFUNCTION Fc_AverageValues : REAL\nVAR_INPUT\ni_REALV1  : REAL; //Valor posici\u00f3n 1\ni_REALV2  : REAL; //Valor posici\u00f3n 2\ni_REALV3  : REAL; //Valor posici\u00f3n 3\ni_REALV4  : REAL; //Valor posici\u00f3n 4\ni_REALV5  : REAL; //Valor posici\u00f3n 5\ni_REALV6  : REAL; //Valor posici\u00f3n 6\ni_REALV7  : REAL; //Valor posici\u00f3n 7\ni_REALV8  : REAL; //Valor posici\u00f3n 8\ni_REALV9  : REAL; //Valor posici\u00f3n 9\ni_REALV10 : REAL; //Valor posici\u00f3n 10\ni_REALV11 : REAL; //Valor posici\u00f3n 11\ni_REALV12 : REAL; //Valor posici\u00f3n 12\ni_REALV13 : REAL; //Valor posici\u00f3n 13\ni_REALV14 : REAL; //Valor posici\u00f3n 14\ni_REALV15 : REAL; //Valor posici\u00f3n 15\ni_REALV16 : REAL; //Valor posici\u00f3n 16\ni_REALV17 : REAL; //Valor posici\u00f3n 17\ni_REALV18 : REAL; //Valor posici\u00f3n 18\ni_REALV19 : REAL; //Valor posici\u00f3n 19\ni_REALV20 : REAL; //Valor posici\u00f3n 20\nEND_VAR\n\n//Retorna la suma de todos los valores dividida del n\u00famero de valores que son 20.\n\nFc_AverageValues := (i_REALV1 + i_REALV2 + i_REALV3 + i_REALV4 + i_REALV5 + i_REALV6 + i_REALV7 + i_REALV8 + i_REALV9 + i_REALV10 + i_REALV11 + i_REALV12 + i_REALV13 + i_REALV14 + i_REALV15 + i_REALV16 + i_REALV17 + i_REALV18 + i_REALV19 + i_REALV20) / 20.0 ;\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#codigo-de-la-funcion-fc_averagereferencia-para-pase-por-referencia","title":"C\u00f3digo de la funci\u00f3n Fc_AverageReferencia para pase por referencia:","text":"<pre><code>// Esta funci\u00f3n calcula la media de un buffer de 20 elementos. Solo a modo de ejemplo comparativo\n// pasando valores por referencia.\n\nFUNCTION Fc_AverageReferencia : REAL\n\nVAR_INPUT\ni_Ref : REFERENCE TO ARRAY[1..20] OF REAL;\nEND_VAR\nVAR\nintIdx : INT;      // Variable indice para el bucle.\nrVAcum : REAL:=0; // Valor acumulado.\nEND_VAR\n\n// Retorna la suma de todos los valores divida del n\u00famero de valores que son 20.\n\nFOR intIdx:=1 TO 20 BY 1 DO\nrVAcum := rVAcum + i_Ref[intIdx];\nEND_FOR;\nFc_AverageReferencia := rVAcum / 20.0;\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#codigo-de-ejemplo-de-llamada-a-ambas-funciones","title":"C\u00f3digo de ejemplo de llamada a ambas funciones:","text":"<p><pre><code>PROGRAM SR_Main_04\nVAR\narFIFO  : ARRAY[1..20] OF REAL; // FIFO con los valores de fuerza registrados.\nintIdx  : INT;                  // Variable de indice.\nrIncAng : REAL;                 // Valor de incremento angular para generaci\u00f3n de senoide.\nrValAng : REAL;                 // Valor actual de angulo.\nrValSin : REAL;                 // Amplitud de la senoide superpuesta.\nrVMed   : REAL;                 // Resultado del c\u00e1lculo.\n\nrefFIFO : REFERENCE TO ARRAY[1..20] OF REAL := arFIFO; // Crea una referencia y la asigna a arFIFO\nrMedRef : REAL;           // Resultado del c\u00e1lculo para el ejemplo de pase de valores por Ref.\nEND_VAR\n\n// Ejemplo de como realizar el c\u00e1lculo del valor medio de las lecturas de fuerza contenidas en arFIFO\n// mediante la funci\u00f3n Fc_AverageValues (Pase de par\u00e1metros por valores) y Fc_AverageReferencia (Pase de\n// par\u00e1metros por referencia)\n// Lo que se pretende es ver las ventajas del pase por referencia\n\n// Asignaci\u00f3n de valores para llenar el FIFO a efectos de tener algunos valores para el c\u00e1lculo de la media\n// al valor 124 le superpone una variaci\u00f3n senoidal de amplitud 6\n\nrIncAng := (2 * 3.14159) / 20.0; // 2 * PI Radianes dividido entre 20 puntos.\nrValAng := 0.0;                   // Valor inicial del angulo.\n\nFOR intIdx :=1 TO 20 BY 1 DO\nrValSin := SIN(rValAng) * 6;         // Valor del seno para una amplitud de 6\narFIFO[intIdx] := 124.0 + rValSin;  // A un nivel de 124.0 se superpone un seno de amplitud 6.\nrValAng := rValAng + rIncAng;       // Pr\u00f3ximo valor angular. \nEND_FOR;\n\n// Con el FIFO de valores llamaremos a la funci\u00f3n para el c\u00e1lculo de la media pasando valores.\n// Lo que no ser\u00eda para nada adecuado por tratarse de muchos par\u00e1metros.\n\nrVMed:= Fc_AverageValues( i_REALV1  := arFIFO[1],\ni_REALV2  := arFIFO[2],\ni_REALV3  := arFIFO[3],\ni_REALV4  := arFIFO[4], i_REALV5  := arFIFO[5],\ni_REALV6  := arFIFO[6], i_REALV7  := arFIFO[7],\ni_REALV8  := arFIFO[8],\ni_REALV9  := arFIFO[9],\ni_REALV10 := arFIFO[10],\ni_REALV11 := arFIFO[11],\ni_REALV12 := arFIFO[12],\ni_REALV13 := arFIFO[13],\ni_REALV14 := arFIFO[14],\ni_REALV15 := arFIFO[15],\ni_REALV16 := arFIFO[16],\ni_REALV17 := arFIFO[17],\ni_REALV18 := arFIFO[18],\ni_REALV19 := arFIFO[19],\ni_REALV20 := arFIFO[20]);\n\n// Con el FIFO lleno de valores llamaremos a la funci\u00f3n para el c\u00e1lculo de la media pasando valores por referencia\n// para ver lo sencillo que resulta en este caso.\n\nrMedRef := Fc_AverageReferencia(i_Ref:=refFIFO);\n</code></pre> Claramente la llamada a la funci\u00f3n pasando los valores por referencia es la mejor. Y en este ejemplo se ha supuesto un ejemplo con solo 20 datos de entrada, pero lo normal es encontrar aplicaciones con estructuras de datos de varios Kbytes.</p> <ul> <li>Un puntero de tipo T apunta a un objeto de tipo T (T = tipo de datos b\u00e1sico o definido por el usuario)</li> <li>Un puntero contiene la direcci\u00f3n del objeto al que apunta.</li> <li>La operaci\u00f3n fundamental con un puntero se llama \"desreferenciar\". La desreferenciaci\u00f3n en CODESYS se realiza con el s\u00edmbolo \"^\"</li> <li>Un puntero puede apuntar a un objeto diferente en un momento diferente.</li> <li>Antes de desreferenciar un puntero y asignarle un valor, siempre debe verificar si un puntero apunta a un objeto. (puntero = 0)?</li> <li>Una referencia del tipo T \"apunta\" a un objeto del tipo T (T = tipo de datos b\u00e1sico o definido por el usuario).</li> <li>Una referencia debe ser inicializada con un objeto y su \"apuntando\" a este objeto a trav\u00e9s del programa.</li> <li>Una referencia no debe ser desreferenciada como un puntero y puede usarse con la misma sintaxis que el objeto.</li> <li>Otra palabra de referencia es \"Alias\" (otro nombre) un seud\u00f3nimo para el objeto.</li> <li>La referencia no tiene direcci\u00f3n propia y un puntero s\u00ed. La direcci\u00f3n de la referencia es la misma que la del objeto \"puntiagudo\".</li> <li>No hay referencia 0, por lo que nunca debe llamar a la referencia si no est\u00e1 inicializada.</li> <li>Debe verificar si tiene una referencia v\u00e1lida con la palabra clave integrada CODESYS \"__ISVALIDREF\".</li> </ul> <p>El mejor uso de punteros y referencias es cuando desea pasar o devolver un objeto de alg\u00fan tipo a una funci\u00f3n o bloque de funciones por \"referencia\" porque el objeto es demasiado grande o desea manipular el objeto pasado dentro de la funci\u00f3n/bloque de funci\u00f3n. Aseg\u00farese de que el lector de su c\u00f3digo sepa que va a cambiar el valor del objeto dentro de la funci\u00f3n/bloque de funciones si esto es lo que pretende hacer cuando lo pasa como argumento.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#resumen-conclusiones","title":".Resumen / Conclusiones:","text":"<ul> <li>La memoria contiene miles y hasta millones de celdas o byte, en las que se ubica el c\u00f3digo del programa y todos los datos/variables. Cada celda tiene su n\u00famero, al que se llama direcci\u00f3n de memoria y que se suele expresar en hexadecimal 16#FA1204 -como ejemplo-</li> <li>Un puntero es una variable, que en lugar de contener un valor contiene una direcci\u00f3n de memoria, en la que \u201cvive\u201d la variable a la que realmente queremos acceder. </li> <li>Al igual que cualquier otra variable, hay que declarar los punteros para que el compilador pueda ubicarlos en la memoria.  Recordemos que un puntero es una variable, pero que su contenido es una direcci\u00f3n de memoria.</li> <li>Para cada tipo de variable se precisa el correspondiente tipo de puntero.  No se puede acceder a una variable INT con un puntero pensado para acceder a una estructura de datos.</li> <li>Nada tiene que ver el acceso indirecto a un array mediante una variable de \u00edndice, con un puntero.  En este caso el acceso est\u00e1 limitado al propio array, con el puntero se puede acceder a cualquier direcci\u00f3n de memoria.</li> <li>Con punteros se puede acceder a todo tipo de datos, en una simple l\u00ednea de c\u00f3digo se puede copiar una estructura entera de varios Kbytes de datos. Lo que resulta mucho m\u00e1s r\u00e1pido.</li> <li>Una referencia se parece mucho a un puntero, para simplificar podr\u00edamos decir que es un \u201calias\u201d de un objeto y que es algo menos cr\u00edtico que los punteros, su principal utilidad es la de pasar gran cantidad de par\u00e1metros a funciones, de forma muy simple y r\u00e1pida.</li> <li>El pase de par\u00e1metros a una funci\u00f3n se puede realizar de diversas formas, por valores, por punteros o por referencia, el programador deber\u00e1 elegir el m\u00e1s adecuado para cada aplicaci\u00f3n.</li> <li>Cuando se trata de grandes cantidades de datos el pase de par\u00e1metros por referencia o por punteros, ser\u00e1n los adecuados</li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#links-de-puntero-y-referencia","title":"Links de Puntero y Referencia:","text":"<ul> <li> <p>\ud83d\udd17 Perre Garriga,Pointer&amp;Reference</p> </li> <li> <p>\ud83d\udd17 Control and use of Pointers In Codesys</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Pointers</p> </li> <li> <p>\ud83d\udd17 AT&amp;U, CODESYS - Difference between pointer and reference</p> </li> <li> <p>\ud83d\udd17 AT&amp;U, CODESYS -Differente between pass by vale and pass by Reference</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#link-al-video-de-youtube-011","title":"Link al Video de Youtube 011:","text":"<ul> <li>\ud83d\udd17 011 - OOP IEC 61131-3 PLC -- Puntero vs Referencia</li> </ul>"},{"location":"Clases%20y%20Objetos/propiedad/","title":"Objeto Propiedad","text":""},{"location":"Clases%20y%20Objetos/propiedad/#propiedades","title":"Propiedades:","text":"<p>Las propiedades son las principales variables de una clase. Se pueden utilizar como una alternativa a la clase regular o E/S del bloque de funciones. Las propiedades tienen m\u00e9todos Get \"Obtener\" y Set \"Establecer\" que permiten acceder y/o cambiar las variables:</p> <ul> <li>Get - M\u00e9todo que devuelve el valor de una variable.</li> <li>Set - M\u00e9todo que establece el valor de una variable.</li> </ul> <p>Al eliminar el m\u00e9todo \"Obtener\" o \"Establecer\", un programador puede hacer que las propiedades sean \"de solo escritura\" o \u201csolo lectura\u201d, respectivamente. Dado que estos son m\u00e9todos, significa que las propiedades pueden:</p> <ul> <li>Tener sus propias variables internas.</li> <li>Realizar operaciones antes de devolver su valor.</li> <li>No es necesario adjuntar la variable devuelta a una entrada o salida en particular (o variable interna) de la POU, puede devolver un valor basado en una determinada combinaci\u00f3n de sus variables.</li> <li>Ser accedido por evento en lugar de ser verificado en cada ciclo de ejecuci\u00f3n.</li> </ul>"},{"location":"Clases%20y%20Objetos/propiedad/#propiedades-getters-setters","title":"Propiedades: Getters &amp; Setters:","text":"<p>para modificar directamente nuestras propiedades lo que se busca es que se haga a trav\u00e9s de los metodos Getters y Setters, el cual var\u00eda la escritura seg\u00fan el lenguaje pero el concepto es el mismo.</p> <p>Por lo tanto, una declaraci\u00f3n de propiedad tiene la siguiente estructura:</p> <p><pre><code>PROPERTY &lt;Access specifier&gt; &lt;Name&gt; : &lt;Datatype&gt;\n</code></pre> En el Objeto Propiedad es obligatorio que retorne un valor.</p>"},{"location":"Clases%20y%20Objetos/propiedad/#especificadores-de-acceso","title":"Especificadores de acceso:","text":"<p>Al igual que con los m\u00e9todos, las propiedades tambi\u00e9n pueden tomar los siguientes especificadores de acceso: PUBLIC , PRIVATE , PROTECTED , INTERNAL y FINAL . Cuando no se define ning\u00fan especificador de acceso, la propiedad es PUBLIC . Adem\u00e1s, tambi\u00e9n se puede especificar un especificador de acceso para cada setter y getter. Esto tiene prioridad sobre el propio especificador de acceso de la propiedad.</p> <p>Las propiedades son reconocibles por las siguientes caracter\u00edsticas:</p> <p>Especificador de acceso:</p> <ul> <li>PUBLIC: <ul> <li>Corresponde a la especificaci\u00f3n de modificador sin acceso.</li> </ul> </li> <li>PRIVATE: <ul> <li>El acceso a la propiedad est\u00e1 limitado solo al bloque de funciones.</li> </ul> </li> <li>PROTECTED:<ul> <li>El acceso a la propiedad est\u00e1 limitado al programa o al bloque de funci\u00f3n y sus derivados.</li> </ul> </li> <li>INTERNAL:<ul> <li>El acceso a la propiedad est\u00e1 limitado al espacio de nombres, es decir, a la biblioteca.</li> </ul> </li> <li>FINAL: <ul> <li>No se permite sobrescribir la propiedad en un derivado del bloque de funciones. Esto significa que la propiedad no se puede sobrescribir ni extender en una subclase posiblemente existente.</li> <li>Las propiedades pueden ser abstractas, lo que significa que una propiedad no tiene una implementaci\u00f3n inicial y que la implementaci\u00f3n real se proporciona en el bloque de funciones derivado.</li> </ul> </li> </ul> <p>Los pragmas son muy \u00fatiles para monitorear propiedades en modo en l\u00ednea. Para esto, escr\u00edbalos en la parte superior de las declaraciones de propiedades (attribute 'monitoring'):</p> <p>{attribute 'monitoring := 'variable'}:  Al acceder a una propiedad, TwinCAT almacena el valor real en una variable y muestra el valor de esta \u00faltima. Este valor puede volverse obsoleto si el c\u00f3digo ya no accede a la propiedad.</p> <p>{attribute 'monitoring' := 'call'}:  Cada vez que se muestra el valor, TwinCAT llama al c\u00f3digo del descriptor de acceso Get. Cualquier efecto secundario, provocado por ese c\u00f3digo, puede aparecer en el seguimiento.</p>"},{"location":"Clases%20y%20Objetos/propiedad/#links-del-objeto-propiedad","title":"Links del Objeto Propiedad:","text":"<ul> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Codesys del Objeto propiedad</p> </li> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Beckhoff del Objeto propiedad</p> </li> <li> <p>\ud83d\udd17 utilizing-properties,twincontrols.com</p> </li> <li> <p>\ud83d\udd17 object-oriented-programming-in-programmable-logic-controllers-plc-whats-really-new,en.grse.de</p> </li> <li> <p>\ud83d\udd17 TC07.Beckhoff TwinCAT3 Function Block-Part2 Property.JP- DUT</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/propiedad/#link-al-video-de-youtube-006","title":"Link al Video de Youtube 006:","text":"<ul> <li>\ud83d\udd17 006 - OOP IEC 61131-3 PLC -- Objeto Propiedad</li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/","title":"Herencia Bloque de Funcion","text":""},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#herencia-bloque-de-funcion","title":"Herencia Bloque de Funcion:","text":"<p>Los bloques de funciones son un medio excelente para mantener las secciones del programa separadas entre s\u00ed. Esto mejora la estructura del software y simplifica significativamente la reutilizaci\u00f3n. Anteriormente, ampliar la funcionalidad de un bloque de funciones existente siempre era una tarea delicada. Esto signific\u00f3 modificar el c\u00f3digo o programar un nuevo bloque de funciones alrededor del bloque existente (es decir, el bloque de funciones existente se incrust\u00f3 efectivamente dentro de un nuevo bloque de funciones). En el \u00faltimo caso, fue necesario crear todas las variables de entrada nuevamente y asignarlas a las variables de entrada para el bloque de funciones existente. Lo mismo se requer\u00eda, en sentido contrario, para las variables de salida.</p> <p>TwinCAT 3 y Codesys (IEC61131-3) introduce el concepto de herencia. La herencia es uno de los principios fundamentales de la programaci\u00f3n orientada a objetos. La herencia implica derivar un nuevo bloque de funciones a partir de un bloque de funciones existente. A continuaci\u00f3n, se puede ampliar el nuevo bloque. En la medida permitida por los especificadores de acceso del bloque de funciones principal, el nuevo bloque de funciones hereda todas las propiedades y m\u00e9todos del bloque de funciones principal. Cada bloque de funciones puede tener cualquier n\u00famero de bloques de funciones secundarios, pero solo un bloque de funciones principal. La derivaci\u00f3n de un bloque de funciones se produce en la nueva declaraci\u00f3n del bloque de funciones. El nombre del nuevo bloque de funciones va seguido de la palabra clave EXTENDS seguida del nombre del bloque de funciones principal. Por ejemplo:</p> <p><pre><code>FUNCTION_BLOCK PUBLIC FB_NewEngine EXTENDS FB_Engine\n</code></pre> El nuevo bloque de funciones derivado ( FB_NewEngine ) posee todas las propiedades y m\u00e9todos de su padre ( FB_Engine ). Sin embargo, los m\u00e9todos y las propiedades solo se heredan cuando el especificador de acceso lo permite.</p> <p>El bloque de funciones secundario tambi\u00e9n hereda todas las variables Locales, VAR_INPUT , VAR_OUTPUT y VAR_IN_OUT del bloque de funciones principal. Este comportamiento no se puede modificar mediante especificadores de acceso.</p> <p>Si los m\u00e9todos o las propiedades del bloque de funciones principal se han declarado como PROTECTED, el bloque de funciones secundario ( FB_NewEngine ) podr\u00e1 acceder a ellos, pero no desde fuera de FB_NewEngine .</p> <p>La herencia se aplica solo a las POU de tipo FUNCTION_BLOCK.</p>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#especificadores-de-acceso","title":"Especificadores de acceso:","text":"<p>Las declaraciones FUNCTION_BLOCK , FUNCTION o PROGRAM pueden incluir un especificador de acceso. Esto restringe el acceso y, en su caso, la capacidad de heredar.</p> <ul> <li>PUBLIC:</li> </ul> <p>Cualquiera puede llamar o crear una instancia de la POU. Adem\u00e1s, si la POU es un FUNCTION_BLOCK , se puede usar para la herencia. No se aplican restricciones.</p> <ul> <li>INTERN:</li> </ul> <p>La POU solo se puede utilizar dentro de su propio espacio de nombres. Esto permite que las POU est\u00e9n disponibles solo dentro de una determinada biblioteca, por ejemplo.</p> <ul> <li>FINAL:</li> </ul> <p>El FUNCTION_BLOCK no puede servir como un bloque de funciones principal. Los m\u00e9todos y las propiedades de esta POU no se pueden heredar. FINAL solo est\u00e1 permitido para POU del tipo FUNCTION_BLOCK .</p> <p>La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC. Los especificadores de acceso PRIVATE y PROTECTED no est\u00e1n permitidos en las declaraciones de POU.</p> <p>Si planea utilizar la herencia, la declaraci\u00f3n del bloque de funciones tendr\u00e1 la siguiente estructura:</p> <pre><code>FUNCTION_BLOCK &lt;Access specifier&gt; &lt;Name&gt; EXTENDS &lt;Name basic function block&gt;\n</code></pre>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#metodos-de-sobrescritura","title":"M\u00e9todos de Sobrescritura:","text":"<p>El nuevo FUNCTION_BLOCK FB_NewEngine , que se deriva de FB_Engine , puede contener propiedades y m\u00e9todos adicionales. Por ejemplo, podemos agregar la propiedad Gear . Esta propiedad se puede utilizar para consultar y cambiar la marcha actual. Es necesario configurar getters y setters para esta propiedad.</p> <p>Sin embargo, tambi\u00e9n debemos asegurarnos de que el par\u00e1metro nGear del m\u00e9todo Start() se pase a esta propiedad. Debido a que el bloque de funciones principal FB_Engine no tiene acceso a esta nueva propiedad, se debe crear un nuevo m\u00e9todo con exactamente los mismos par\u00e1metros en FB_NewEngine . Copiamos el c\u00f3digo existente al nuevo m\u00e9todo y agregamos nuevo c\u00f3digo para que el par\u00e1metro nGear se pase a la propiedad Gear .</p> <p><pre><code>METHOD PUBLIC Start\nVAR_INPUT\nnGear : INT := 2;\nfVelocity : LREAL := 8.0;\nEND_VAR IF (fVelocity &lt; MaxVelocity) THEN\nvelocityInternal := fVelocity;\nELSE\nvelocityInternal := MaxVelocity;\nEND_IF\nGear := nGear; // new\n</code></pre> La l\u00ednea 12 copia el par\u00e1metro nGear a la propiedad Gear.</p> <p>Cuando un m\u00e9todo o propiedad que ya est\u00e1 presente en el bloque de funciones principal se redefine dentro del bloque de funciones secundario, esto se denomina sobrescritura. El bloque de funciones FB_NewEngine sobrescribe el m\u00e9todo Start() .</p> <p>Por lo tanto, FB_NewEngine tiene la nueva propiedad Gear y sobrescribe el m\u00e9todo Start() .</p> <p></p> <p><pre><code>fbNewEngine.Start(1, 7.5);\n</code></pre> llama al m\u00e9todo Start() en FB_NewEngine, ya que este m\u00e9todo ha sido redefinido (sobrescrito) en FB_NewEngine .</p> <p>Mientras que:</p> <p><pre><code>fbNewEngine.Stop();\n</code></pre> llama al m\u00e9todo Stop() desde FB_Engine . El m\u00e9todo Stop() ha sido heredado por FB_NewEngine de FB_Engine .</p>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> <li> <p>\ud83d\udd17 Simple Codesys OOP - Inheritance</p> </li> <li> <p>\ud83d\udd17 TC11.Beckhoff TwinCAT3 Function Block Extend.JP</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#link-al-video-de-youtube-007","title":"Link al Video de Youtube 007:","text":"<ul> <li>\ud83d\udd17 007 - OOP IEC 61131-3 PLC -- Herencia FB</li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Estructura/","title":"Herencia Estructura","text":""},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Estructura/#herencia-estructura","title":"Herencia Estructura:","text":"<p>Al igual que los bloques de funciones, las estructuras se pueden ampliar. La estructura obtiene entonces las variables de la estructura b\u00e1sica adem\u00e1s de sus propias variables.</p> <p>Crear una estructura que extienda a otra Estructura: <pre><code>TYPE ST_Base1 :\nSTRUCT\nbBool1: BOOL;\niINT : INT;\nrReal : REAL;   END_STRUCT\nEND_TYPE\n</code></pre> <pre><code>TYPE ST_Sub1 EXTENDS ST_Base1:\nSTRUCT\nttime :TIME;\ntton  : TON;\nEND_STRUCT\nEND_TYPE\n</code></pre> <pre><code>TYPE ST_Sub2 EXTENDS ST_Sub1 :\nSTRUCT\nbBool2: BOOL; // No se podria llamar la variable bBool1 porque la tenemos declarada en la estructura ST_Base1\nEND_STRUCT\nEND_TYPE\n</code></pre> <pre><code>PROGRAM MAIN\nVAR\nstestructura1  : ST_Sub1;\nstestructura2  : ST_Sub2;\nEND_VAR\n\n//Extensi\u00f3n de Estructura:\nstestructura1.bBool1;\nstestructura1.iINT;\nstestructura1.rReal;\nstestructura1.ttime;\nstestructura1.tton(in:= TRUE, pt:=T#1S);\n\nstestructura2.bBool1;\nstestructura2.iINT;\nstestructura2.rReal;\nstestructura2.ttime;\nstestructura2.tton(in:= TRUE, pt:=T#1S);\nstestructura2.bBool2;\n</code></pre></p> <ul> <li> <p>De esta forma de extender una Estructura por Herencia no se pueden repetir el mismo nombre de variable declarada con las estructuras extendidas.</p> </li> <li> <p>Tambien sin usar EXTENDS para la Estructura podriamos realizarlo de la siguiente forma:</p> </li> </ul> <p><pre><code>TYPE ST_2 :\nSTRUCT\nbBool : BOOL;\nEND_STRUCT\nEND_TYPE\n</code></pre> <pre><code>TYPE ST_1:\nSTRUCT\nsStruct : ST_2;\nsstring : STRING(80);\nEND_STRUCT\nEND_TYPE\n</code></pre> <pre><code>PROGRAM MAIN\nVAR\nstestructura11 : ST_1;\nEND_VAR\n\nstestructura11.sstring;\nstestructura11.sStruct.bBool; //el resultado es que queda mas anidado\n</code></pre></p> <ul> <li> <p>De esta forma si que se pueden declarar el mismo nombre de la variable en diferentes Estructuras, ya que al estar anidadas no existe el problema anterior.</p> </li> <li> <p>No se permite la herencia m\u00faltiple de la siguiente forma:</p> </li> </ul> <pre><code>TYPE ST_Sub EXTENDS ST_Base1,ST_Base2 :\nSTRUCT\n</code></pre>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Estructura/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 infosys.beckhoff.com, Extends Structure</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Structure</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Structure</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Structure</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Estructura/#link-al-video-de-youtube-008","title":"Link al Video de Youtube 008:","text":"<ul> <li>\ud83d\udd17 008 - OOP IEC 61131-3 PLC -- Herencia Estructura e Interface</li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Interface/","title":"Herencia Interface","text":""},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Interface/#herencia-interface","title":"Herencia Interface:","text":"<p>Al igual que los bloques de funciones, las interfaces se pueden ampliar. A continuaci\u00f3n, la interface obtiene los m\u00e9todos de interface y las propiedades de la interface b\u00e1sica, adem\u00e1s de los suyos propios.</p> <p>Cree una interface que ampl\u00ede otra interface mediante la extensi\u00f3n:</p> <pre><code>INTERFACE I_Sub1 EXTENDS I_Base1, I_Base2\n</code></pre> <ul> <li>Se permite la herencia m\u00faltiple mediante la extensi\u00f3n de interfaces:</li> </ul> <pre><code>INTERFACE I_Sub2 EXTENDS I_Sub1\n</code></pre> <ul> <li>Se permite la herencia m\u00faltiple para las interfaces. Es posible que una interfaz ampl\u00ede a m\u00e1s de una interface.</li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Interface/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 infosys.beckhoff.com, Extends Interface</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Extends Interface</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Interface/#link-al-video-de-youtube-008","title":"Link al Video de Youtube 008:","text":"<ul> <li>\ud83d\udd17 008 - OOP IEC 61131-3 PLC -- Herencia Estructura e Interface</li> </ul>"},{"location":"Conceptos%20Previos/Tabla%20de%20Modificadores%20de%20acceso/","title":"Tabla de Modificadores de acceso","text":"Modificadores de acceso FUNCTION_BLOCK - FB METODO PROPIEDAD PUBLIC Si Si Si INTERNAL Si Si Si FINAL Si Si Si ABSTRACT Si Si Si PRIVATE No Si Si PROTECTED No Si Si"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/","title":"Tipos de Datos","text":""},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#declaracion-de-una-variable","title":"Declaracion de una Variable:","text":"<p>La declaraci\u00f3n de variables en CODESYS \u00f3 TwinCAT incluir\u00e1: - Un nombre de variable - Dos puntos - Un tipo de dato - Un valor inicial opcional - Un punto y coma - Un comentario opcional</p>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#tipos-de-datos","title":"\ud83d\udd17 Tipos de Datos:","text":""},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#las-ventajas-de-las-estructuras-de-datos","title":"Las ventajas de las estructuras de datos.","text":"<ul> <li>La principal aportaci\u00f3n de las estructuras de datos y los tipos de datos  creados por el usuario es la claridad y el orden del c\u00f3digo resultante.</li> </ul> <ul> <li> <p>Estructuras de datos: (STRUCT)</p> </li> <li> <p>\ud83d\udd17 Extender una Estructura, Infosys Beckhoff</p> </li> <li> <p>Datos de usuario:UDT (User Data Type) Los UDT (User Data Type) son tipos de datos que el usuario crea a su medida,  seg\u00fan las necesidades de cada proyecto.</p> </li> </ul> <p>When programming in TwinCAT, you can use different data types or instances of function blocks. You assign a data type to each identifier. The data type determines how much memory space is allocated and how these values are interpreted.</p> <p>The following groups of data types are available:</p>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#standard-data-types","title":"Standard data types","text":"<p>TwinCAT supports all data types described in the IEC 61131-3 standard.</p> <ul> <li>BOOL</li> <li>Integer Data Types</li> <li>REAL / LREAL</li> <li>STRING</li> <li>WSTRING</li> <li>Time, date and time data types</li> <li>LTIME</li> </ul>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#extensions-of-the-iec-61131-3-standard","title":"Extensions of the IEC 61131-3 standard","text":"<ul> <li>BIT</li> <li>ANY and ANY_ <li>Special data types XINT, UXINT, XWORD and PVOID</li> <li>REFERENCE</li> <li>UNION</li> <li>POINTER</li> <li>Data type __SYSTEM.ExceptionCode</li>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#user-defined-data-types","title":"User-defined data types","text":"<p>Note the recommendations for naming objects.</p> <ul> <li>POINTER</li> <li>REFERENCE</li> <li>ARRAY</li> <li> <p>Subrange Types User-defined data types that you create as DUT object in the TwinCAT PLC project tree:</p> </li> <li> <p>Structure</p> </li> <li>Enumerations</li> <li>Alias</li> <li>UNION</li> </ul>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#further-information","title":"Further Information","text":"<ul> <li>BOOL</li> <li>Integer Data Types</li> <li>Subrange Types</li> <li>BIT</li> <li>REAL / LREAL</li> <li>STRING</li> <li>WSTRING</li> <li>Time, date and time data types</li> <li>ANY and ANY_ <li>Special data types XINT, UXINT, XWORD and PVOID</li> <li>POINTER</li> <li>Data type __SYSTEM.ExceptionCode</li> <li>Interface pointer / INTERFACE</li> <li>REFERENCE https://infosys.beckhoff.com/english.php?content=../content/1033/tc3_plc_intro/2529458827.html&amp;id=</li> <li>ARRAY</li> <li>Structure</li> <li>Enumerations</li> <li>Alias</li> <li>UNION</li>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#links-tipos-de-datos","title":"Links Tipos de Datos:","text":"<ul> <li> <p>\ud83d\udd17 12. TwinCAT 3: Standard data types</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Tipos de datos</p> </li> <li> <p>\ud83d\udd17 www.infoplc.net, codesys-variables</p> </li> <li> <p>\ud83d\udd17 TC10.Beckhoff TwinCAT3 DUT\u69cb\u9020\u4f53.JP</p> </li> </ul>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/","title":"Tipos de variables y variables especiales","text":""},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#variable-types-and-special-variables","title":"Variable types and special variables:","text":"<p>The variable type defines how and where you can use the variable. The variable type is defined during the variable declaration.</p>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#further-information","title":"Further Information:","text":"<ul> <li>Local Variables - VAR<ul> <li>Las variables locales se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR y END_VAR.</li> <li>Puede extender las variables locales con una palabra clave de atributo.</li> <li>Puede acceder a variables locales para leer desde fuera de los objetos de programaci\u00f3n a trav\u00e9s de la ruta de instancia. El acceso para escribir desde fuera del objeto de programaci\u00f3n no es posible; Esto ser\u00e1 mostrado por el compilador como un error.</li> <li>Para mantener la encapsulaci\u00f3n de datos prevista, se recomienda encarecidamente no acceder a las variables locales de un POU desde fuera del POU, ni en modo de lectura ni en modo de escritura. (Otros compiladores de lenguaje de alto nivel tambi\u00e9n generan operaciones de acceso de lectura a variables locales como errores). Adem\u00e1s, con los bloques de funciones de biblioteca no se puede garantizar que las variables locales de un bloque de funciones permanezcan sin cambios durante las actualizaciones posteriores. Esto significa que es posible que el proyecto de aplicaci\u00f3n ya no se pueda compilar correctamente despu\u00e9s de la actualizaci\u00f3n de la biblioteca.</li> <li>Tambi\u00e9n observe aqu\u00ed la regla SA0102 del An\u00e1lisis Est\u00e1tico, que determina el acceso a las variables locales para la lectura desde el exterior.</li> </ul> </li> <li>Input Variables - VAR_INPUT<ul> <li>Las variables de entrada son variables de entrada para un bloque de funciones.</li> <li>VAR_INPUT variables se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR_INPUT y END_VAR.</li> <li>Puede ampliar las variables de entrada con una palabra clave de atributo.</li> </ul> </li> <li>Output Variables - VAR_OUTPUT<ul> <li>Las variables de salida son variables de salida de un bloque de funciones.</li> <li>VAR_OUTPUT variables se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR_OUTPUT y END_VAR. TwinCAT devuelve los valores de estas variables al bloque de funci\u00f3n de llamada. All\u00ed puede consultar los valores y continuar us\u00e1ndolos.</li> <li>Puede ampliar las variables de salida con una palabra clave de atributo.    </li> </ul> </li> <li>Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</li> <li>Global Variables - VAR_GLOBAL<ul> <li>Solo es posible su declaraci\u00f3n en GVL (Lista de Variables Global)</li> </ul> </li> <li>Temporary Variable - VAR_TEMP<ul> <li>Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.</li> <li>Las variables temporales se declaran localmente entre las palabras clave VAR_TEMP y END_VAR.</li> <li>VAR_TEMP declaraciones s\u00f3lo son posibles en programas y bloques de funciones.</li> <li>TwinCAT reinicializa las variables temporales cada vez que se llama al bloque de funciones.</li> <li>La aplicaci\u00f3n s\u00f3lo puede acceder a variables temporales en la parte de implementaci\u00f3n de un programa o bloque de funciones.</li> </ul> </li> <li>Static Variables - VAR_STAT<ul> <li>Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.</li> <li>Las variables est\u00e1ticas se declaran localmente entre las palabras clave VAR_STAT y END_VAR. TwinCAT inicializa las variables est\u00e1ticas cuando se llama por primera vez al bloque de funciones respectivo.</li> <li>Puede tener acceso a las variables est\u00e1ticas s\u00f3lo dentro del espacio de nombres donde se declaran las variables (como es el caso de las variables est\u00e1ticas en C). Sin embargo, las variables est\u00e1ticas conservan su valor cuando la aplicaci\u00f3n sale del bloque de funciones. Puede utilizar variables est\u00e1ticas, como contadores para llamadas a funciones, por ejemplo.</li> <li>Puede extender variables est\u00e1ticas con una palabra clave de atributo.</li> <li>Las variables est\u00e1ticas solo existen una vez. Esto tambi\u00e9n se aplica a las variables est\u00e1ticas de un bloque de funciones o un m\u00e9todo de bloque de funciones, incluso si el bloque de funciones se instancia varias veces.</li> </ul> </li> <li>External Variables - VAR_EXTERNAL<ul> <li>Las variables externas son variables globales que se \"importan\" en un bloque de funciones.</li> <li>Puede declarar las variables entre las palabras clave VAR_EXTERNAL y END_VAR. Si la variable global no existe, se emite un mensaje de error.  </li> <li>En TwinCAT 3 PLC no es necesario que las variables se declaren como externas. La palabra clave existe para mantener la compatibilidad con IEC 61131-3.</li> <li>Si, no obstante, utiliza variables externas, aseg\u00farese de abordar las variables asignadas (con AT %I o AT %Q) s\u00f3lo en la lista global de variables. El direccionamiento adicional de las instancias de variables locales dar\u00eda lugar a duplicaciones en la imagen del proceso.</li> <li>Estas variables declaradas tambien tiene que estar declarada la misma variable con el mismo nombre en una GVL (Lista de Varaibles Global)</li> </ul> </li> <li>Instance Variables - VAR_INST<ul> <li>TwinCAT crea una variable VAR_INST de un m\u00e9todo no en la pila de m\u00e9todos como las variables VAR, sino en la pila de la instancia del bloque de funciones. Esto significa que la variable VAR_INST se comporta como otras variables de la instancia del bloque de funci\u00f3n y no se reinicializa cada vez que se llama al m\u00e9todo.</li> <li>VAR_INST variables solo est\u00e1n permitidas en los m\u00e9todos de un bloque de funciones, y el acceso a dicha variable solo est\u00e1 disponible dentro del m\u00e9todo. Puede supervisar los valores de las variables de instancia en la parte de declaraci\u00f3n del m\u00e9todo.</li> <li>Las variables de instancia no se pueden extender con una palabra clave de atributo.</li> </ul> </li> <li>Remanent Variables - PERSISTENT, RETAIN Las variables remanentes pueden conservar sus valores m\u00e1s all\u00e1 del tiempo de ejecuci\u00f3n habitual del programa. Las variables remanentes se pueden declarar como variables RETAIN o incluso m\u00e1s estrictamente como variables PERSISTENTES en el proyecto PLC.</li> </ul> <p>Un requisito previo para la funcionalidad completa de las variables RETAIN es un \u00e1rea de memoria correspondiente en el controlador (NovRam). Las variables persistentes se escriben solo cuando TwinCAT se apaga. Esto requerir\u00e1 generalmente un UPS correspondiente. Excepci\u00f3n: Las variables persistentes tambi\u00e9n se pueden escribir con el bloque de funci\u00f3n FB_WritePersistentData.</p> <p>Si el \u00e1rea de memoria correspondiente no existe, los valores de las variables RETAIN y PERSISTENT se pierden durante un corte de energ\u00eda.</p> <p>La declaraci\u00f3n AT no debe utilizarse en combinaci\u00f3n con VAR RETAIN o VAR PERSISTENT.</p>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#variables-persistentes","title":"Variables persistentes","text":"<p>Puede declarar variables persistentes agregando la palabra clave PERSISTENT despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables PERSISTENTES conservan su valor despu\u00e9s de una terminaci\u00f3n no controlada, un Reset cold o una nueva descarga del proyecto PLC. Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. En otras palabras, TwinCAT solo reinicializa las variables PERSISTENTES durante un origen de Restablecer.</p> <p>Un ejemplo de aplicaci\u00f3n para variables persistentes es un contador de horas de funcionamiento, que debe continuar contando despu\u00e9s de un corte de energ\u00eda y cuando el proyecto PLC se descarga nuevamente.</p> <p>Evite usar el tipo de datos POINTER TO en listas de variables persistentes, ya que los valores de direcci\u00f3n pueden cambiar cuando el proyecto PLC se descargue nuevamente. TwinCAT emite las advertencias correspondientes del compilador. Declarar una variable local como PERSISTENTE en una funci\u00f3n no tiene ning\u00fan efecto. La persistencia de datos no se puede utilizar de esta manera. El comportamiento durante un restablecimiento en fr\u00edo puede verse influenciado por el pragma 'TcInitOnReset'</p>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#variables-retain","title":"Variables RETAIN","text":"<p>Puede declarar variables RETAIN agregando la palabra clave RETAIN despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables declaradas como RETAIN dependen del sistema de destino, pero normalmente se administran en un \u00e1rea de memoria separada que debe protegerse contra fallas de energ\u00eda. El llamado controlador Retain asegura que las variables RETAIN se escriban al final de un ciclo PLC y solo en el \u00e1rea correspondiente de la NovRam. El manejo del controlador de retenci\u00f3n se describe en el cap\u00edtulo \"Conservar datos\" de la documentaci\u00f3n de C/C++.</p> <p>Las variables RETAIN conservan su valor despu\u00e9s de una terminaci\u00f3n incontrolada (corte de energ\u00eda). Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. TwinCAT reinicializa las variables RETAIN en un origen de restablecimiento.</p> <p>Una posible aplicaci\u00f3n es un contador de piezas en una planta de producci\u00f3n, que debe seguir contando despu\u00e9s de un corte de energ\u00eda.</p> <p>Si declara una variable local como RETAIN en un programa o bloque de funciones, TwinCAT almacena esta variable espec\u00edfica en el \u00e1rea de retenci\u00f3n (como una variable RETEAIN global). Si declara una variable local en una funci\u00f3n como RETAIN, esto no tiene efecto. TwinCAT no almacena la variable en el \u00e1rea de retenci\u00f3n.</p>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#cuadro-general-completo","title":"Cuadro general completo","text":"<p>El grado de retenci\u00f3n de las variables RETAIN se incluye autom\u00e1ticamente en el de las variables PERSISTENT.</p> Despu\u00e9s del comando en l\u00ednea VAR VAR RETAIN VAR PERSISTENT Restablecer fr\u00edo Los valores se reinicializan Los valores se mantienen Los valores se mantienen Restablecer origen Los valores se reinicializan Los valores se reinicializan Los valores se reinicializan Descargar Los valores se reinicializan Los valores se mantienen Los valores se mantienen Cambio en l\u00ednea Los valores se mantienen Los valores se mantienen Los valores se mantienen <ul> <li>SUPER</li> <li>THIS</li> <li>Variable types - attribute keywords<ul> <li>RETAIN: for remanent variables of type RETAIN</li> <li>PERSISTENT: for remanent variables of type PERSISTENT</li> <li>CONSTANT: for constants</li> </ul> </li> </ul>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 Local Variables - VAR, infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 Instance Variables - VAR_INST, infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/instance-variables-with-var_inst</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/var_temp-var_stat-and-var_const</p> </li> <li> <p>\ud83d\udd17 Tipos de variables y variables especiales</p> </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Decorator%20Design%20Pattern/","title":"Patron Decorador","text":"<ul> <li>\ud83d\udd17 Decorator Design Pattern</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Factory%20Method%20Design%20Pattern/","title":"Patron Metodo de Fabrica","text":"<ul> <li>\ud83d\udd17 Factory Method Design Pattern</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Observer%20Design%20Pattern/","title":"Patron Observador","text":"<ul> <li>\ud83d\udd17 Observer Design Pattern </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Strategy%20pattern/","title":"Patron de Estrategia","text":"<p>TwinCAT with Head First Design Patterns Ch.1 - IntroStrategy Pattern.docx</p>"},{"location":"Patrones%20de%20Dise%C3%B1o/The%20Abstract%20Factory%20Pattern/","title":"Patron Fabrica Abstracta","text":"<ul> <li> <p>\ud83d\udd17 iec-61131-6-abstract-factory-english,stefanhenneken.net</p> </li> <li> <p>\ud83d\udd17 Abstract Factory Design Pattern</p> </li> <li> <p>refactoring.guru,abstract-factory</p> </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/","title":"Patrones de Dise\u00f1o","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#patrones-de-diseno","title":"PATRONES DE DISE\u00d1O:","text":"<p>Los patrones de dise\u00f1o son soluciones generales y reutilizables para problemas comunes que se encuentran en la programaci\u00f3n de software. En la programaci\u00f3n orientada a objetos, existen muchos patrones de dise\u00f1o que se pueden aplicar para mejorar la modularidad, la flexibilidad y el mantenimiento del c\u00f3digo. Algunos ejemplos de patrones de dise\u00f1o que se pueden aplicar en la programaci\u00f3n de PLCs incluyen el patr\u00f3n Singleton, el patr\u00f3n Factory Method, el patr\u00f3n Observer y el patr\u00f3n Strategy. Por ejemplo, el patr\u00f3n Singleton se utiliza para garantizar que solo exista una instancia de una clase determinada en todo el programa. Esto puede ser \u00fatil en la programaci\u00f3n de PLCs cuando se quiere asegurar que solo hay una instancia activa del objeto que controla un determinado proceso o dispositivo. El patr\u00f3n Factory Method se utiliza para crear instancias de objetos sin especificar expl\u00edcitamente la clase concreta a instanciar. Esto puede ser \u00fatil en la programaci\u00f3n de PLCs cuando se quiere crear objetos seg\u00fan las necesidades espec\u00edficas del programa. El patr\u00f3n Observer se utiliza para establecer una relaci\u00f3n uno a muchos entre objetos, de manera que cuando un objeto cambia su estado, todos los objetos relacionados son notificados autom\u00e1ticamente. Este patr\u00f3n puede ser muy \u00fatil en la programaci\u00f3n de PLCs para establecer relaciones entre diferentes componentes del sistema, como sensores y actuadores. El patr\u00f3n Strategy se utiliza para definir un conjunto de algoritmos intercambiables, y luego encapsular cada uno como un objeto. Este patr\u00f3n puede ser \u00fatil en la programaci\u00f3n de PLCs cuando se desea cambiar din\u00e1micamente el comportamiento del sistema seg\u00fan las condiciones del entorno. En resumen, los patrones de dise\u00f1o son una herramienta muy \u00fatil para mejorar la calidad del c\u00f3digo en la programaci\u00f3n de PLCs y se pueden aplicar con \u00e9xito en la programaci\u00f3n orientada a objetos para PLCs.</p> <pre><code>\u201cLos patrones de dise\u00f1o son \ndescripciones de objetos y clases \nconectadas que se personalizan para \nresolver un problema de dise\u00f1o \ngeneral en un contexto particular\u201d. \n- Gang of Four \n</code></pre> <p> </p> <p>Clasificaci\u00f3n seg\u00fan su prop\u00f3sito:  Los patrones de dise\u00f1o se clasificaron originalmente en tres grupos: </p> <ul> <li>Creacionales. </li> <li>Estructurales. </li> <li>De comportamiento. </li> </ul> <p>Clasificaci\u00f3n seg\u00fan su \u00e1mbito:</p> <ul> <li>De clase: Basados en la herencia de clases. </li> <li>De objeto: Basados en la utilizaci\u00f3n din\u00e1mica de objetos. </li> </ul> <p>Patrones creacionales:</p> <ul> <li>Builder</li> <li>Singleton </li> <li>Dependency Injection </li> <li>Service Locator </li> <li>Abstract Factory</li> <li>Factory Method </li> </ul> <p>Patrones estructurales:</p> <ul> <li>Adapter</li> <li>Data Access Object (DAO)  </li> <li>Query Object </li> <li>Decorator </li> <li>Bridge </li> </ul> <p>Patrones de comportamiento:</p> <ul> <li>Command</li> <li>Chain of Responsibility </li> <li>Strategy</li> <li>Template Method </li> <li>Interpreter</li> <li>Observer </li> <li>State </li> <li>Visitor </li> <li>Iterator</li> </ul> <p>Los patrones de dise\u00f1o son soluciones reutilizables para problemas comunes de dise\u00f1o de software. Proporcionan una forma para que los desarrolladores de software resuelvan problemas comunes de manera consistente y eficiente, sin tener que reinventar la rueda cada vez.</p> <p>Beneficios de usar Patrones de Dise\u00f1o =&gt;</p> <p>\u2022 Reusabilidad: Evite reinventar la rueda cada vez.</p> <p>\u2022 Escalabilidad: Dise\u00f1o de software flexible y adaptable.</p> <p>\u2022 Capacidad de mantenimiento: C\u00f3digo m\u00e1s f\u00e1cil de modificar y depurar.</p> <p>\u2022 Estandarizaci\u00f3n: Vocabulario com\u00fan y estructura a trav\u00e9s de diferentes proyectos.</p> <p>\u2022 Colaboraci\u00f3n: m\u00e1s f\u00e1cil para varios desarrolladores trabajar en el mismo c\u00f3digo base.</p> <p>Algunos patrones de dise\u00f1o de uso com\u00fan =&gt;</p> <p>\u2022 Patr\u00f3n de estrategia: el patr\u00f3n de estrategia se utiliza para definir una familia de algoritmos, encapsular cada uno y hacerlos intercambiables.</p> <p>Por ejemplo, imagina que tienes un juego con diferentes tipos de personajes, cada uno con sus propias habilidades \u00fanicas. El patr\u00f3n de estrategia le permitir\u00eda definir un conjunto de estrategias (es decir, algoritmos) para cada tipo de personaje y luego cambiar f\u00e1cilmente entre ellas seg\u00fan sea necesario.</p> <p>\u2022 Patr\u00f3n de observador: el patr\u00f3n de observador se utiliza para notificar a los objetos cuando hay un cambio en otro objeto.</p> <p>Por ejemplo, imagine que tiene una aplicaci\u00f3n meteorol\u00f3gica que necesita notificar a sus usuarios cuando cambia la temperatura. El patr\u00f3n de observador le permitir\u00eda definir un conjunto de observadores (es decir, los usuarios) y luego notificarles cuando cambie la temperatura.</p> <p>\u2022 Patr\u00f3n de decorador: el patr\u00f3n de decorador se utiliza para agregar funcionalidad a un objeto de forma din\u00e1mica, sin cambiar su estructura original.</p> <p>Por ejemplo, imagine que tiene un autom\u00f3vil y desea agregarle un sistema de navegaci\u00f3n GPS. El patr\u00f3n decorador le permitir\u00eda agregar el sistema GPS sin tener que modificar el propio autom\u00f3vil.</p> <p>\u2022 Patr\u00f3n de comando: el patr\u00f3n de comando se usa para encapsular una solicitud como un objeto, lo que permite que se almacene, pase y ejecute en un momento posterior.</p> <p>Por ejemplo, imagina que tienes un sistema de automatizaci\u00f3n del hogar que te permite controlar las luces, el termostato y otros dispositivos. El patr\u00f3n de comando le permitir\u00eda encapsular cada comando (por ejemplo, encender las luces), almacenarlo como un objeto y ejecutarlo m\u00e1s tarde.</p> <p>\u2022 Patr\u00f3n de f\u00e1brica: el patr\u00f3n de f\u00e1brica se utiliza para crear objetos sin exponer la l\u00f3gica de creaci\u00f3n al cliente.</p> <p>Por ejemplo, imagina que tienes un juego con diferentes niveles, cada uno con su propio conjunto de enemigos. El patr\u00f3n de f\u00e1brica te permitir\u00eda crear enemigos para cada nivel sin exponer la l\u00f3gica de creaci\u00f3n al cliente.</p> <p>\u2022 Patr\u00f3n compuesto: el patr\u00f3n compuesto se utiliza para crear una estructura de objetos en forma de \u00e1rbol, donde los objetos individuales y los grupos de objetos se tratan de la misma manera.</p> <p>Por ejemplo, imagine que tiene un sistema de archivos, donde los archivos y los directorios se tratan de la misma manera. El patr\u00f3n compuesto le permitir\u00eda tratar archivos y directorios individuales como el mismo tipo de objeto y crear una estructura similar a un \u00e1rbol de todo el sistema de archivos.</p>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li>\ud83d\udd17 0w8States/PLC-Design-Patterns</li> </ul>"},{"location":"UML/Class%20UML/","title":"Class UML","text":""},{"location":"UML/Class%20UML/#class-uml","title":"Class UML","text":"<p>La jerarqu\u00eda de herencia se puede representar en forma de diagrama. El lenguaje de modelado unificado (UML) es el est\u00e1ndar establecido en esta \u00e1rea. UML define varios tipos de diagramas que describen tanto la estructura como el comportamiento del software.</p> <p>Una buena herramienta para describir la jerarqu\u00eda de herencia de bloques de funciones es el diagrama de clases.</p> <p>Los diagramas UML se pueden crear directamente en TwinCAT 3. Los cambios en el diagrama UML tienen un efecto directo en las POU. Por lo tanto, los bloques de funciones se pueden modificar y modificar a trav\u00e9s del diagrama UML.</p> <p>Cada caja representa un bloque de funci\u00f3n y siempre se divide en tres secciones horizontales. La secci\u00f3n superior muestra el nombre del bloque de funciones, la secci\u00f3n central enumera sus propiedades y la secci\u00f3n inferior enumera todos sus m\u00e9todos. En este ejemplo, las flechas muestran la direcci\u00f3n de la herencia y siempre apuntan hacia el bloque de funciones principal.</p>"},{"location":"UML/Class%20UML/#links-uml-listado-de-referencias","title":"Links UML listado de referencias:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net, UML Class</li> <li> <p>\ud83d\udd17 www.lucidchart.com/tutorial-de-diagrama-de-clases-uml</p> </li> <li> <p>\ud83d\udd17 www.edrawsoft.com/uml-class-diagram-explained</p> </li> <li> <p>\ud83d\udd17 blog.visual-paradigm.com/what-are-the-six-types-of-relationships-in-uml-class-diagrams</p> </li> <li> <p>\ud83d\udd17 Ingenier\u00eda del Software: Fundamentos de UML usando Papyrus</p> </li> <li> <p>\ud83d\udd17 plantuml.com/class-diagram</p> </li> <li> <p>\ud83d\udd17 www.planttext.com</p> </li> <li> <p>\ud83d\udd17 UML Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 Tutorial - Diagrama de Clases UML</p> </li> </ul>"},{"location":"UML/Statechart%20UML/","title":"StateChart UML","text":""},{"location":"UML/Statechart%20UML/#state-chart","title":"state chart:","text":""},{"location":"UML/UML/","title":"UML","text":""},{"location":"UML/UML/#uml","title":"UML","text":"<ul> <li>https://www.plccoder.com/twincat-uml-class-diagram/</li> </ul>"},{"location":"UML/relaciones/","title":"Relaciones","text":"<p>.Relaciones:</p> <p>Vamos a ver 2 tipos de relaciones:</p> <ul> <li>Asociaci\u00f3n.<ul> <li>De uno a uno: Una clase mantiene una asociaci\u00f3n de a uno con otra clase.</li> <li>De uno a muchos: Una clase mantiene una asociaci\u00f3n con otra clase a trav\u00e9s de una colecci\u00f3n.</li> <li>De muchos a muchos: La asociaci\u00f3n se da en ambos lados a trav\u00e9s de una colecci\u00f3n.</li> </ul> </li> <li>Colaboraci\u00f3n.<ul> <li>La colaboraci\u00f3n se da a trav\u00e9s de una referencia de una clase con el fin de lograr un cometido. </li> </ul> </li> </ul>"},{"location":"principios/_principios%20OOP/","title":"4 Pilares","text":"<p> Principios OOP: (4 pilares) </p> <ul> <li>Abstracci\u00f3n -- La forma de plasmar algo hacia el c\u00f3digo para enfocarse en su uso. No enfocarnos tanto en que hay por detras del codigo si no en el uso de este.</li> <li>Encapsulamiento -- No toda la informaci\u00f3n de nuestro objeto es relevante y/o accesible para el usuario.</li> <li>Herencia -- Es la cualidad de heredar caracteristicas de otra clase. (EXTENDS)</li> <li>Polimorfismo -- Las m\u00faltiples formas que puede obtener un objeto si comparte la misma clase o interfaz. (IMPLEMENTS) </li> </ul> <p></p>"},{"location":"principios/abstraccion/","title":"Abstracci\u00f3n","text":""},{"location":"principios/abstraccion/#abstraccion","title":"abstraccion","text":"<p>Abstraction is the process of hiding important information, showing only the most essential  information. It reduces code complexity and isolates the impact of changes. Abstraction can be understood from a real-life example: turning on a television must only  require clicking on a button, as people don\u2019t need to know or the process that it goes through. Even though that process can be complex and important, there is no need for the user to know  how it is implemented. The important information that isn\u2019t required is hidden from the user,  reducing code complexity, enhancing data hiding and reusability, thus making function  blocks easier to implement and modify.</p> <p>La palabra clave ABSTRACT est\u00e1 disponible para bloques de funciones, m\u00e9todos y propiedades. Permite la implementaci\u00f3n de un proyecto PLC con niveles de abstracci\u00f3n.</p> <p>La abstracci\u00f3n es un concepto clave de la programaci\u00f3n orientada a objetos. Los diferentes niveles de abstracci\u00f3n contienen aspectos de implementaci\u00f3n generales o espec\u00edficos.</p>"},{"location":"principios/abstraccion/#aplicacion-de-la-abstraccion","title":"Aplicaci\u00f3n de la abstracci\u00f3n:","text":"<p>Es \u00fatil implementar funciones b\u00e1sicas o puntos en com\u00fan de diferentes clases en una clase b\u00e1sica abstracta. Se implementan aspectos espec\u00edficos en subclases no abstractas. El principio es similar al uso de una interfaz. Las interfaces corresponden a clases puramente abstractas que contienen s\u00f3lo m\u00e9todos y propiedades abstractas. Una clase abstracta tambi\u00e9n puede contener m\u00e9todos y propiedades no abstractos.</p> <p>Reglas para el uso de la palabra clave ABSTRACT - No se pueden instanciar bloques de funciones abstractas. - Los bloques de funciones abstractas pueden contener m\u00e9todos y propiedades abstractos y no abstractos. - Los m\u00e9todos abstractos o las propiedades no contienen ninguna implementaci\u00f3n (s\u00f3lo la declaraci\u00f3n). - Si un bloque de funci\u00f3n contiene un m\u00e9todo o propiedad abstracta, debe ser abstracto. - Los bloques de funciones abstractas deben extenderse para poder implementar los m\u00e9todos o propiedades abstractos. - Por lo tanto: un FB derivado debe implementar los m\u00e9todos/propiedades de su FB b\u00e1sico o tambi\u00e9n debe definirse como abstracto.</p> <ul> <li> <p>\ud83d\udd17 ABSTRACT,www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 ABSTRACION Concepto, Infosys Beckhoff</p> </li> </ul>"},{"location":"principios/encapsulamiento/","title":"Encapsulamiento","text":""},{"location":"principios/encapsulamiento/#encapsulamiento","title":"encapsulamiento","text":"<p>La encapsulaci\u00f3n se utiliza para agrupar datos con los m\u00e9todos que operan en ellos y para ocultar datos en su interior. una clase, evitando que personas no autorizadas accedan directamente a ella. Reduce la complejidad del c\u00f3digo y aumenta la reutilizaci\u00f3n. La separaci\u00f3n del c\u00f3digo permite la creaci\u00f3n de rutinas que pueden ser reutilizadas en lugar de copiar y pegar c\u00f3digo, reduciendo la complejidad del programa principal.</p> <ul> <li>https://www.plccoder.com/encapsulation/</li> </ul>"},{"location":"principios/herencia/","title":"Herencia","text":""},{"location":"principios/herencia/#herencia","title":"herencia","text":"<p>Inheritance allows the user to create classes based on other classes. The inherited classes can  use the base class\u2019s functionalities as well as some additional functionalities that the user may  define. It eliminates redundant code, prevents copying and pasting and makes expansion easier.  This is very useful because it allows classes to be extended of modified (overridden) without  changing the base class\u2019s code implementation. What do an old landline phone and a smartphone have in common? Both of them can be  classified as phones. Should they be classified as objects? No, as they also define the properties  and behaviors of a group of objects. A smartphone works just like a regular phone, but it is also  able to take pictures, navigate the internet, and do many other things. So, old landline phone and smartphone are child classes that extend the parent phone class.</p> <p>Superclase: la clase cuyas caracter\u00edsticas se heredan se conoce como superclase (o una clase base o una clase principal).  Subclase: la clase que hereda la otra clase se conoce como subclase (o una clase derivada, clase extendida o clase hija).</p> <ul> <li>\ud83d\udd17 [stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance](https://stefanhenneken.net/2017/04/23/</li> </ul>"},{"location":"principios/polimorfismo/","title":"Polimorfismo","text":""},{"location":"principios/polimorfismo/#polimorfismo","title":"polimorfismo","text":"<p>The concept of polymorphism is derived by the combination of two words: Poly (Many) and  Morphism (Form). It refactors ugly and complex switch cases/case statements. Object-Oriented PLC Programming 8 Polymorphism allows an object to change its appearance and performance depending on the  practical situation in order to be able to carry out a particular task [10]. It can be either static or  dynamic: static polymorphism occurs when the object\u2019s type is defined by the compiler;  dynamic polymorphism occurs when the type is determined during run-time, making it possible  for a same variable to access different objects while the program is running. A good example to explain polymorphism is a Swiss Army Knife (Figure 2.4): Figure 2.4 - Swiss Army Knife A Swiss Army Knife is a single tool that includes a bunch of resources that can be used to solve different issues. Selecting the proper tool, a Swiss Army Knife can be used to efficiently perform a certain set of valuable tasks. In the dual way, a simple adder block that adapts itself  to cope with, for instance, int, float, string, and time data types is an example of a polymorphic  programming resource.</p> <p>\u00bfComo conseguir el Polimorfismo?</p> <p>El polimorfismo se puede obtener gracias a las Interfaces y/o las Clases Abstractas.</p> <p>.Interface: (INTERFACE) - Son un contrato que obliga a una clase a implementar las propiedades y/o m\u00e9todos definidos. - Son una plantilla (sin l\u00f3gica).</p> <p>.Clases Abstractas: (ABSTRACT) - Son Clases que no se pueden instanciar, solo pueden ser implementadas a trav\u00e9s de la herencia.</p> <ul> <li> <p>Diferencias:</p> Clases abstractas Interfaces 1.- Limitadas a una sola implementaci\u00f3n. 1. No tiene limitaci\u00f3n de implementaci\u00f3n. 2.- Pueden definir comportamiento base. 2. Expone propiedades y m\u00e9todos abstractos (sin l\u00f3gica). *** ### Links Polimorfismo: </li> <li> <p>\ud83d\udd17 polymorphism, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 abstract, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 [stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance](https://stefanhenneken.net/2017/04/23/</p> </li> <li> <p>\ud83d\udd17 AT&amp;U, CODESYS - Runtime polymorphism using inheritance (OOP)</p> </li> <li> <p>\ud83d\udd17 AT&amp;U,CODESYS - Runtime polymorphism using an ITF (OOP)</p> </li> </ul>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/","title":"Principio de Abierto Cerrado","text":""},{"location":"solid/Principio%20de%20Abierto_Cerrado/#principio-de-abiertocerrado","title":"Principio de Abierto/Cerrado","text":"<p>La definici\u00f3n del principio abierto/cerrado El Principio Abierto/Cerrado (OCP) fue formulado por Bertrand Meyer en 1988 y establece:</p> <p>Una entidad de software debe estar abierta a extensiones, pero al mismo tiempo cerrada a modificaciones. Entidad de software: Esto significa una clase, bloque de funci\u00f3n, m\u00f3dulo, m\u00e9todo, servicio, ...</p> <p>Abierto: el comportamiento de los m\u00f3dulos de software debe ser extensible.</p> <p>Cerrado: la capacidad de expansi\u00f3n no debe lograrse cambiando el software existente.</p> <p>Cuando Bertrand Meyer defini\u00f3 el Principio Abierto/Cerrado (OCP) a fines de la d\u00e9cada de 1980, la atenci\u00f3n se centr\u00f3 en el lenguaje de programaci\u00f3n C++. Usaba herencia, bien conocida en el mundo orientado a objetos. La disciplina de la orientaci\u00f3n a objetos, que a\u00fan era joven en ese momento, promet\u00eda grandes mejoras en la reutilizaci\u00f3n y la mantenibilidad al permitir que clases concretas se usaran como clases base para nuevas clases.</p> <p>Cuando Robert C. Martin se hizo cargo del principio de Bertrand Meyer en la d\u00e9cada de 1990, lo implement\u00f3 t\u00e9cnicamente de manera diferente. C ++ permite el uso de herencia m\u00faltiple, mientras que la herencia m\u00faltiple rara vez se encuentra en los lenguajes de programaci\u00f3n m\u00e1s nuevos. Por este motivo, Robert C. Martin se centr\u00f3 en el uso de interfaces. Se puede encontrar m\u00e1s informaci\u00f3n al respecto en el libro (enlace publicitario de Amazon *) Arquitectura limpia: el manual pr\u00e1ctico para el dise\u00f1o de software profesional.</p> <p>Resumen Sin embargo, adherirse al principio abierto/cerrado (OCP) conlleva el riesgo de un exceso de ingenier\u00eda. La opci\u00f3n de extensiones solo debe implementarse donde sea espec\u00edficamente necesario. El software no puede dise\u00f1arse de tal manera que todas las extensiones imaginables puedan implementarse sin realizar ajustes en el c\u00f3digo fuente.</p> <p>!!! este link es en aleman, poner el link en ingles cuando salga:!!!</p>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net, iec-61131-3-solid-das-open-closed-principle</p> </li> <li> <p>\ud83d\udd17 stefanhenneken.net, EC 61131-3: SOLID \u2013 The Open/Closed Principle</p> </li> </ul>"},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/","title":"Principio de Inversi\u00f3n de Dependencia","text":""},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/#principio-de-inversion-de-dependencia","title":"Principio de Inversi\u00f3n de Dependencia:","text":""},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-dependency-inversion-principle</p> </li> <li> <p>\ud83d\udd17 Twincontrols__Dependency Injection</p> </li> </ul>"},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/","title":"Principio de Responsabilidad \u00danica","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/#principio-de-responsabilidad-unica","title":"Principio de Responsabilidad \u00danica:","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-single-responsibility-principle</li> </ul>"},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/","title":"Principio de Segregaci\u00f3n de Interfaz","text":""},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/#principio-de-segregacion-de-interfaz","title":"Principio de Segregaci\u00f3n de Interfaz","text":""},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-interface-segregation-principle</p> </li> <li> <p>\ud83d\udd17 IEC 61131-3: SOLID \u2013 The Interface Segregation Principle</p> </li> </ul>"},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/","title":"Principio de Sustituci\u00f3n de Liskov","text":""},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/#principio-de-sustitucion-de-liskov","title":"Principio de sustituci\u00f3n de Liskov","text":""},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/#links","title":"Links:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-liskov-substitution-principle</li> </ul>"},{"location":"solid/_SOLID/","title":"SOLID","text":"<p> - Propuesta por Robert C.Martin en el 2000. - Son recomendaciones para escribir un c\u00f3digo sostenible,mantenible,escalable y robusto. - Beneficios:     - Alta Cohesi\u00f3n. Colaboracion entre clases.     - Bajo Acoplamiento. Evitar que una clase dependa fuertemente de otra clase.</p> <ul> <li>Principio de Responsabilidad \u00danica: Una clase debe tener una raz\u00f3n para existir mas no para cambiar.</li> <li>Principio de Abierto/Cerrado: Las piezas del software deben estar abiertas para la extensi\u00f3n pero cerradas para la modificaci\u00f3n.</li> <li>Principio de Sustituci\u00f3n de Liskov: Las clases subtipos deber\u00edan ser reemplazables por sus clases padres.</li> <li>Principio de Segregaci\u00f3n de Interfaz: Varias interfaces funcionan mejor que una sola.</li> <li>Principio de Inversi\u00f3n de Dependencia: Clases de alto nivel no deben depender de las clases bajo nivel.</li> </ul> <p>Adem\u00e1s de los principios SOLID, existen otros principios como:</p>"},{"location":"solid/_SOLID/#keep-it-simple-stupid-kiss","title":"Keep It Simple, Stupid (KISS).","text":"<p><pre><code>\" Mantenlo Simple, Est\u00fapido \"\n</code></pre> - Evite la complejidad innecesaria en su c\u00f3digo, use soluciones simples para resolver problemas.</p> <ul> <li>Ejemplo: En lugar de escribir un algoritmo personalizado para generar un n\u00famero aleatorio dentro de un rango, use el generador de n\u00fameros aleatorios incorporado en su lenguaje de programaci\u00f3n.</li> </ul>"},{"location":"solid/_SOLID/#dont-repeat-yourself-dry","title":"Don't Repeat Yourself (DRY).","text":"<p><pre><code>\" No te repitas \"\n</code></pre> - Cada pieza de conocimiento debe tener una representaci\u00f3n \u00fanica, inequ\u00edvoca y autorizada dentro de un sistema. - Evite la duplicaci\u00f3n de c\u00f3digo y mantenga su base de c\u00f3digo lo m\u00e1s mantenible y escalable posible. - Ejemplo: En lugar de copiar y pegar el mismo bloque de c\u00f3digo en varios lugares, cree una funci\u00f3n o m\u00f3dulo que se pueda reutilizar.</p>"},{"location":"solid/_SOLID/#law-of-demeter-lod","title":"Law Of Demeter (LOD).","text":"<p><pre><code>\" Habla Solo con tus amigos inmediatos \"\n</code></pre> - La Ley de Demeter (LOD) en programaci\u00f3n es un principio que establece que un objeto debe tener acceso limitado a los objetos relacionados con \u00e9l y solo interactuar con los objetos m\u00e1s cercanos a \u00e9l. En resumen, un objeto no debe conocer la estructura interna de otros objetos y solo debe comunicarse con ellos a trav\u00e9s de una interfaz limitada. - Ejemplo: Si tienes una clase \"Persona\" que tiene un m\u00e9todo \"getNombre()\" y otra clase \"Empresa\" que tiene un m\u00e9todo \"getPersona()\". En lugar de acceder directamente al nombre de la persona desde la clase Empresa, se deber\u00eda llamar al m\u00e9todo \"getNombre()\" de la clase Persona desde fuera de la clase Empresa, para evitar una dependencia innecesaria y mantener una comunicaci\u00f3n limitada entre objetos.</p>"},{"location":"solid/_SOLID/#you-aint-gonna-need-it-yagni","title":"You Ain't Gonna Need It (YAGNI).","text":"<p><pre><code>\" No lo vas a necesitar \"\n</code></pre> - No agregue funcionalidad a su c\u00f3digo hasta que realmente lo necesite.</p> <ul> <li>Ejemplo: No agregue una funci\u00f3n a su aplicaci\u00f3n que permita a los usuarios cambiar el color de la fuente si no es parte de los requisitos principales.</li> </ul> <p>Todos estos principios tienen el objetivo com\u00fan de mejorar la mantenibilidad y la reutilizaci\u00f3n del software.</p>"},{"location":"solid/_SOLID/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 C\u00f3mo explicar conceptos de programaci\u00f3n orientada a objetos a un ni\u00f1o de 6 a\u00f1os</p> </li> <li> <p>\ud83d\udd17 iec-61131-3-solid-five-principles-for-better-software,stefanhenneken.net</p> </li> <li> <p>\ud83d\udd17 kentcdodds.com,aha-programming</p> </li> </ul>"}]}