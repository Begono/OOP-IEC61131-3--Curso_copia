{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"Libraries/","title":"Libraries","text":""},{"location":"Tipos%20de%20Dise%C3%B1o%20para%20programacion%20de%20PLC/","title":"Types of Design for PLC programming","text":""},{"location":"links/","title":"Links OOP","text":""},{"location":"requeriments/","title":"Requeriments","text":""},{"location":"tipos%20de%20paradigmas/","title":"Types of paradigms","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/","title":"Constructor and Destructor","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/","title":"Abstract FB vs. Interface","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/","title":"Function Block Declaration variables","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/","title":"Function Block Access Modifiers","text":""},{"location":"Clases%20y%20Objetos/Function%20Block/","title":"Function Block","text":""},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/","title":"Fluent Interface","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/","title":"Method Declaration of variables","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/","title":"Method access modifiers","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/","title":"Method return variable types","text":""},{"location":"Clases%20y%20Objetos/SUPER%20pointer/","title":"SUPER pointer","text":""},{"location":"Clases%20y%20Objetos/THIS%20pointer/","title":"THIS pointer","text":"<p>THIS pointer The THIS pointer is available to all function blocks and points to the current function block instance. This pointer is required whenever a method contains a local variable which obscures a variable in the function block.</p> <p>An assignment statement within the method sets the value of the local variable. If we want the method to set the value of the local variable in the function block, we need to use the THIS pointer to access it.</p>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/","title":"Classes and Objects","text":""},{"location":"Clases%20y%20Objetos/interface/","title":"Interface","text":""},{"location":"Clases%20y%20Objetos/metodo/","title":"Method","text":""},{"location":"Clases%20y%20Objetos/modificadores%20de%20acceso/","title":"Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/","title":"pointer and reference","text":""},{"location":"Clases%20y%20Objetos/propiedad/","title":"Object Property","text":""},{"location":"Clases%20y%20Objetos/Inheritance/Inheritance%20Function%20Block/","title":"Inheritance Function Block","text":""},{"location":"Clases%20y%20Objetos/Inheritance/Inheritance%20Interface/","title":"Inheritance Interface","text":""},{"location":"Clases%20y%20Objetos/Inheritance/Inheritance%20Structure/","title":"Inheritance Structure","text":""},{"location":"Concepts%20Previous/Tabla%20de%20Modificadores%20de%20acceso/","title":"Access Modifiers Table","text":""},{"location":"Concepts%20Previous/Tipos%20de%20datos/","title":"Type of Data","text":""},{"location":"Concepts%20Previous/Variable%20types%20and%20special%20variables/","title":"Variable types and special variables","text":""},{"location":"Concepts%20Previous/Variable%20types%20and%20special%20variables/#variable-types-and-special-variables","title":"Variable types and special variables:","text":"<p>The variable type defines how and where you can use the variable. The variable type is defined during the variable declaration.</p>"},{"location":"Concepts%20Previous/Variable%20types%20and%20special%20variables/#further-information","title":"Further Information:","text":"<ul> <li>Local Variables - VAR</li> <li>Input Variables - VAR_INPUT</li> <li>Output Variables - VAR_OUTPUT</li> <li>Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</li> <li>Global Variables - VAR_GLOBAL<ul> <li>Solo es posible su declaraci\u00f3n en GVL (Lista de Variables Global)</li> </ul> </li> <li>Temporary Variable - VAR_TEMP<ul> <li>Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.</li> <li>Las variables temporales se declaran localmente entre las palabras clave VAR_TEMP y END_VAR.</li> <li>VAR_TEMP declaraciones s\u00f3lo son posibles en programas y bloques de funciones.</li> <li>TwinCAT reinicializa las variables temporales cada vez que se llama al bloque de funciones.</li> </ul> </li> </ul> <p>La aplicaci\u00f3n s\u00f3lo puede acceder a variables temporales en la parte de implementaci\u00f3n de un programa o bloque de funciones. - Static Variables - VAR_STAT     - Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.     - Las variables est\u00e1ticas se declaran localmente entre las palabras clave VAR_STAT y END_VAR. TwinCAT inicializa las variables est\u00e1ticas cuando se llama por primera vez al bloque de funciones respectivo.     - Puede tener acceso a las variables est\u00e1ticas s\u00f3lo dentro del espacio de nombres donde se declaran las variables (como es el caso de las variables est\u00e1ticas en C). Sin embargo, las variables est\u00e1ticas conservan su valor cuando la aplicaci\u00f3n sale del bloque de funciones. Puede utilizar variables est\u00e1ticas, como contadores para llamadas a funciones, por ejemplo.     - Puede extender variables est\u00e1ticas con una palabra clave de atributo.     - Las variables est\u00e1ticas solo existen una vez. Esto tambi\u00e9n se aplica a las variables est\u00e1ticas de un bloque de funciones o un m\u00e9todo de bloque de funciones, incluso si el bloque de funciones se instancia varias veces. - External Variables - VAR_EXTERNAL     - Las variables externas son variables globales que se \"importan\" en un bloque de funciones.     - Puede declarar las variables entre las palabras clave VAR_EXTERNAL y END_VAR. Si la variable global no existe, se emite un mensaje de error.     - En TwinCAT 3 PLC no es necesario que las variables se declaren como externas. La palabra clave existe para mantener la compatibilidad con IEC 61131-3.     - Si, no obstante, utiliza variables externas, aseg\u00farese de abordar las variables asignadas (con AT %I o AT %Q) s\u00f3lo en la lista global de variables. El direccionamiento adicional de las instancias de variables locales dar\u00eda lugar a duplicaciones en la imagen del proceso.     - Estas variables declaradas tambien tiene que estar declarada la misma variable con el mismo nombre en una GVL (Lista de Varaibles Global) - Instance Variables - VAR_INST     - TwinCAT crea una variable VAR_INST de un m\u00e9todo no en la pila de m\u00e9todos como las variables VAR, sino en la pila de la instancia del bloque de funciones. Esto significa que la variable VAR_INST se comporta como otras variables de la instancia del bloque de funci\u00f3n y no se reinicializa cada vez que se llama al m\u00e9todo.     - VAR_INST variables solo est\u00e1n permitidas en los m\u00e9todos de un bloque de funciones, y el acceso a dicha variable solo est\u00e1 disponible dentro del m\u00e9todo. Puede supervisar los valores de las variables de instancia en la parte de declaraci\u00f3n del m\u00e9todo.     - Las variables de instancia no se pueden extender con una palabra clave de atributo. - Remanent Variables - PERSISTENT, RETAIN Las variables remanentes pueden conservar sus valores m\u00e1s all\u00e1 del tiempo de ejecuci\u00f3n habitual del programa. Las variables remanentes se pueden declarar como variables RETAIN o incluso m\u00e1s estrictamente como variables PERSISTENTES en el proyecto PLC.</p> <p>Un requisito previo para la funcionalidad completa de las variables RETAIN es un \u00e1rea de memoria correspondiente en el controlador (NovRam). Las variables persistentes se escriben solo cuando TwinCAT se apaga. Esto requerir\u00e1 generalmente un UPS correspondiente. Excepci\u00f3n: Las variables persistentes tambi\u00e9n se pueden escribir con el bloque de funci\u00f3n FB_WritePersistentData.</p> <p>Si el \u00e1rea de memoria correspondiente no existe, los valores de las variables RETAIN y PERSISTENT se pierden durante un corte de energ\u00eda.</p> <p>Variables remanentes - PERSISTENT, RETAIN 1:   La declaraci\u00f3n AT no debe utilizarse en combinaci\u00f3n con VAR RETAIN o VAR PERSISTENT.</p> <p>Variables persistentes Puede declarar variables persistentes agregando la palabra clave PERSISTENT despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables PERSISTENTES conservan su valor despu\u00e9s de una terminaci\u00f3n no controlada, un Reset cold o una nueva descarga del proyecto PLC. Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. En otras palabras, TwinCAT solo reinicializa las variables PERSISTENTES durante un origen de Restablecer.</p> <p>Un ejemplo de aplicaci\u00f3n para variables persistentes es un contador de horas de funcionamiento, que debe continuar contando despu\u00e9s de un corte de energ\u00eda y cuando el proyecto PLC se descarga nuevamente.</p> <p>Tabla de informaci\u00f3n general que muestra el comportamiento de las variables PERSISTENTES Despu\u00e9s del comando en l\u00ednea</p> <p>VAR PERSISTENTE</p> <p>Restablecer fr\u00edo</p> <p>Los valores se conservan</p> <p>Restablecer origen</p> <p>Los valores se reinicializan</p> <p>Descargar</p> <p>Los valores se conservan</p> <p>Cambio en l\u00ednea</p> <p>Los valores se conservan</p> <p>Evite usar el tipo de datos POINTER TO en listas de variables persistentes, ya que los valores de direcci\u00f3n pueden cambiar cuando el proyecto PLC se descargue nuevamente. TwinCAT emite las advertencias correspondientes del compilador. Declarar una variable local como PERSISTENTE en una funci\u00f3n no tiene ning\u00fan efecto. La persistencia de datos no se puede utilizar de esta manera. El comportamiento durante un restablecimiento en fr\u00edo puede verse influenciado por el pragma 'TcInitOnReset'</p> <p>Variables RETAIN Puede declarar variables RETAIN agregando la palabra clave RETAIN despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables declaradas como RETAIN dependen del sistema de destino, pero normalmente se administran en un \u00e1rea de memoria separada que debe protegerse contra fallas de energ\u00eda. El llamado controlador Retain asegura que las variables RETAIN se escriban al final de un ciclo PLC y solo en el \u00e1rea correspondiente de la NovRam. El manejo del controlador de retenci\u00f3n se describe en el cap\u00edtulo \"Conservar datos\" de la documentaci\u00f3n de C/C++.</p> <p>Las variables RETAIN conservan su valor despu\u00e9s de una terminaci\u00f3n incontrolada (corte de energ\u00eda). Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. TwinCAT reinicializa las variables RETAIN en un origen de restablecimiento.</p> <p>Una posible aplicaci\u00f3n es un contador de piezas en una planta de producci\u00f3n, que debe seguir contando despu\u00e9s de un corte de energ\u00eda.</p> <p>Tabla general que muestra el comportamiento de las variables RETAIN Despu\u00e9s del comando en l\u00ednea</p> <p>RETENCI\u00d3N DE VAR</p> <p>Restablecer fr\u00edo</p> <p>Los valores se conservan</p> <p>Restablecer origen</p> <p>Los valores se reinicializan</p> <p>Descargar</p> <p>Los valores se conservan - SUPER - THIS - Variable types - attribute keywords     - RETAIN: for remanent variables of type RETAIN     - PERSISTENT: for remanent variables of type PERSISTENT     - CONSTANT: for constants</p>"},{"location":"Concepts%20Previous/Variable%20types%20and%20special%20variables/#_1","title":"Variable types and special variables","text":"<ul> <li> <p>\ud83d\udd17 infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/instance-variables-with-var_inst</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/var_temp-var_stat-and-var_const</p> </li> <li> <p>\ud83d\udd17 Tipos de variables y variables especiales </p> </li> </ul> <p></p> <p></p>"},{"location":"Concepts%20Previous/access%20modifiers/","title":"Access modifiers","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/Strategy%20pattern/","title":"Strategy Pattern","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/The%20Abstract%20Factory%20Pattern/","title":"The Abstract Factory Pattern","text":"<ul> <li>iec-61131-6-abstract-factory-english,stefanhenneken.net</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/","title":"Design patterns","text":""},{"location":"UML/Class%20UML/","title":"Class UML","text":""},{"location":"UML/Statechart%20UML/","title":"StateChart UML","text":""},{"location":"UML/UML/","title":"UML","text":""},{"location":"UML/relations/","title":"Relations","text":""},{"location":"principios/_principios%20OOP/","title":"4 Pillars","text":""},{"location":"principios/abstraccion/","title":"Abstraction","text":""},{"location":"principios/encapsulamiento/","title":"Encapsulation","text":""},{"location":"principios/herencia/","title":"Inheritance","text":""},{"location":"principios/polimorfismo/","title":"Polymorphism","text":""},{"location":"solid/Principio%20de%20Abierto_Cerrado/","title":"Open/Closed Principle - OCP","text":""},{"location":"solid/Principio%20de%20Inversi%C3%B3n%20de%20Dependencia/","title":"Dependency Inversion Principle - DIP","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20%C3%9Anica/","title":"Single Responsibility Principle - SRP","text":""},{"location":"solid/Principio%20de%20Segregaci%C3%B3n%20de%20Interfaz/","title":"Interface Segregation Principle - ISP","text":""},{"location":"solid/Principio%20de%20Sustituci%C3%B3n%20de%20Liskov/","title":"Liskov Substitution Principle - LSP","text":""},{"location":"solid/_SOLID/","title":"SOLID","text":""}]}